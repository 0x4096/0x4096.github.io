<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>行者驰骋风沙，不负青丝韶华</title>
    <url>/2020/09/28/live-up-to-the-youth-of-green-silk.html</url>
    <content><![CDATA[<p>说明：本文转载自2015年前《青年文摘》中的一篇文章，当时很喜欢，一直有收藏在QQ空间的日志，在这特此分享。</p>
<blockquote>
<p>题记：不屈不挠的骑行，无与伦比的风景，战胜死亡的年轻</p>
</blockquote>
<p>我一直觉得，人的每一次蜕变，大抵是从认识自己开始的。</p>
<p>记得之前和同学闲聊中说，我所理解的出行的意义是在另一个地方邂逅另一个自己，行走的愈远，思想愈加曼妙悠长，心境的起伏便愈加跌宕，重逢的自己也必然叹为观止般震慑。</p>
<p>向来追求自由与洒脱，恰用过去的48小时270公里的行程，暂且做一次青春片刻的诠释。</p>
<p>两个月前有幸加入了未来花园骑行团队，适逢五一假期，红屋、独狼、村长带领加我在内志趣相投的十个人，于1日清晨5点40整装待发，开始骑行之旅。为了节省体力，骑行工具率先装车，一人随车看守，其余人搭S2线直奔延庆火车站。法定假日的高速清晨六点便堵得不可开交，我们九人八点不到就到了延庆，随后便是近两小时的等待，也直接导致第一天的行程无法完成。</p>
<p>车终于到了！安好快拆，调好座椅，整理好行囊，村长带队，独狼收队，红屋掌控全局，行者风范，片刻不迟。延庆县内的道路依旧不顺畅，一路走走停停，均速不超过25码，前晚睡觉兴奋到失眠，这种感觉一直没有消失，前十几公里丝毫感觉不到疲惫，时常忍不住回头望去，我们的队伍一字排开，一架公路，九架山地，华装异彩，行若游龙，独秀一路的风景。</p>
<p>出了延庆，沿S221一路前行，路上的车渐渐少了，两旁的树渐渐多了，我们的速度也上升到30码，路途变得有些枯燥，前方一切未知，当天轻度污染，天看起来还是灰蒙蒙的。对未知的好奇扫去了心中滋生的阴霾，队形依然，踏频不减，偶尔风尘袭来，拉起面巾，正午阳光刺眼，戴上夹片，几十公里的缓坡，体力一直在消耗。在此之前，也算是有一定的初级骑行基础，不过都是独行，这次跟随团队，总里程270公里，累计十几公里的陡坡、盘山路，几十公里的起伏路，算是中强度活动。对于单天最多100公里里程，无爬坡经验的选手来说下此决定着实是一次心理和生理上的挑战！活动筹划期间就与红屋商量，不想错过这次难得的机会，又怕如此高的强度身体吃不消，渴望挑战却忧虑半途而废，提醒自己保持理性量力而行，却又感性的无所畏惧，追求极限。一番纠结挣扎与思想对峙之后，毅然决然出发，说到底还是对自己有信心，而此时的信心源于对自己理性的评估，既不自视过高，又不妄自菲薄。</p>
<p>终于休息了！这次休息是为了前方艰巨的任务——5公里盘山路陡坡，大家都在补充能量，随着独狼远去的身影，我们开始上升海拔。爬坡体力消耗巨大，速度只能维持在7-8码，听红屋讲，对新手来说，爬坡3公里是个坎儿，我倒是想挑战下，1km，2km，爬过一条路，抬头望去，越过层层的盘山路，山顶还在高处，继续低着头，豆大的汗珠滴滴的掉，一点不含糊，咬紧牙关扛下去，聚集身上每一寸肌肉的力量到双腿上，时间似乎在那一刻静止了，凝固了空气，定格的画面中唯有脚下的路，前进的方向，此刻的信念是，细流成江河，跬步至千里。</p>
<p>峰回路转，柳暗花明。观景台边，石碑兀立。识得四字，燕山天池。踱至崖边，放眼眺去。不见池水，但见群峰。想必这四字若不是由文人骚客所杜撰，赚的游人空欢喜，便是池水早已干涸，不禁联想到家乡长白山天池。华北地区多的是人文景观，但凡大江大河，峰谷险峻也不会现此平原地区，古人云：“幽州之地，左环沧海，右拥太行，北枕居庸，南襟河济，诚天府之国”。太行山脉余脉终于百望山，此次延庆出发，一路穿梭起伏在燕山山脉，秀色可餐，令人刮目，我说这里堪称小张家界，也记住了这个京郊骑行首屈一指的线路——千家店百里画廊。</p>
<p>话说五岳归来不看山，黄山归来不看岳，张家界归来天下无山，九寨归来世间无水。我倒觉得景色是不能比较的，景色本就在那里，耳听之而为声，目遇之而成色，景固然美，也必须有恬静的心灵与之契合，人在旅途，总会有那么一刻，不知为何所触动，惟愿生落于此间，死葬于此处。</p>
<p>略过燕山天池，右拐上滦赤路，放坡，从未有过的刺激！曲折蜿蜒的盘山路，一路风驰而下，头盔面巾裹得严严实实，耳边的呼啸声承载着速度与激情，在飞驰的瞬间瞄了一眼码表，53公里每小时，相当于每秒钟15米，在保证安全的情况下恣意放纵，奢侈地享受着爬坡的辛苦，然而畅快的感觉却总是那么短暂。</p>
<p>路至缓处，百里画廊。寻常山水，娓娓道来。山峦叠翠，白河流长。硅化木群，乌龙峡谷。石器遗址，地质荟萃。莺啼燕舞，炊晓人家。细流汩汩，劲叶沙沙。十人一字队，翩然若游龙。倏尔天气骤变，风急天阴猿啸哀，雨滴稀落，复行数里，土地平旷，屋舍俨然。避之于屋檐，顷刻之间，骤雨倾盆，众人不禁感叹，雷公生妒，奈何天公作美！</p>
<p>靠谱的天气预报，四时下雨准确无误！半小时之后，天气乍晴，气温忽降。我们加了外套，拍个合影。也正是这场迟来的雨，扫尽了当天的雾霾，赐予我们纤尘不染的风景。千家店是我们的福地，小憩之后，继续上路，原计划是在琉璃庙结束一天的行程，由于早上近两小时的延迟出发，使得第一天的行程少走15公里，下一站，汤河口，安营寨扎。</p>
<p>随团出行就是突出一个省心，结识志同道合的朋友，在这个团队里，村长、独狼还都是大三的本科生，红屋硕士刚刚毕业，还有各个院系的硕士博士，在骑行经验交流上就收获颇丰，每当快至食宿地点，为了节约时间，领队提前加速赶到，预定之后众人坐享其成，行程顺畅极了，凡事用心，才会专业。</p>
<p>一段乏味的平路之后，终于到了汤河口，本来计划夜宿琉璃庙，眼看日暮降临，再行十几公里已然不现实。北京的郊区与市区简直就是两个世界，这里的基础设施建设还赶不上家乡的一个县级市，物价倒是低的惊人，农家院住宿每人二十，一升的脉动售价六元，大盘大盘的荤菜售价不到三十五……那个晚上，听他们讲述之前出团经历中雷人的人和事，讲述京郊的几条经典的路线，爬妙峰山的生不如死，四海的起伏，慈悲峪的良心坡，大家说说笑笑，其乐融融。</p>
<p>住宿条件虽然很简陋，但好久没睡的那么舒服踏实了。次日清晨，六点准时起床，打开水龙头，一股刺骨冰寒的井水将倦意一扫而尽，大家收拾打理完毕，在不远处的包子铺吃了早点，包子馅咸的厉害，我只能吃包子皮，一碗脑豆腐，一个鸡蛋，拼命的用蛋白质为上午的路程积蓄力量。</p>
<p>走过坦途，穿越隧道，高速下面出现一排排歪歪扭扭的房子，琉璃庙到了，遗憾的是，两个队友由于之前的膝伤，加上第一天的高强度骑行，中途选择了退出，他们顺着G6辅路回去了，我们没有做过多挽留，心中为之惋惜却也无能为力，短暂的道别之后，剩下了我们八个人，这是我忽然感到有种压迫感，在路上我一直不敢排在最后，这样感觉会被人带着节奏或者拖累大家，可如今剩下的人中实力都不在我之下，想必是要拖后腿了。片刻的矛盾之后，继续爬坡，这次的坡比昨天的还有长还有陡，不过有了第一天的经验，显得得心应手了。我的经验就是再怎么累也不能下车推着走，在车上最慢速度也能维持在7-8，推着走就5-6了，而且最关键的是车上累大腿，推着走累小腿，如果掌握好节奏，调整合适的踏频，也可以达到遍骑遍休息的目的，一旦停下来，再次启动会更累。</p>
<p>海拔大约上升至一千米的时候，我们到达了峰顶，放下自行车，爬上观景台，当天晴空万里，俯瞰白河峡谷，近百米高的悬崖如利剑将白河劈开，巍峨的明长城在山间蜿蜒伸展，两岸峭壁林立，山泉汇成浩荡的激流，沿白河溯流而上，直至云蒙山北麓，堪称白河峡谷瑰丽壮观之精华！</p>
<p>悬崖陡壁，刀削斧劈。奇峰耸立，怪石嶙峋。苍松古柏，雄鹰盘旋。恍似云梦仙境，与三峡比肩，与漓江媲美！天蓝得没有一丝留白，山翠得不见半处阴郁，路平得没有一粒石子，人静得可以聆听鸟鸣。那一刻的感受堪称销魂！这种极致的享受也只有零距离的置身自然才会拥有。</p>
<p>一百六十公里的返程路，我回来了，并没有到达所谓的极限。一路上，有路人惊异的赞许，有迎面车友的鼓励，有红屋细致入微的领导，有团结一致驶向终点的众志成城。</p>
<p>世之奇伟、瑰怪、非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。苟活的意义是安稳，生活的意义是尝试，而生命的意义是挑战！</p>
<p>这只是一个开始，未来充满期待，青海湖，海南岛，川藏线……</p>
<p>一次不屈不挠的骑行，印刻无与伦比的风景，笃信战胜死亡的年轻！</p>
<p>幸甚的生命，尚好的青春！</p>
<p>一点浩然气，千里快哉风！</p>]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」解决死锁之路2 - 了解常见的锁类型</title>
    <url>/2023/08/28/mysql-lock-type.html</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html</a></p>
</blockquote>
<p>在上一篇博客中，我们学习了事务以及事务并发时可能遇到的问题，并介绍了四种不同的隔离级别来解决这些并发问题，在隔离级别的实现一节中，我们提到了锁的概念，锁是实现事务并发的关键。其实，锁的概念不仅仅出现在数据库中，在大多数的编程语言中也存在，譬如 Java 中的 synchronized，C# 中的 lock 等，所以对于开发同学来说应该是不陌生的。但是数据库中的锁有很多花样，一会是行锁表锁，一会是读锁写锁，又一会是记录锁意向锁，概念真是层出不穷，估计很多同学就晕了。</p>
<p>在讨论传统的隔离级别实现的时候，我们就提到：通过对锁的类型（读锁还是写锁），锁的粒度（行锁还是表锁），持有锁的时间（临时锁还是持续锁）合理的进行组合，就可以实现四种不同的隔离级别；但是上一篇博客中并没有对锁做更深入的介绍，我们这一篇就来仔细的学习下 MySQL 中常见的锁类型。</p>
<p>这是《解决死锁之路》系列博文中的一篇，你还可以阅读其他几篇：</p>
<ol>
<li><a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">学习事务与隔离级别</a></li>
<li><a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">了解常见的锁类型</a></li>
<li><a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html">掌握常见 SQL 语句的加锁分析</a></li>
<li><a href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">死锁问题的分析和解决</a></li>
</ol>
<h1 id="一、表锁-vs-行锁"><a href="#一、表锁-vs-行锁" class="headerlink" title="一、表锁 vs. 行锁"></a>一、表锁 vs. 行锁</h1><p>在 MySQL 中锁的种类有很多，但是最基本的还是表锁和行锁：表锁指的是对一整张表加锁，一般是 DDL 处理时使用，也可以自己在 SQL 中指定；而行锁指的是锁定某一行数据或某几行，或行和行之间的间隙。行锁的加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，通常都是用行锁来处理并发事务。表锁由 MySQL 服务器实现，行锁由存储引擎实现，常见的就是 InnoDb，所以通常我们在讨论行锁时，隐含的一层意义就是数据库的存储引擎为 InnoDb ，而 MyISAM 存储引擎只能使用表锁。</p>
<h2 id="1-1-表锁"><a href="#1-1-表锁" class="headerlink" title="1.1 表锁"></a>1.1 表锁</h2><p>表锁由 MySQL 服务器实现，所以无论你的存储引擎是什么，都可以使用。一般在执行 DDL 语句时，譬如 <strong>ALTER TABLE</strong> 就会对整个表进行加锁。在执行 SQL 语句时，也可以明确对某个表加锁，譬如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; lock table products read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from products where id = 100;</span><br><span class="line"> </span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>上面的 SQL 首先对 products 表加一个表锁，然后执行查询语句，最后释放表锁。表锁可以细分成两种：读锁和写锁，如果是加写锁，则是 <code>lock table products write</code> 。详细的语法可以参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html">MySQL 的官网文档</a>。</p>
<p>关于表锁，我们要了解它的加锁和解锁原则，要注意的是它使用的是 <strong>一次封锁</strong> 技术，也就是说，我们会在会话开始的地方使用 lock 命令将后面所有要用到的表加上锁，在锁释放之前，我们只能访问这些加锁的表，不能访问其他的表，最后通过 unlock tables 释放所有表锁。这样的好处是，不会发生死锁！所以我们在 MyISAM 存储引擎中，是不可能看到死锁场景的。对多个表加锁的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; lock table products read, orders read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from products where id = 100;</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from orders where id = 200;</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from users where id = 300;</span><br><span class="line">ERROR 1100 (HY000): Table &#x27;users&#x27; was not locked with LOCK TABLES</span><br><span class="line"> </span><br><span class="line">mysql&gt; update orders set price = 5000 where id = 200;</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;orders&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"> </span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以看到由于没有对 users 表加锁，在持有表锁的情况下是不能读取的，另外，由于加的是读锁，所以后面也不能对 orders 表进行更新。MySQL 表锁的加锁规则如下：</p>
<ul>
<li>对于读锁<ul>
<li>持有读锁的会话可以读表，但不能写表；</li>
<li>允许多个会话同时持有读锁；</li>
<li>其他会话就算没有给表加读锁，也是可以读表的，但是不能写表；</li>
<li>其他会话申请该表写锁时会阻塞，直到锁释放。</li>
</ul>
</li>
<li>对于写锁<ul>
<li>持有写锁的会话既可以读表，也可以写表；</li>
<li>只有持有写锁的会话才可以访问该表，其他会话访问该表会被阻塞，直到锁释放；</li>
<li>其他会话无论申请该表的读锁或写锁，都会阻塞，直到锁释放。</li>
</ul>
</li>
</ul>
<p>锁的释放规则如下：</p>
<ul>
<li>使用 UNLOCK TABLES 语句可以显示释放表锁；</li>
<li>如果会话在持有表锁的情况下执行 LOCK TABLES 语句，将会释放该会话之前持有的锁；</li>
<li>如果会话在持有表锁的情况下执行 START TRANSACTION 或 BEGIN 开启一个事务，将会释放该会话之前持有的锁；</li>
<li>如果会话连接断开，将会释放该会话所有的锁。</li>
</ul>
<h2 id="1-2-行锁"><a href="#1-2-行锁" class="headerlink" title="1.2 行锁"></a>1.2 行锁</h2><p>表锁不仅实现和使用都很简单，而且占用的系统资源少，所以在很多存储引擎中使用，如 MyISAM、MEMORY、MERGE 等，MyISAM 存储引擎几乎完全依赖 MySQL 服务器提供的表锁机制，查询自动加表级读锁，更新自动加表级写锁，以此来解决可能的并发问题。但是表锁的粒度太粗，导致数据库的并发性能降低，为了提高数据库的并发能力，InnoDb 引入了行锁的概念。行锁和表锁对比如下：</p>
<ul>
<li>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</li>
<li>行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<p>行锁和表锁一样，也分成两种类型：读锁和写锁。常见的增删改（INSERT、DELETE、UPDATE）语句会自动对操作的数据行加写锁，查询的时候也可以明确指定锁的类型，SELECT … LOCK IN SHARE MODE 语句加的是读锁，SELECT … FOR UPDATE 语句加的是写锁。</p>
<p>行锁这个名字听起来像是这个锁加在某个数据行上，实际上这里要指出的是：在 MySQL 中，行锁是加在索引上的。所以要深入了解行锁，还需要先了解下 MySQL 中索引的结构。</p>
<h3 id="1-2-1-MySQL-的索引结构"><a href="#1-2-1-MySQL-的索引结构" class="headerlink" title="1.2.1 MySQL 的索引结构"></a>1.2.1 MySQL 的索引结构</h3><p>我们知道，数据库中索引的作用是方便服务器根据用户条件快速查找数据库中的数据。在一堆有序的数据集中查找某条特定的记录，通常我们会使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">二分查找算法（Binary search）</a>，使用该算法查询一组固定长度的数组数据是没问题的，但是如果数据集是动态增减的，使用扁平的数组结构就变得不那么方便了。所以，后来又发明了一种新的数据结构：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树（Binary search tree）</a>，又叫做排序二叉树（Sorted binary tree），使用树形结构的好处是，可以大大的提高数据插入和删除的复杂度。二叉查找树查找算法的复杂度依赖于树的高度，为 O(log n)，譬如下面这样的一颗 3 层的二叉查找树，查找任意元素最多不超过 3 次比较就可以找到。</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/3887402864.png" alt="binary-search-tree.png"></p>
<p>当然这是最理想的一种情况，我们考虑下最糟糕的一种情况，当数据本身就是有序的时候，生成的二叉树将会退化为线性表，复杂度就变成了 O(n)，如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/1895065164.png" alt="binary-search-tree-line.png"></p>
<p>为了解决这个问题，人们又想出了一种新的解决方法，那就是<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91">平衡树（Balanced search tree）</a>，其实平衡树有很多种，但是通常我们讨论的是 <a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL 树</a>，这个名字来自于它的发明者：G.M. Adelson-Velsky 和 E.M. Landis。通过平衡树的 <strong>树旋转</strong> 操作，可以使得任何情况下二叉树的任意两个子树高度最大差为 1，也就是说让二叉树一直保持着矮矮胖胖的身材，这样保证对树的所有操作最坏复杂度都是 O(log n)。</p>
<p>那这些树结构和 MySQL 的索引有什么关系呢？其实，无论是 InnoDb 还是 MyISAM 存储引擎，它们的索引采用的数据结构都是<a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+ 树</a>，而 B+ 树又是从 <a href="https://zh.wikipedia.org/wiki/B%E6%A0%91">B 树</a>演变而来。二叉树虽然查找效率很高，但是也有着一些局限性，特别是当数据存储于外部设备时（如数据库或文件系统），因为这个时候不仅需要考虑算法本身的复杂度，还需要考虑程序与外部设备之间的读写效率。在二叉树中，每一个树节点只保存一条数据，并且最多有两个子节点。程序在查找数据时，读取一条数据，比较，再读取另一条数据，再比较，再读取，如此往复。每读取一次，都涉及到程序和外部设备之间的 IO 开销，而这个开销将大大降低程序的查找效率。于是，便有人提出了增加节点保存的数据条数的想法，譬如 <a href="https://zh.wikipedia.org/wiki/2-3%E6%A0%91">2-3 树</a>（每个节点保存 1 条或 2 条数据）、<a href="https://zh.wikipedia.org/wiki/2-3-4%E6%A0%91">2-3-4 树</a>（每个节点保存 1 条、2 条或 3 条数据）等，当然也不用限定得这么死，数值范围可以 1 - n 条，这就是 B 树。在实际应用中，会根据硬盘上一个 page 的大小来调整 n 的数值，这样可以让一次 IO 操作就读取到 n 条数据，减少了 IO 开销，并且，树的高度显著降低了，查找时只需几次 page 的 IO 即可定位到目标（page 翻译为中文为页，表示 InnoDB 每次从磁盘（data file）到内存（buffer pool）之间传送数据的大小）。一颗典型的 B 树如下图所示（<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">图片来源</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/3506926970.png" alt="btree.png"></p>
<p>不过在现实场景里几乎没有地方在使用 B 树，这是因为 B 树没有很好的伸缩性，它将多条数据都保存在节点里，如果数据中某个字段太长，一个 page 能容纳的数据量将受到限制，最坏的情况是一个 page 保存一条数据，这个时候 B 树退化成二叉树；另外 B 树无法修改字段最大长度，除非调整 page 大小，重建整个数据库。于是，B+ 树横空出世，在 B+ 树里，内节点（非叶子节点）中不再保存数据，而只保存用于查找的 key，并且所有的叶子节点按顺序使用链表进行连接，这样可以大大的方便范围查询，只要先查到起始位置，然后按链表顺序查找，一直查到结束位置即可。如下图所示（<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">图片来源</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/2847462571.png" alt="b+tree.png"></p>
<p>那么在 B+ 树中，数据保存在什么地方呢？关于这一点，InnoDb 和 MyISAM 的实现是不一样的，InnoDb 将数据保存在叶子节点中，而 MyISAM 将数据保存在独立的文件中，MyISAM 有三种类型的文件：*.frm 用于存储表的定义，*.MYI 用于存放表索引，*.MYD 用于存放数据。MYD 文件中的数据是以堆表的形式存储的，所以像 MyISAM 这样以堆形式存储数据的我们通常把它叫做 <strong>堆组织表（Heap organized table，简称 HOT）</strong>，而像 InnoDb 这种将数据保存在叶子节点中，叫做 <strong>索引组织表（Index organized table，简称 IOT）</strong>。</p>
<p>MyISAM 索引结构如下图所示（<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">图片来源</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/1183701961.png" alt="index-myisam.png"></p>
<p>InnoDb 索引结构如下图所示（<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">图片来源</a>）：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/1483339495.png" alt="index-innodb.png"></p>
<p>可以看到，MyISAM 索引的 B+ 树中，非叶子节点中保存 key，叶子节点中保存着数据的地址，指向数据文件中数据的位置；InnoDb 索引的 B+ 树中，非叶子节点和 MyISAM 一样保存 key，但是叶子节点直接保存数据。所以，MyISAM 在通过索引查找数据时，必须通过两步才能拿到数据（先获取数据的地址，再读取数据文件），InnoDb 在通过索引查找数据时，可以直接读取数据。</p>
<p>注意上面两张图都是对应着 Primary Key 的情况，MySQL 有两种索引类型：主键索引（Primary Index）和非主键索引（Secondary Index，又称为二级索引、辅助索引），MyISAM 存储引擎对两种索引的存储没有区别，InnoDb 存储引擎的数据是保存在主键索引里的，非主键索引里保存着该节点对应的主键。所以 InnoDb 的主键索引有时候又被称为 <strong>聚簇索引（Clustered Index）</strong>，二级索引被称为 <strong>非聚簇索引（Nonclustered Index）</strong>。如果没有主键，InnoDB 会试着使用一个非空的唯一索引（Unique nonnullable index）代替；如果没有这种索引，会定义一个隐藏的主键。所以 InnoDb 的表一定会有主键索引。关于聚簇索引和二级索引，可以参看这里的 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">MySQL 文档</a>。（疑惑：MyISAM 如果没有索引，会怎么样？会定义隐藏的主键吗？）</p>
<h3 id="1-2-2-MySQL-加锁流程"><a href="#1-2-2-MySQL-加锁流程" class="headerlink" title="1.2.2 MySQL 加锁流程"></a>1.2.2 MySQL 加锁流程</h3><p>关于 MySQL 的索引是一个很大的话题，譬如，增删改查时 B+ 树的调整算法是怎样实现的，如何通过索引加快 SQL 的执行速度，如何优化索引，等等等等。我们这里为了加强对锁的理解，只需要了解索引的数据结构即可。当执行下面的 SQL 时（id 为 students 表的主键），我们要知道，InnoDb 存储引擎会在 id &#x3D; 49 这个主键索引上加一把 X 锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update students set score = 100 where id = 49;</span><br></pre></td></tr></table></figure>



<p>当执行下面的 SQL 时（name 为 students 表的二级索引），InnoDb 存储引擎会在 name &#x3D; ‘Tom’ 这个索引上加一把 X 锁，同时会通过 name &#x3D; ‘Tom’ 这个二级索引定位到 id &#x3D; 49 这个主键索引，并在 id &#x3D; 49 这个主键索引上加一把 X 锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update students set score = 100 where name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure>



<p>加锁过程如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/1423030488.png" alt="index-innodb-locks.png"></p>
<p>像上面这样的 SQL 比较简单，只操作单条记录，如果要同时更新多条记录，加锁的过程又是什么样的呢？譬如下面的 SQL（假设 score 字段为二级索引）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update students set level = 3 where score &gt;= 60;</span><br></pre></td></tr></table></figure>



<p>下图展示了当用户执行这条 SQL 时，MySQL Server 和 InnoDb 之间的执行流程：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/201797556.png" alt="innodb-locks-multi-lines.png"></p>
<p>从图中可以看到当 UPDATE 语句被发给 MySQL 后，MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁（current read），待 MySQL Server 收到这条加锁的记录之后，会再发起一个 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，MySQL 在操作多条记录时 InnoDB 与 MySQL Server 的交互是一条一条进行的，加锁也是一条一条依次进行的，先对一条满足条件的记录加锁，返回给 MySQL Server，做一些 DML 操作，然后在读取下一条加锁，直至读取完毕。理解这一点，对我们后面分析复杂 SQL 语句的加锁过程将很有帮助。</p>
<h3 id="1-2-3-行锁种类"><a href="#1-2-3-行锁种类" class="headerlink" title="1.2.3 行锁种类"></a>1.2.3 行锁种类</h3><p>根据锁的粒度可以把锁细分为表锁和行锁，行锁根据场景的不同又可以进一步细分，在 MySQL 的源码里，定义了四种类型的行锁，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LOCK_TABLE  16  /* table lock */</span><br><span class="line">#define LOCK_REC    32  /* record lock */</span><br><span class="line"> </span><br><span class="line">/* Precise modes */</span><br><span class="line">#define LOCK_ORDINARY   0   </span><br><span class="line">#define LOCK_GAP    512 </span><br><span class="line">#define LOCK_REC_NOT_GAP 1024   </span><br><span class="line">#define LOCK_INSERT_INTENTION 2048</span><br></pre></td></tr></table></figure>



<ul>
<li>LOCK_ORDINARY：也称为 <strong>Next-Key Lock</strong>，锁一条记录及其之前的间隙，这是 RR 隔离级别用的最多的锁，从名字也能看出来；</li>
<li>LOCK_GAP：间隙锁，锁两个记录之间的 GAP，防止记录插入；</li>
<li>LOCK_REC_NOT_GAP：只锁记录；</li>
<li>LOCK_INSERT_INTENSION：插入意向 GAP 锁，插入记录时使用，是 LOCK_GAP 的一种特例。</li>
</ul>
<p>这四种行锁将是理解并解决数据库死锁的关键，我们下面将深入研究这四种锁的特点。但是在介绍这四种锁之前，让我们再来看下 MySQL 下锁的模式。</p>
<h1 id="二、读锁-vs-写锁"><a href="#二、读锁-vs-写锁" class="headerlink" title="二、读锁 vs. 写锁"></a>二、读锁 vs. 写锁</h1><p>MySQL 将锁分成两类：锁类型（lock_type）和锁模式（lock_mode）。锁类型就是上文中介绍的表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方；而锁模式描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的，锁模式在 MySQL 的源码中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Basic lock modes */</span><br><span class="line">enum lock_mode &#123;</span><br><span class="line">    LOCK_IS = 0, /* intention shared */</span><br><span class="line">    LOCK_IX,    /* intention exclusive */</span><br><span class="line">    LOCK_S,     /* shared */</span><br><span class="line">    LOCK_X,     /* exclusive */</span><br><span class="line">    LOCK_AUTO_INC,  /* locks the auto-inc counter of a table in an exclusive mode*/</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>LOCK_IS：读意向锁；</li>
<li>LOCK_IX：写意向锁；</li>
<li>LOCK_S：读锁；</li>
<li>LOCK_X：写锁；</li>
<li>LOCK_AUTO_INC：自增锁；</li>
</ul>
<p>将锁分为读锁和写锁主要是为了提高读的并发，如果不区分读写锁，那么数据库将没办法并发读，并发性将大大降低。而 IS（读意向）、IX（写意向）只会应用在表锁上，方便表锁和行锁之间的冲突检测。LOCK_AUTO_INC 是一种特殊的表锁。下面依次进行介绍。</p>
<h2 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h2><p>读锁和写锁都是最基本的锁模式，它们的概念也比较容易理解。读锁，又称共享锁（Share locks，简称 S 锁），加了读锁的记录，所有的事务都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。写锁，又称排他锁（Exclusive locks，简称 X 锁），或独占锁，对记录加了排他锁之后，只有拥有该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。（注意：这里说的读都是当前读，快照读是无需加锁的，记录上无论有没有锁，都可以快照读）</p>
<p>在其他的数据库系统中（譬如 MSSQL），我们可能还会看到一种基本的锁模式：更新锁（Update locks，简称 U 锁），MySQL 暂时不支持 U 锁，所以这里只是稍微了解一下。这个锁主要是用来防止死锁的，因为多数数据库在加 X 锁的时候是先获取 S 锁，获取成功之后再升级成 X 锁，如果有两个事务同时获取了 S 锁，然后又同时尝试升级 X 锁，就会发生死锁。增加 U 锁表示有事务对该行有更新意向，只允许一个事务拿到 U 锁，该事务在发生写后 U 锁变 X 锁，未写时看做 S 锁。（疑问：MySQL 更新的时候是直接申请 X 锁么？）</p>
<h2 id="2-2-读写意向锁"><a href="#2-2-读写意向锁" class="headerlink" title="2.2 读写意向锁"></a>2.2 读写意向锁</h2><p>表锁锁定了整张表，而行锁是锁定表中的某条记录，它们俩锁定的范围有交集，因此表锁和行锁之间是有冲突的。譬如某个表有 10000 条记录，其中有一条记录加了 X 锁，如果这个时候系统需要对该表加表锁，为了判断是否能加这个表锁，系统需要遍历表中的所有 10000 条记录，看看是不是某条记录被加锁，如果有锁，则不允许加表锁，显然这是很低效的一种方法，为了方便检测表锁和行锁的冲突，从而引入了意向锁。</p>
<p>意向锁为表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。当事务试图读或写某一条记录时，会先在表上加上意向锁，然后才在要操作的记录上加上读锁或写锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。</p>
<p>下面是各个表锁之间的兼容矩阵：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/10/1431433403.png" alt="table-locks-compatible-matrix.png"></p>
<p>这个矩阵看上去有点眼花缭乱，其实很简单，因为是斜对称的，所以我们用一条斜线把表格分割成两个部分，只需要看左下角的一半即可。总结起来有下面几点：</p>
<ul>
<li>意向锁之间互不冲突；</li>
<li>S 锁只和 S&#x2F;IS 锁兼容，和其他锁都冲突；</li>
<li>X 锁和其他所有锁都冲突；</li>
<li>AI 锁只和意向锁兼容；</li>
</ul>
<h2 id="2-3-AUTO-INC-锁"><a href="#2-3-AUTO-INC-锁" class="headerlink" title="2.3 AUTO_INC 锁"></a>2.3 AUTO_INC 锁</h2><p>AUTO_INC 锁又叫自增锁（一般简写成 AI 锁），它是一种特殊类型的表锁，当插入的表中有自增列（AUTO_INCREMENT）的时候可能会遇到。当插入表中有自增列时，数据库需要自动生成自增值，在生成之前，它会先为该表加 AUTO_INC 表锁，其他事务的插入操作阻塞，这样保证生成的自增值肯定是唯一的。AUTO_INC 锁具有如下特点：</p>
<ul>
<li>AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁；</li>
<li>自增锁不遵循二段锁协议，它并不是事务结束时释放，而是在 INSERT 语句执行结束时释放，这样可以提高并发插入的性能；</li>
<li>自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。</li>
</ul>
<p>显然，AUTO_INC 表锁会导致并发插入的效率降低，为了提高插入的并发性，MySQL 从 5.1.22 版本开始，引入了一种可选的轻量级锁（mutex）机制来代替 AUTO_INC 锁，我们可以通过参数 <code>innodb_autoinc_lock_mode</code> 控制分配自增值时的并发策略。参数 <code>innodb_autoinc_lock_mode</code> 可以取下列值：</p>
<ul>
<li>innodb_autoinc_lock_mode &#x3D; 0 （traditional lock mode）<ul>
<li>使用传统的 AUTO_INC 表锁，并发性比较差。</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode &#x3D; 1 （consecutive lock mode）<ul>
<li>MySQL 默认采用这种方式，是一种比较折中的方法。</li>
<li>MySQL 将插入语句分成三类：<code>Simple inserts、Bulk inserts、Mixed-mode inserts</code>。通过分析 INSERT 语句可以明确知道插入数量的叫做 <code>Simple inserts</code>，譬如最经常使用的 INSERT INTO table VALUE(1,2) 或 INSERT INTO table VALUES(1,2), (3,4)；通过分析 INSERT 语句无法确定插入数量的叫做 <code>Bulk inserts</code>，譬如 INSERT INTO table SELECT 或 LOAD DATA 等；还有一种是不确定是否需要分配自增值的，譬如 INSERT INTO table VALUES(1,’a’), (NULL,’b’), (5, ‘C’), (NULL, ‘d’) 或 INSERT … ON DUPLICATE KEY UPDATE，这种叫做 <code>Mixed-mode inserts</code>。</li>
<li>Bulk inserts 不能确定插入数使用表锁；Simple inserts 和 Mixed-mode inserts 使用轻量级锁 mutex，只锁住预分配自增值的过程，不锁整张表。Mixed-mode inserts 会直接分析语句，获得最坏情况下需要插入的数量，一次性分配足够的自增值，缺点是会分配过多，导致浪费和空洞。</li>
<li>这种模式的好处是既平衡了并发性，又能保证同一条 INSERT 语句分配的自增值是连续的。</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode &#x3D; 2 （interleaved lock mode）<ul>
<li>全部都用轻量级锁 mutex，并发性能最高，按顺序依次分配自增值，不会预分配。</li>
<li>缺点是不能保证同一条 INSERT 语句内的自增值是连续的，这样在复制（replication）时，如果 binlog_format 为 statement-based（基于语句的复制）就会存在问题，因为是来一个分配一个，同一条 INSERT 语句内获得的自增值可能不连续，主从数据集会出现数据不一致。所以在做数据库同步时要特别注意这个配置。</li>
</ul>
</li>
</ul>
<p>可以参考 MySQL 的这篇文档 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html">AUTO_INCREMENT Handling in InnoDB</a> 了解自增锁，InnoDb 处理自增值的方式，以及在不同的复制模式下可能遇到的问题。</p>
<h1 id="三、细说-MySQL-锁类型"><a href="#三、细说-MySQL-锁类型" class="headerlink" title="三、细说 MySQL 锁类型"></a>三、细说 MySQL 锁类型</h1><p>前面在讲行锁时有提到，在 MySQL 的源码中定义了四种类型的行锁，我们这一节将学习这四种锁。在我刚接触数据库锁的概念时，我理解的行锁就是将锁锁在行上，这一行记录不能被其他人修改，这种理解其实很肤浅，因为行锁也有可能并不是锁在行上而是行与行之间的间隙上，事实上，我理解的这种锁是最简单的行锁模式：记录锁。</p>
<h2 id="3-1-记录锁（Record-Locks）"><a href="#3-1-记录锁（Record-Locks）" class="headerlink" title="3.1 记录锁（Record Locks）"></a>3.1 记录锁（Record Locks）</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-record-locks"><strong>记录锁</strong></a> 是最简单的行锁，并没有什么好说的。譬如下面的 SQL 语句（id 为主键）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE accounts SET level = 100 WHERE id = 5;</span><br></pre></td></tr></table></figure>



<p>这条 SQL 语句就会在 id &#x3D; 5 这条记录上加上记录锁，防止其他事务对 id &#x3D; 5 这条记录进行修改或删除。记录锁永远都是加在索引上的，就算一个表没有建索引，数据库也会隐式的创建一个索引。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上（参考上面的加锁流程一节）。</p>
<p>注意，如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由 MySQL Server 层进行过滤。不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁（显然这违背了二段锁协议）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。</p>
<h2 id="3-2-间隙锁（Gap-Locks）"><a href="#3-2-间隙锁（Gap-Locks）" class="headerlink" title="3.2 间隙锁（Gap Locks）"></a>3.2 间隙锁（Gap Locks）</h2><p>还是看上面的那个例子，如果 id &#x3D; 5 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。</p>
<p>还记得我们在上一篇博客中介绍的数据库并发过程中可能存在的问题吗？其中有一个问题叫做 <strong>幻读</strong>，指的是在同一个事务中同一条 SQL 语句连续两次读取出来的结果集不一样。在 read committed 隔离级别很明显存在幻读问题，在 repeatable read 级别下，标准的 SQL 规范中也是存在幻读问题的，但是在 MySQL 的实现中，使用了间隙锁的技术避免了幻读。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-gap-locks"><strong>间隙锁</strong></a> 是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。有时候又称为范围锁（Range Locks），这个范围可以跨一个索引记录，多个索引记录，甚至是空的。使用间隙锁可以防止其他事务在这个范围内插入或修改记录，保证两次读取这个范围内的记录不会变，从而不会出现幻读现象。很显然，间隙锁会增加数据库的开销，虽然解决了幻读问题，但是数据库的并发性一样受到了影响，所以在选择数据库的隔离级别时，要注意权衡性能和并发性，根据实际情况考虑是否需要使用间隙锁，大多数情况下使用 read committed 隔离级别就足够了，对很多应用程序来说，幻读也不是什么大问题。</p>
<p>回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 5 前后两个索引之间加上间隙锁。</p>
<p>值得注意的是，间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，所以加间隙 S 锁和加间隙 X 锁没有任何区别。</p>
<h2 id="3-3-Next-Key-Locks"><a href="#3-3-Next-Key-Locks" class="headerlink" title="3.3 Next-Key Locks"></a>3.3 Next-Key Locks</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks"><strong>Next-key 锁</strong></a> 是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。假设一个索引包含<br>10、11、13 和 20 这几个值，可能的 Next-key 锁如下：</p>
<ul>
<li>(-∞, 10]</li>
<li>(10, 11]</li>
<li>(11, 13]</li>
<li>(13, 20]</li>
<li>(20, +∞)</li>
</ul>
<p>通常我们都用这种左开右闭区间来表示 Next-key 锁，其中，圆括号表示不包含该记录，方括号表示包含该记录。前面四个都是 Next-key 锁，最后一个为间隙锁。和间隙锁一样，在 RC 隔离级别下没有 Next-key 锁，只有 RR 隔离级别才有。继续拿上面的 SQL 例子来说，如果 id 不是主键，而是二级索引，且不是唯一索引，那么这个 SQL 在 RR 隔离级别下会加什么锁呢？答案就是 Next-key 锁，如下：</p>
<ul>
<li>(a, 5]</li>
<li>(5, b)</li>
</ul>
<p>其中，a 和 b 是 id &#x3D; 5 前后两个索引，我们假设 a &#x3D; 1、b &#x3D; 10，那么此时如果插入一条 id &#x3D; 3 的记录将会阻塞住。之所以要把 id &#x3D; 5 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id &#x3D; 5 可能会有多条记录，为了防止再插入一条 id &#x3D; 5 的记录，必须将下面标记 ^ 的位置都锁住，因为这些位置都可能再插入一条 id &#x3D; 5 的记录：</p>
<p>1 ^ 5 ^ 5 ^ 5 ^ 10 11 13 15</p>
<p>可以看出来，Next-key 锁确实可以避免幻读，但是带来的副作用是连插入 id &#x3D; 3 这样的记录也被阻塞了，这根本就不会引起幻读问题的。</p>
<p>关于 Next-key 锁，有一个比较有意思的问题，比如下面这个 orders 表（id 为主键，order_id 为二级非唯一索引）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----+----------+</span><br><span class="line">|  id | order_id |</span><br><span class="line">+-----+----------+</span><br><span class="line">|   1 |        1 |</span><br><span class="line">|   3 |        2 |</span><br><span class="line">|   5 |        5 |</span><br><span class="line">|   7 |        5 |</span><br><span class="line">|  10 |        9 |</span><br><span class="line">+-----+----------+</span><br></pre></td></tr></table></figure>

<p>事务 A 执行下面的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from orders where order_id = 5 for update;</span><br><span class="line">+-----+----------+</span><br><span class="line">|  id | order_id |</span><br><span class="line">+-----+----------+</span><br><span class="line">|   5 |        5 |</span><br><span class="line">|   7 |        5 |</span><br><span class="line">+-----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这个时候不仅 order_id &#x3D; 5 这条记录会加上 X 记录锁，而且这条记录前后的间隙也会加上锁，加锁位置如下：</p>
<p>1 2 ^ 5 ^ 5 ^ 9</p>
<p>可以看到 (2, 9) 这个区间都被锁住了，这个时候如果插入 order_id &#x3D; 4 或者 order_id &#x3D; 8 这样的记录肯定会被阻塞，这没什么问题，那么现在问题来了，如果插入一条记录 order_id &#x3D; 2 或者 order_id &#x3D; 9 会被阻塞吗？答案是可能阻塞，也可能不阻塞，这取决于插入记录主键的值，感兴趣的读者可以参考<a href="http://blog.sina.com.cn/s/blog_a1e9c7910102vnrj.html">这篇博客</a>。</p>
<h2 id="3-4-插入意向锁（Insert-Intention-Locks）"><a href="#3-4-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="3.4 插入意向锁（Insert Intention Locks）"></a>3.4 插入意向锁（Insert Intention Locks）</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-insert-intention-locks"><strong>插入意向锁</strong></a> 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id &#x3D; 1 和 id &#x3D; 5 之间如果有两个事务要同时分别插入 id &#x3D; 2 和 id &#x3D; 3 是没问题的，虽然两个事务都会在 id &#x3D; 1 和 id &#x3D; 5 之间加上插入意向锁，但是不会冲突。</p>
<p>插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。</p>
<h2 id="3-5-行锁的兼容矩阵"><a href="#3-5-行锁的兼容矩阵" class="headerlink" title="3.5 行锁的兼容矩阵"></a>3.5 行锁的兼容矩阵</h2><p>下面我们对这四种行锁做一个总结，它们之间的兼容矩阵如下图所示：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/11/3404508090.png" alt="row-locks-compatible-matrix.png"></p>
<p>其中，<strong>第一行表示已有的锁，第一列表示要加的锁</strong>。这个矩阵看起来很复杂，因为它是不对称的，如果要死记硬背可能会晕掉。其实仔细看可以发现，不对称的只有插入意向锁，所以我们先对插入意向锁做个总结，如下：</p>
<ul>
<li>插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；</li>
<li>插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。</li>
</ul>
<p>了解插入意向锁的特点之后，我们将它从矩阵中移去，兼容矩阵就变成了下面这个样子：</p>
<p><img src="https://www.aneasystone.com/usr/uploads/2017/11/3787975353.png" alt="row-locks-compatible-matrix-simple.png"></p>
<p>这个看起来就非常简单了，可以得出下面的结论：</p>
<ul>
<li>间隙锁不和其他锁（不包括插入意向锁）冲突；</li>
<li>记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；</li>
</ul>
<h2 id="3-6-在-MySQL-中观察行锁"><a href="#3-6-在-MySQL-中观察行锁" class="headerlink" title="3.6 在 MySQL 中观察行锁"></a>3.6 在 MySQL 中观察行锁</h2><p>为了更好的理解不同的行锁，下面我们在 MySQL 中对不同的锁实际操作一把。有两种方式可以在 MySQL 中观察行锁，第一种是通过下面的 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.innodb_locks;</span><br></pre></td></tr></table></figure>



<p>这个命令会打印出 InnoDb 的所有锁信息，包括锁 ID、事务 ID、以及每个锁的类型和模式等其他信息。第二种是使用下面的 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status</span><br></pre></td></tr></table></figure>



<p>这个命令并不是专门用来查看锁信息的，而是用于输出当前 InnoDb 引擎的状态信息，包括：BACKGROUND THREAD、SEMAPHORES、TRANSACTIONS、FILE I&#x2F;O、INSERT BUFFER AND ADAPTIVE HASH INDEX、LOG、BUFFER POOL AND MEMORY、ROW OPERATIONS 等等。其中 TRANSACTIONS 部分会打印当前 MySQL 所有的事务，如果某个事务有加锁，还会显示加锁的详细信息。如果发生死锁，也可以通过这个命令来定位死锁发生的原因。不过在这之前需要先打开 Innodb 的锁监控：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_status_output = ON;</span><br><span class="line">mysql&gt; set global innodb_status_output_locks = ON;</span><br></pre></td></tr></table></figure>



<p>打开锁监控之后，使用 <code>show engine innodb status</code> 命令，会输出大量的信息，我们在其中可以找到 <strong>TRANSACTIONS</strong> 部分，这里面就包含了每个事务及相关锁的信息，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3125</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 3106 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 17</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 3124, ACTIVE 10 sec</span><br><span class="line">4 lock struct(s), heap size 1136, 3 row lock(s)</span><br><span class="line">MySQL thread id 19, OS thread handle 6384, query id 212 localhost ::1 root</span><br><span class="line">TABLE LOCK table `accounts` trx id 3124 lock mode IX</span><br><span class="line">RECORD LOCKS space id 53 page no 5 n bits 72 index createtime of table `accounts` trx id 3124 lock_mode X</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 5a119f98; asc Z   ;;</span><br><span class="line"> 1: len 4; hex 80000005; asc     ;;</span><br><span class="line"> </span><br><span class="line">RECORD LOCKS space id 53 page no 3 n bits 80 index PRIMARY of table `accounts` trx id 3124 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 7; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000000c1c; asc       ;;</span><br><span class="line"> 2: len 7; hex b70000012b0110; asc     +  ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 5: len 0; hex ; asc ;;</span><br><span class="line"> 6: len 4; hex 5a119f98; asc Z   ;;</span><br><span class="line"> </span><br><span class="line">RECORD LOCKS space id 53 page no 5 n bits 72 index createtime of table `accounts` trx id 3124 lock_mode X locks gap before rec</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 5a119fa1; asc Z   ;;</span><br><span class="line"> 1: len 4; hex 8000000a; asc     ;;</span><br></pre></td></tr></table></figure>





<p>可以看出，<code>show engine innodb status</code> 的输出比较晦涩，要读懂它还需要学习一些其他知识，我们这里暂且不提，后面再专门对其进行介绍。这里使用 <code>information_schema.innodb_locks</code> 表来体验一下 MySQL 中不同的行锁。</p>
<p>要注意的是，只有在两个事务出现锁竞争时才能在这个表中看到锁信息，譬如你执行一条 UPDATE 语句，它会对某条记录加 X 锁，这个时候 <code>information_schema.innodb_locks</code> 表里是没有任何记录的。</p>
<p>另外，只看这个表只能得到当前持有锁的事务，至于是哪个事务被阻塞，可以通过 <code>information_schema.innodb_lock_waits</code> 表来查看。</p>
<h3 id="3-6-1-记录锁"><a href="#3-6-1-记录锁" class="headerlink" title="3.6.1 记录锁"></a>3.6.1 记录锁</h3><p>根据上面的行锁兼容矩阵，记录锁和记录锁或 Next-key 锁冲突，所以想观察到记录锁，可以让两个事务都对同一条记录加记录锁，或者一个事务加记录锁另一个事务加 Next-key 锁。</p>
<p>事务 A 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from accounts where id = 5 for update;</span><br><span class="line">+----+----------+-------+</span><br><span class="line">| id |     name | level |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">|  5 | zhangsan |     7 |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>事务 B 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from accounts where id = 5 lock in share mode;</span><br></pre></td></tr></table></figure>



<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.innodb_locks;</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| 3108:53:3:4 | 3108        | S         | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 5         |</span><br><span class="line">| 3107:53:3:4 | 3107        | X         | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 5         |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="3-6-2-间隙锁"><a href="#3-6-2-间隙锁" class="headerlink" title="3.6.2 间隙锁"></a>3.6.2 间隙锁</h3><p>根据兼容矩阵，间隙锁只和插入意向锁冲突，而且是先加间隙锁，然后加插入意向锁时才会冲突。</p>
<p>事务 A 执行（id 为主键，且 id &#x3D; 3 这条记录不存在）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from accounts where id = 3 lock in share mode;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>事务 B 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; insert into accounts(id, name, level) value(3, &#x27;lisi&#x27;, 10);</span><br></pre></td></tr></table></figure>



<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.innodb_locks;</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| 3110:53:3:4 | 3110        | X,GAP     | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 3         |</span><br><span class="line">| 3109:53:3:4 | 3109        | S,GAP     | RECORD    | `accounts` | PRIMARY    |         53 |         3 |        4 | 3         |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="3-6-3-Next-key-锁"><a href="#3-6-3-Next-key-锁" class="headerlink" title="3.6.3 Next-key 锁"></a>3.6.3 Next-key 锁</h3><p>根据兼容矩阵，Next-key 锁和记录锁、Next-key 锁或插入意向锁冲突，但是貌似很难制造 Next-key 锁和记录锁冲突的场景，也很难制造 Next-key 锁和 Next-key 锁冲突的场景（如果你能找到这样的例子，还望不吝赐教）。所以还是用 Next-key 锁和插入意向锁冲突的例子，和上面间隙锁的例子几乎一样。</p>
<p>事务 A 执行（level 为二级索引）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from accounts where level = 7 lock in share mode;</span><br><span class="line">+----+----------+-------+</span><br><span class="line">| id |     name | level |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">|  5 | zhangsan |     7 |</span><br><span class="line">|  9 |   liusan |     7 |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>事务 B 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; insert into accounts(name, level) value(&#x27;lisi&#x27;, 7);</span><br></pre></td></tr></table></figure>



<p>事务 B 阻塞，出现锁竞争，查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.innodb_locks;</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span><br><span class="line">| lock_id     | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data      |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span><br><span class="line">| 3114:53:5:5 | 3114        | X,GAP     | RECORD    | `accounts` |      level |         53 |         5 |        5 | 0x5A119FA1, 10 |</span><br><span class="line">| 3113:53:5:5 | 3113        | S,GAP     | RECORD    | `accounts` |      level |         53 |         5 |        5 | 0x5A119FA1, 10 |</span><br><span class="line">+-------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+----------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以看到除了锁住的索引不同之外，Next-key 锁和间隙锁之间几乎看不出任何差异。</p>
<h1 id="四、乐观锁-vs-悲观锁"><a href="#四、乐观锁-vs-悲观锁" class="headerlink" title="四、乐观锁 vs. 悲观锁"></a>四、乐观锁 vs. 悲观锁</h1><p>关于 MySQL 下的锁类型到这里就告一段落了。在结束这边博客之前，我认为还有必要介绍下乐观锁和悲观锁的概念，这两个概念听起来很像是一种特殊的锁，但实际上它并不是什么具体的锁，而是一种锁的思想。这种思想无论是在操作数据库时，还是在编程项目中，都非常实用。</p>
<p>我们知道，不同的隔离级别解决不同的并发问题，MySQL 能够根据设置的隔离级别自动管理事务内的锁，不需要开发人员关心就能避免那些并发问题的发生，譬如在 RC 级别下，开发人员不用担心会出现脏读问题，只要正常的写 SQL 语句就可以了。但对于当前隔离级别无法解决的并发问题，我们就需要自己来处理了，譬如在 MySQL 的 RR 级别下（不是标准的 RR 级别），你肯定会遇到丢失更新问题，对于这种问题，通常有两种解决思路。其实在讲 MVCC 的时候也提到过，解决并发问题的方式除了锁，还可以利用时间戳或者版本号等等手段。前一种处理数据的方式通常叫做 <strong>悲观锁（Pessimistic Lock）</strong>，第二种无锁方式叫做 <strong>乐观锁（Optimistic Lock）</strong>。</p>
<ul>
<li>悲观锁，顾名思义就是很悲观，每次拿数据时都假设有别人会来修改，所以每次在拿数据的时候都会给数据加上锁，用这种方式来避免跟别人冲突，虽然很有效，但是可能会出现大量的锁冲突，导致性能低下。</li>
<li>乐观锁则是完全相反，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有改过这个数据，可以使用版本号等机制来判断。</li>
</ul>
<p>我们在上一篇博客中丢失更新那一节举了一个商品库存的例子，我们分别用悲观锁和乐观锁来解决这个问题，以此来体会两个思想之间的区别以及优缺点。这个例子如下：</p>
<blockquote>
<p>譬如商品表的库存字段，每次下单之后库存值需要减 1，大概的流程如下：</p>
<ul>
<li>SELECT name, stock FROM product WHERE id &#x3D; 100;</li>
<li>判断 stock 值是否足够，如果足够，则下单：if (stock &gt; n) process order;</li>
<li>更新 stock 值，减去下单的商品数量：new_stock &#x3D; stock - n;</li>
<li>UPDATE product SET stock &#x3D; new_stock WHERE id &#x3D; 100;</li>
</ul>
<p>如果两个线程同时下单，很可能就会出现下面这样的情况：</p>
<ul>
<li>线程 A 获取库存值为 10；</li>
<li>线程 B 获取库存值为 10；</li>
<li>线程 A 需要买 5 个商品，校验通过，并下单；</li>
<li>线程 B 需要买 5 个商品，校验通过，并下单；</li>
<li>线程 A 下单完成，更新库存值为 10 - 5 &#x3D; 5；</li>
<li>线程 B 下单完成，更新库存值为 10 - 5 &#x3D; 5；</li>
</ul>
</blockquote>
<p>如果采用悲观锁的思想，我们在线程 A 获取商品库存的时候对该商品记录加 X 锁，并在最后下单完成并更新库存值之后再释放锁，这样线程 B 在获取库存值时就会等待，从而也不会出现线程 B 并发修改库存的情况了。</p>
<p>如果采用乐观锁的思想，我们不对记录加锁，于是线程 A 获取库存值为 10，线程 B 获取库存也为 10，然后线程 A 更新库存为 5 的时候使用类似于这样的 SQL 来校验当前库存值是否被修改过：<code>UPDATE product SET stock = new_stock WHERE id = 100 AND stock = 10;</code> 如果 UPDATE 成功则认为没有修改过，下单成功；同样线程 B 更新库存为 5 的时候也用同样的方式校验，很显然校验失败，这个时候我们可以重新查询最新的库存值并下单，或者直接抛出异常提示下单失败。这种带条件的更新就是乐观锁。但是要注意的是，这种带条件的更新还可能会遇到 <a href="https://en.wikipedia.org/wiki/ABA_problem">ABA 问题</a>（关于 ABA 问题可以参考 <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>），解决方法则是为每一条记录增加一个唯一的版本号字段，使用版本号字段来进行判断。再举一个很现实的例子，我们通常使用 svn 更新和提交代码，也是使用了乐观锁的思想，当用户提交代码时，会根据你提交的版本号和代码仓库中最新的版本号进行比较，如果一致则允许提交，如果不一致，则提示用户更新代码到最新版本。</p>
<p>总的来说，<strong>悲观锁需要使用数据库的锁机制来实现，而乐观锁是通过程序的手段来实现</strong>，这两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于读多写少的情况下，即冲突真的很少发生，这样可以省去锁的开销，加大系统的吞吐量。但如果经常产生冲突，上层应用不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁更合适。虽然使用带版本检查的乐观锁能够同时保持高并发和高可伸缩性，但它也不是万能的，譬如它不能解决脏读问题，所以在实际应用中还是会和数据库的隔离级别一起使用。</p>
<p>不仅仅是数据库，其实在分布式系统中，我们也可以看到悲观锁和乐观锁的影子。譬如酷壳上的这篇文章<a href="https://coolshell.cn/articles/6790.html">《多版本并发控制(MVCC)在分布式系统中的应用》</a>中提到的案例，就是一个典型的提交覆盖问题，可以通过悲观锁或者乐观锁来解决。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html">MySQL 5.7 Reference Manual - LOCK TABLES and UNLOCK TABLES Syntax</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html">MySQL 5.7 Reference Manual - Internal Locking Methods</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">MySQL 5.7 Reference Manual - InnoDB Locking</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html">MySQL 5.7 Reference Manual - AUTO_INCREMENT Handling in InnoDB</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">MySQL 5.7 Reference Manual - Clustered and Secondary Indexes</a></li>
<li><a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html">克鲁斯卡尔的博客 - MySQL总结</a></li>
<li>[克鲁斯卡尔的博客 - InnoDB 锁](<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB">http://novoland.github.io/数据库/2015/08/17/InnoDB</a> 锁.html)</li>
<li><a href="http://blog.sina.com.cn/s/blog_a1e9c7910102vnrj.html">MySQL InnoDB锁机制之Gap Lock、Next-Key Lock、Record Lock解析</a></li>
<li><a href="http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/">MySQL加锁分析</a></li>
<li><a href="https://liuzhengyang.github.io/2016/09/25/mysqlinnodb/">mysql、innodb和加锁分析</a></li>
<li><a href="https://github.com/MrLining/mysql/wiki/MySQL%E4%B8%AD%E7%9A%84%E9%94%81%EF%BC%88%E8%A1%A8%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81%EF%BC%89-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E9%94%81">MySQL中的锁（表锁、行锁） 并发控制锁</a></li>
<li><a href="https://book.douban.com/subject/25817684/">《深入浅出MySQL：数据库开发、优化与管理维护》</a></li>
<li><a href="http://www.jianshu.com/p/f5ff017db62a">MySQL 乐观锁与悲观锁</a></li>
</ol>]]></content>
      <categories>
        <category>经验</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析</title>
    <url>/2023/06/06/mysql-lock-analyze.html</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html">https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html</a></p>
</blockquote>
<p>这篇博客将对一些常见的 SQL 语句进行加锁分析，看看我们平时执行的那些 SQL 都会加什么锁。只有对我们所写的 SQL 语句加锁过程了如指掌，才能在遇到死锁问题时倒推出是什么锁导致的问题。在前面的博客中我们已经学习了 MySQL 下不同的锁模式和锁类型，我们要特别注意它们的兼容矩阵，熟悉哪些锁是不兼容的，这些不兼容的锁往往就是导致死锁的罪魁祸首。总体来说，MySQL 中的锁可以分成两个粒度：表锁和行锁，表锁有：表级读锁，表级写锁，读意向锁，写意向锁，自增锁；行锁有：读记录锁，写记录锁，间隙锁，Next-key 锁，插入意向锁。不出意外，绝大多数的死锁问题都是由这些锁之间的冲突导致的。</p>
<p>我们知道，不同的隔离级别加锁也是不一样的，譬如 RR 隔离级别下有间隙锁和 Next-key 锁，这在 RC 隔离级别下是没有的（也有例外），所以在对 SQL 进行加锁分析时，必须得知道数据库的隔离级别。由于 RR 和 RC 用的比较多，所以这篇博客只对这两种隔离级别做分析。</p>
<p>这是《解决死锁之路》系列博文中的一篇，你还可以阅读其他几篇：</p>
<ol>
<li><a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">学习事务与隔离级别</a></li>
<li><a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">了解常见的锁类型</a></li>
<li>掌握常见 SQL 语句的加锁分析</li>
<li><a href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">死锁问题的分析和解决</a></li>
</ol>
<h2 id="一、基本的加锁规则"><a href="#一、基本的加锁规则" class="headerlink" title="一、基本的加锁规则"></a>一、基本的加锁规则</h2><p>虽然 MySQL 的锁各式各样，但是有些基本的加锁原则是保持不变的，譬如：快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁的等等。这些规则整理如下，后面就不再重复介绍了： </p>
<ul>
<li>常见语句的加锁<ul>
<li>SELECT … 语句正常情况下为快照读，不加锁；</li>
<li>SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁；</li>
<li>SELECT … FOR UPDATE 语句为当前读，加 X 锁；</li>
<li>常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；</li>
<li>常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚；</li>
</ul>
</li>
<li>表锁<ul>
<li>表锁（分 S 锁和 X 锁）</li>
<li>意向锁（分 IS 锁和 IX 锁）</li>
<li>自增锁（一般见不到，只有在 innodb_autoinc_lock_mode &#x3D; 0 或者 Bulk inserts 时才可能有）</li>
</ul>
</li>
<li>行锁<ul>
<li>记录锁（分 S 锁和 X 锁）</li>
<li>间隙锁（分 S 锁和 X 锁）</li>
<li>Next-key 锁（分 S 锁和 X 锁）</li>
<li>插入意向锁</li>
</ul>
</li>
<li>行锁分析<ul>
<li>行锁都是加在索引上的，最终都会落在聚簇索引上；</li>
<li>加行锁的过程是一条一条记录加的；</li>
</ul>
</li>
<li>锁冲突<ul>
<li>S 锁和 S 锁兼容，X 锁和 X 锁冲突，X 锁和 S 锁冲突；</li>
<li>表锁和行锁的冲突矩阵参见前面的博客 <a href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">了解常见的锁类型</a>；</li>
</ul>
</li>
<li>不同隔离级别下的锁<ul>
<li>上面说 SELECT … 语句正常情况下为快照读，不加锁；但是在 Serializable 隔离级别下为当前读，加 S 锁；</li>
<li>RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）；</li>
<li>不同隔离级别下锁的区别，参见前面的博客 <a href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">学习事务与隔离级别</a>；</li>
</ul>
</li>
</ul>
<h2 id="二、简单-SQL-的加锁分析"><a href="#二、简单-SQL-的加锁分析" class="headerlink" title="二、简单 SQL 的加锁分析"></a>二、简单 SQL 的加锁分析</h2><p>何登成前辈在他的博客《MySQL 加锁处理分析》中对一些常见的 SQL 加锁进行了细致的分析，这篇博客可以说是网上介绍 MySQL 加锁分析的一个范本，网上几乎所有关于加锁分析的博客都是参考了这篇博客，勘称经典，强烈推荐。我这里也不例外，只是在他的基础上进行了一些整理和总结。</p>
<p>我们使用下面这张 students 表作为实例，其中 id 为主键，no（学号）为二级唯一索引，name（姓名）和 age（年龄）为二级非唯一索引，score（学分）无索引。 </p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062248634.png" alt="students-table.png"></p>
<p>这一节我们只分析最简单的一种 SQL，它只包含一个 WHERE 条件，等值查询或范围查询。虽然 SQL 非常简单，但是针对不同类型的列，我们还是会面对各种情况：</p>
<ul>
<li>聚簇索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘John’;</li>
<li>无索引：UPDATE students SET score &#x3D; 100 WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE age &lt;&#x3D; 23;</li>
<li>修改索引值：UPDATE students SET name &#x3D; ‘John’ WHERE id &#x3D; 15;</li>
</ul>
<h3 id="2-1-聚簇索引，查询命中"><a href="#2-1-聚簇索引，查询命中" class="headerlink" title="2.1 聚簇索引，查询命中"></a>2.1 聚簇索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE id = 15</code> 在 RC 和 RR 隔离级别下加锁情况一样，都是对 id 这个聚簇索引加 X 锁，如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062249327.png" alt="primary-index-locks.png"></p>
<h3 id="2-2-聚簇索引，查询未命中"><a href="#2-2-聚簇索引，查询未命中" class="headerlink" title="2.2 聚簇索引，查询未命中"></a>2.2 聚簇索引，查询未命中</h3><p>如果查询未命中纪录，在 RC 和 RR 隔离级别下加锁是不一样的，因为 RR 有 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE id = 16</code> 在 RC 和 RR 隔离级别下的加锁情况如下（RC 不加锁）：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062250297.png" alt="primary-index-locks-gap.png"></p>
<h3 id="2-3-二级唯一索引，查询命中"><a href="#2-3-二级唯一索引，查询命中" class="headerlink" title="2.3 二级唯一索引，查询命中"></a>2.3 二级唯一索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0003&#39;</code> 命中二级唯一索引，上一篇博客中我们介绍了索引的结构，我们知道二级索引的叶子节点中保存了主键索引的位置，在给二级索引加锁的时候，主键索引也会一并加锁。这个在 RC 和 RR 两种隔离级别下没有区别：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062251380.png" alt="secondary-index-unique-locks.png"></p>
<p>那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 students 表进行更新，如：<code>UPDATE students SET score = 100 WHERE id = 20</code>，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p>
<h3 id="2-4-二级唯一索引，查询未命中"><a href="#2-4-二级唯一索引，查询未命中" class="headerlink" title="2.4 二级唯一索引，查询未命中"></a>2.4 二级唯一索引，查询未命中</h3><p>如果查询未命中纪录，和 2.2 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0008&#39;</code> 加锁情况如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062251753.png" alt="secondary-index-unique-locks-gap.png"></p>
<p>这种情况下只会在二级索引加锁，不会在聚簇索引上加锁。</p>
<h3 id="2-5-二级非唯一索引，查询命中"><a href="#2-5-二级非唯一索引，查询命中" class="headerlink" title="2.5 二级非唯一索引，查询命中"></a>2.5 二级非唯一索引，查询命中</h3><p>如果查询命中的是二级非唯一索引，在 RR 隔离级别下，还会加 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;Tom&#39;</code>加锁如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252725.png" alt="secondary-index-non-unique-locks.png"></p>
<p>为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。</p>
<p>这里还有一点要注意一下，数一数右图中的锁你可能会觉得一共加了 7 把锁，实际情况不是，要注意的是 (Tom, 37) 上的记录锁和它前面的 GAP 锁合起来是一个 Next-key 锁，这个锁加在 (Tom, 37) 这个索引上，另外 (Tom, 49) 上也有一把 Next-key 锁。那么最右边的 GAP 锁加在哪呢？右边已经没有任何记录了啊。其实，在 InnoDb 存储引擎里，每个数据页中都会有两个虚拟的行记录，用来限定记录的边界，分别是：<code>Infimum Record</code> 和 <code>Supremum Record</code>，Infimum 是比该页中任何记录都要小的值，而 Supremum 比该页中最大的记录值还要大，这两条记录在创建页的时候就有了，并且不会删除。上面右边的 GAP 锁就是加在 Supremum Record 上。所以说，上面右图中共有 2 把 Next-key 锁，1 把 GAP 锁，2 把记录锁，一共 5 把锁。</p>
<h3 id="2-6-二级非唯一索引，查询未命中"><a href="#2-6-二级非唯一索引，查询未命中" class="headerlink" title="2.6 二级非唯一索引，查询未命中"></a>2.6 二级非唯一索引，查询未命中</h3><p>如果查询未命中纪录，和 2.2、2.4 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;John&#39;</code> 加锁情况如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252968.png" alt="secondary-index-non-unique-locks-gap.png"></p>
<h3 id="2-7-无索引"><a href="#2-7-无索引" class="headerlink" title="2.7 无索引"></a>2.7 无索引</h3><p>如果 WHERE 条件不能走索引，MySQL 会如何加锁呢？有的人说会在表上加 X 锁，也有人说会根据 WHERE 条件将筛选出来的记录在聚簇索引上加上 X 锁，那么究竟如何，我们看下图：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252189.png" alt="no-index-locks.png"></p>
<p>在没有索引的时候，只能走聚簇索引，对表中的记录进行全表扫描。在 RC 隔离级别下会给所有记录加行锁，在 RR 隔离级别下，不仅会给所有记录加行锁，所有聚簇索引和聚簇索引之间还会加上 GAP 锁。</p>
<p>语句 <code>UPDATE students SET score = 100 WHERE score = 22</code> 满足条件的虽然只有 1 条记录，但是聚簇索引上所有的记录，都被加上了 X 锁。那么，为什么不是只在满足条件的记录上加锁呢？这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 MySQL Server 层进行过滤，因此也就把所有的记录都锁上了。</p>
<p>不过在实际的实现中，MySQL 有一些改进，如果是 RC 隔离级别，在 MySQL Server 过滤条件发现不满足后，会调用 unlock_row 方法，把不满足条件的记录锁释放掉（违背了 2PL 的约束）。这样做可以保证最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。如果是 RR 隔离级别，一般情况下 MySQL 是不能这样优化的，除非设置了 <code>innodb_locks_unsafe_for_binlog</code> 参数，这时也会提前释放锁，并且不加 GAP 锁，这就是所谓的 <strong>semi-consistent read</strong>。</p>
<h3 id="2-8-聚簇索引，范围查询"><a href="#2-8-聚簇索引，范围查询" class="headerlink" title="2.8 聚簇索引，范围查询"></a>2.8 聚簇索引，范围查询</h3><p>上面所介绍的各种情况其实都是非常常见的 SQL，它们有一个特点：全部都只有一个 WHERE 条件，并且都是等值查询。那么问题来了，如果不是等值查询而是范围查询，加锁情况会怎么样呢？有人可能会觉得这很简单，根据上面的加锁经验，我们只要给查询范围内的所有记录加上锁即可，如果隔离级别是 RR，所有记录之间再加上间隙锁。事实究竟如何，我们看下面的图：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253940.png" alt="primary-index-range-locks.png"></p>
<p>SQL 语句为 <code>UPDATE students SET score = 100 WHERE id &lt;= 20</code>，按理说我们只需要将 id &#x3D; 20、18、15 三条记录锁住即可，但是看右边的图，在 RR 隔离级别下，我们还把 id &#x3D; 30 这条记录以及 (20, 30] 之间的间隙也锁起来了，很显然这是一个 Next-key 锁。如果 WHERE 条件是 id &lt; 20，则会把 id &#x3D; 20 这条记录锁住。为什么会这样我也不清楚，网上搜了很久，有人说是为了防止幻读，但 id 是唯一主键，(20, 30] 之间是不可能再插入一条 id &#x3D; 20 的，所以具体的原因还需要再分析下，如果你知道，还请不吝赐教。</p>
<p>所以对于范围查询，如果 WHERE 条件是 id &lt;&#x3D; N，那么 N 后一条记录也会被加上 Next-key 锁；如果条件是 id &lt; N，那么 N 这条记录会被加上 Next-key 锁。另外，如果 WHERE 条件是 id &gt;&#x3D; N，只会给 N 加上记录锁，以及给比 N 大的记录加锁，不会给 N 前一条记录加锁；如果条件是 id &gt; N，也不会锁前一条记录，连 N 这条记录都不会锁。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 11月26号补充 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>我在做实验的时候发现，在 RR 隔离级别，条件是 id &gt;&#x3D; 20，有时会对 id &lt; 20 的记录加锁，有时候又不加，感觉找不到任何规律，请以实际情况为准。我对范围查询的加锁原理还不是很明白，后面有时间再仔细研究下，也欢迎有兴趣的同学一起讨论下。</p>
<p>下面是我做的一个简单的实验，表很简单，只有一列主键 id：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show create table t1;</span><br><span class="line">+-------+--------------------------------------------+</span><br><span class="line">| Table | Create Table                               |</span><br><span class="line">+-------+--------------------------------------------+</span><br><span class="line">| t1    | CREATE TABLE `t1` (                        |</span><br><span class="line">|       |    `id` int(11) NOT NULL AUTO_INCREMENT,   |</span><br><span class="line">|       |    PRIMARY KEY (`id`)                      |</span><br><span class="line">|       | ) ENGINE=InnoDB DEFAULT CHARSET=utf8       |</span><br><span class="line">+-------+--------------------------------------------+</span><br></pre></td></tr></table></figure>



<p>表里一共三条数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">|  6 |</span><br><span class="line">+----+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>执行 <code>delete from t1 where id &gt; 2</code> 时加锁情况是：(2, 4], (4, 6], (6, +∞)<br>执行 <code>select * from t1 where id &gt; 2 for update</code> 时加锁情况是：(-∞, 2], (2, 4], (4, 6], (6, +∞)<br>可见 <strong>select for update</strong> 和 <strong>delete</strong> 的加锁还是有所区别的，至于 select for update 为什么加 (-∞, 2] 这个锁，我还是百思不得其解。后来无意中给表 t1 加了一个字段 a int(11) NOT NULL，竟然发现 <code>select * from t1 where id &gt; 2 for update</code> 就不会给 (-∞, 2] 加锁了，真的非常奇怪。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 12月3号补充 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>经过几天的搜索，终于找到了一个像样的解释（但不好去证实）：当数据表中数据非常少时，譬如上面那个的例子，select … [lock in share mode | for update] 语句会走全表扫描，这样表中所有记录都会被锁住，这就是 (-∞, 2] 被锁的原因。而 delete 语句并不会走全表扫描。</p>
<h3 id="2-9-二级索引，范围查询"><a href="#2-9-二级索引，范围查询" class="headerlink" title="2.9 二级索引，范围查询"></a>2.9 二级索引，范围查询</h3><p>然后我们把范围查询应用到二级非唯一索引上来，SQL 语句为：<code>UPDATE students SET score = 100 WHERE age &lt;= 23</code>，加锁情况如下图所示：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253613.png" alt="secondary-index-range-locks.png"></p>
<p>可以看出和聚簇索引的范围查询一样，除了 WHERE 条件范围内的记录加锁之外，后面一条记录也会加上 Next-key 锁，这里有意思的一点是，尽管满足 age &#x3D; 24 的记录有两条，但只有第一条被加锁，第二条没有加锁，并且第一条和第二条之间也没有加锁。</p>
<h3 id="2-10-修改索引值"><a href="#2-10-修改索引值" class="headerlink" title="2.10 修改索引值"></a>2.10 修改索引值</h3><p>这种情况比较容易理解，WHERE 部分的索引加锁原则和上面介绍的一样，多的是 SET 部分的加锁。譬如 <code>UPDATE students SET name = &#39;John&#39; WHERE id = 15</code> 不仅在 id &#x3D; 15 记录上加锁之外，还会在 name &#x3D; ‘Bob’（原值）和 name &#x3D; ‘John’（新值） 上加锁。示意图如下（<span style='color:red;'>此处理解有误，参见下面的评论区</span>）：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253623.png" alt="update-index-locks.png"></p>
<p>RC 和 RR 没有区别。</p>
<h2 id="三、复杂条件加锁分析"><a href="#三、复杂条件加锁分析" class="headerlink" title="三、复杂条件加锁分析"></a>三、复杂条件加锁分析</h2><p>前面的例子都是非常简单的 SQL，只包含一个 WHERE 条件，并且是等值查询，当 SQL 语句中包含多个条件时，对索引的分析就相当重要了。因为我们知道行锁最终都是加在索引上的，如果我们连执行 SQL 语句时会使用哪个索引都不知道，又怎么去分析这个 SQL 所加的锁呢？</p>
<p>MySQL 的索引是一个很复杂的话题，甚至可以写一本书出来了。这里就只是学习一下在对复杂 SQL 加锁分析之前如何先对索引进行分析。譬如下面这样的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE name = &#x27;Tom&#x27; AND age = 22;</span><br></pre></td></tr></table></figure>



<p>其中 name 和 age 两个字段都是索引，那么该如何加锁？这其实取决于 MySQL 用哪个索引。可以用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">EXPLAIN 命令</a>分析 MySQL 是如何执行这条 SQL 的，通过这个命令可以知道 MySQL 会使用哪些索引以及怎么用索引来执行 SQL 的，只有执行会用到的索引才有可能被加锁，没有使用的索引是不加锁的，这里有<a href="http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html">一篇 EXPLAIN 的博客</a>可以参考。也可以使用 MySQL 的 <a href="http://mysqllover.com/?p=708">optimizer_trace 功能</a> 来对 SQL 进行分析，它支持将执行的 SQL 的查询计划树记录下来，这个稍微有点难度，有兴趣的同学可以研究下。那么 MySQL 是如何选择合适的索引呢？其实 MySQL 会给每一个索引一个指标，叫做索引的选择性，这个值越高表示使用这个索引能最大程度的过滤更多的记录，关于这个，又是另一个话题了。</p>
<p>当然，从两个索引中选择一个索引来用，这种情况的加锁分析和我们上一节讨论的情形并没有本质的区别，只需要将那个没有用索引的 WHERE 条件当成普通的过滤条件就好了。这里我们会把用到的索引称为 <strong>Index Key</strong>，而另一个条件称为 <strong>Table Filter</strong>。譬如这里如果用到的索引为 age，那么 age 就是 Index Key，而 name &#x3D; ‘Tom’ 就是 Table Filter。Index Key 又分为 First Key 和 Last Key，如果 Index Key 是范围查询的话，如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE name = &#x27;Tom&#x27; AND age &gt; 22 AND age &lt; 25;</span><br></pre></td></tr></table></figure>



<p>其中 First Key 为 age &gt; 22，Last Key 为 age &lt; 25。</p>
<p>所以我们在加锁分析时，只需要确定 Index Key 即可，锁是加在 First Key 和 Last Key 之间的记录上的，如果隔离级别为 RR，同样会有间隙锁。要注意的是，当索引为复合索引时，Index Key 可能会有多个，何登成的这篇博客《SQL中的where条件，在数据库中提取与应用浅析》 详细介绍了如何从一个复杂的 WHERE 条件中提取出 Index Key，推荐一读。<a href="http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html">这里</a> 也有一篇博客介绍了 MySQL 是如何利用索引的。</p>
<p>当索引为复合索引时，不仅可能有多个 <strong>Index Key</strong>，而且还可能有 <strong>Index Filter</strong>。所谓 Index Filter，就是复合索引中除 Index Key 之外的其他可用于过滤的条件。如果 MySQL 是 5.6 之前的版本，Index Filter 和 Table Filter 没有区别，统统将 Index First Key 与 Index Last Key 范围内的索引记录，回表读取完整记录，然后返回给 MySQL Server 层进行过滤。而在 MySQL 5.6 之后，Index Filter 与 Table Filter 分离，Index Filter 下降到 InnoDB 的索引层面进行过滤，减少了回表与返回 MySQL Server 层的记录交互开销，提高了SQL的执行效率，这就是传说中的 <a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">ICP（Index Condition Pushdown）</a>，使用 Index Filter 过滤不满足条件的记录，无需加锁。</p>
<p>这里引用何登成前辈博客中的一个例子：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253509.png" alt="complicated-sql-locks.png"></p>
<p>可以看到 pubtime &gt; 1 and pubtime &lt; 20 为 Index First Key 和 Index Last Key，MySQL 会在这个范围内加上记录锁和间隙锁；userid &#x3D; ‘hdc’ 为 Index Filter，这个过滤条件可以在索引层面就可以过滤掉一条记录，因此如果数据库支持 ICP 的话，(4, yyy, 3) 这条记录就不会加锁；comment is not NULL 为 Table Filter，虽然这个条件也可以过滤一条记录，但是它不能在索引层面过滤，而是在根据索引读取了整条记录之后才过滤的，因此加锁并不能省略。</p>
<h2 id="四、DELETE-语句加锁分析"><a href="#四、DELETE-语句加锁分析" class="headerlink" title="四、DELETE 语句加锁分析"></a>四、DELETE 语句加锁分析</h2><p>一般来说，DELETE 的加锁和 SELECT FOR UPDATE 或 UPDATE 并没有太大的差异，DELETE 语句一样会有下面这些情况：</p>
<ul>
<li>聚簇索引，查询命中：DELETE FROM students WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：DELETE FROM students WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：DELETE FROM students WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：DELETE FROM students WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：DELETE FROM students WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：DELETE FROM students WHERE name &#x3D; ‘John’;</li>
<li>无索引：DELETE FROM students WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：DELETE FROM students WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：DELETE FROM students WHERE age &lt;&#x3D; 23;</li>
</ul>
<p>针对这些情况的加锁分析和上文一致，这里不再赘述。</p>
<p>那么 DELETE 语句和 UPDATE 语句的加锁到底会有什么不同呢？我们知道，在 MySQL 数据库中，执行 DELETE 语句其实并没有直接删除记录，而是在记录上打上一个删除标记，然后通过后台的一个叫做 purge 的线程来清理。从这一点来看，DELETE 和 UPDATE 确实是非常相像。事实上，DELETE 和 UPDATE 的加锁也几乎是一样的，这里要单独加一节来说明 DELETE 语句的加锁分析，其实并不是因为 DELETE 语句的加锁和其他语句有所不同，而是因为 DELETE 语句导致多了一种特殊类型的记录：标记为删除的记录，对于这种类型记录，它的加锁和其他记录的加锁机制不一样。所以这一节的标题叫做 <strong>标记为删除的记录的加锁分析</strong> 可能更合适。</p>
<p>那么问题又来了：什么情况下会对已标记为删除的记录加锁呢？我总结下来会有两种情况：<strong>阻塞后加锁</strong> 和 <strong>快照读后加锁</strong>（自己取得名字），下面分别介绍。</p>
<p><strong>阻塞后加锁</strong> 如下图所示，事务 A 删除 id &#x3D; 18 这条记录，同时事务 B 也删除 id &#x3D; 18 这条记录，很显然，id 为主键，DELETE 语句需要获取 X 记录锁，事务 B 阻塞。事务 A 提交之后，id &#x3D; 18 这条记录被标记为删除，此时事务 B 就需要对已删除记录进行加锁。</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062254519.png" alt="delete-locks-after-block.png"></p>
<p><strong>快照读后加锁</strong> 如下图所示，事务 A 删除 id &#x3D; 18 这条记录，并提交。事务 B 在事务 A 提交之前有一次 id &#x3D; 18 的快照读，所以在后面删除 id &#x3D; 18 这条记录的时候就需要对已删除记录加锁了。如果没有事务开头的这个快照读，DELETE 语句就只是简单的删除一条不存在的记录。</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062254924.png" alt="delete-locks-after-snapshot-read.png"></p>
<p>注意，上面的事务 B 不限于 DELETE 语句，换成 UPDATE 或 SELECT FOR UPDATE 同样适用。网上对这种删除记录的加锁分析并不多，我通过自己做的实验，得到了下面这些结论，如有不正确的地方，欢迎斧正。（实验环境，MySQL 版本：5.7，隔离级别：RR）</p>
<ul>
<li>删除记录为聚簇索引<ul>
<li>阻塞后加锁：在删除记录上加 X 记录锁（rec but not gap），并在删除的后一条记录上加间隙锁（gap before rec）</li>
<li>快照读后加锁：在删除记录上加 X 记录锁（rec but not gap）</li>
</ul>
</li>
<li>删除记录为二级索引（唯一索引和非唯一索引都适用）<ul>
<li>阻塞后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
<li>快照读后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
</ul>
</li>
</ul>
<p>要注意的是，这里的隔离级别为 RR，如果在 RC 隔离级别下，加锁过程应该会不一样，感兴趣的同学可以自行实验。关于 DELETE 语句的加锁，何登成前辈在他的博客：《一个最不可思议的MySQL死锁分析》里面有详细的分析，并介绍了页面锁的相关概念，还原了仅仅只有一条 DELETE 语句也会造成死锁的整个过程，讲的很精彩。</p>
<h2 id="五、INSERT-语句加锁分析"><a href="#五、INSERT-语句加锁分析" class="headerlink" title="五、INSERT 语句加锁分析"></a>五、INSERT 语句加锁分析</h2><p>上面所提到的加锁分析，都是针对 SELECT FOR UPDATE、UPDATE、DELETE 等进行的，那么针对 INSERT 加锁过程又是怎样的呢？我们下面继续探索。</p>
<p>还是用 students 表来实验，譬如我们执行下面的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into students(no, name, age, score) value(&#x27;S0008&#x27;, &#x27;John&#x27;, 26, 87);</span><br></pre></td></tr></table></figure>



<p>然后我们用 <code>show engine innodb status\G</code> 查询事务的锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---TRANSACTION 3774, ACTIVE 2 sec</span><br><span class="line">1 lock struct(s), heap size 1136, 0 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 150, OS thread handle 10420, query id 3125 localhost ::1 root</span><br><span class="line">TABLE LOCK table `sys`.`t3` trx id 3774 lock mode IX</span><br></pre></td></tr></table></figure>



<p>我们发现除了一个 IX 的 TABLE LOCK 之外，就没有其他的锁了，难道 INSERT 不加锁？一般来说，加锁都是对表中已有的记录进行加锁，而 INSERT 语句是插入一条新的纪录，这条记录表中本来就没有，那是不是就不需要加锁了？显然不是，至少有两个原因可以说明 INSERT 加了锁：</p>
<ol>
<li>为了防止幻读，如果记录之间加有 GAP 锁，此时不能 INSERT；</li>
<li>如果 INSERT 的记录和已有记录造成唯一键冲突，此时不能 INSERT；</li>
</ol>
<p>要解决这两个问题，都是靠锁来解决的（第一个加插入意向锁，第二个加 S 锁进行当前读），只是在 INSERT 的时候如果没有出现这两种情况，那么锁就是隐式的，只是我们看不到而已。这里我们不得不提一个概念叫 <strong>隐式锁（Implicit Lock）</strong>，它对我们分析 INSERT 语句的加锁过程至关重要。</p>
<p>关于隐式锁，这篇文章<a href="http://www.uml.org.cn/sjjm/201205302.asp">《MySQL数据库InnoDB存储引擎中的锁机制》</a>对其做了详细的说明，讲的非常清楚，推荐一读。可以参考上一篇介绍的悲观锁和乐观锁。</p>
<blockquote>
<p>锁是一种悲观的顺序化机制，它假设很可能发生冲突，因此在操作数据时，就加锁，如果冲突的可能性很小，多数的锁都是不必要的。Innodb 实现了一个延迟加锁的机制来减少加锁的数量，这被称为隐式锁。</p>
<p>隐式锁中有个重要的元素：事务ID（trx_id）。隐式锁的逻辑过程如下：</p>
<p>A. InnoDB 的每条记录中都有一个隐含的 trx_id 字段，这个字段存在于簇索引的 B+Tree 中;<br>B. 在操作一条记录前，首先根据记录中的 trx_id 检查该事务是否是活动的事务（未提交或回滚），如果是活动的事务，首先将隐式锁转换为显式锁（就是为该事务添加一个锁）；<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为 waiting 状态；如果没有冲突不加锁，跳到 E；<br>D. 等待加锁成功，被唤醒，或者超时；<br>E. 写数据，并将自己的 trx_id 写入 trx_id 字段。</p>
<p>隐式锁的特点是只有在可能发生冲突时才加锁，减少了锁的数量。另外，隐式锁是针对被修改的 B+Tree 记录，因此都是 Record 类型的锁，不可能是 Gap 或 Next-Key 类型。</p>
<ol>
<li>INSERT 操作只加隐式锁，不需要显示加锁；</li>
<li>UPDATE、DELETE 在查询时，直接对查询用的 Index 和主键使用显示锁，其他索引上使用隐式锁。</li>
</ol>
<p>理论上说，可以对主键使用隐式锁的。提前使用显示锁应该是为了减少死锁的可能性。INSERT，UPDATE，DELETE 对 B+Tree 们的操作都是从主键的 B+Tree 开始，因此对主键加锁可以有效的阻止死锁。</p>
</blockquote>
<p>INSERT 加锁流程如下（<a href="http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/">参考</a>）：</p>
<ul>
<li>首先对插入的间隙加插入意向锁（Insert Intension Locks）<ul>
<li>如果该间隙已被加上了 GAP 锁或 Next-Key 锁，则加锁失败进入等待；</li>
<li>如果没有，则加锁成功，表示可以插入；</li>
</ul>
</li>
<li>然后判断插入记录是否有唯一键，如果有，则进行唯一性约束检查<ul>
<li>如果不存在相同键值，则完成插入</li>
<li>如果存在相同键值，则判断该键值是否加锁<ul>
<li>如果没有锁， 判断该记录是否被标记为删除<ul>
<li>如果标记为删除，说明事务已经提交，还没来得及 purge，这时加 S 锁等待；</li>
<li>如果没有标记删除，则报 1062 duplicate key 错误；</li>
</ul>
</li>
<li>如果有锁，说明该记录正在处理（新增、删除或更新），且事务还未提交，加 S 锁等待；</li>
</ul>
</li>
</ul>
</li>
<li>插入记录并对记录加 X 记录锁；</li>
</ul>
<p>这里的表述其实并不准确，有兴趣的同学可以去阅读 InnoDb 的源码分析 INSERT 语句具体的加锁过程，我在 <a href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html">《读 MySQL 源码再看 INSERT 加锁流程》</a> 这篇博客中有详细的介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>何登成的技术博客 - MySQL 加锁处理分析</li>
<li>何登成的技术博客 - MySQL+InnoDB semi-consitent read原理及实现分析</li>
<li>何登成的技术博客 - SQL中的where条件，在数据库中提取与应用浅析</li>
<li>何登成的技术博客 - 一个最不可思议的MySQL死锁分析</li>
<li><a href="http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/">Yilun Fan’s Blog - MySQL加锁分析</a></li>
<li><a href="http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html">10分钟让你明白MySQL是如何利用索引的</a></li>
<li><a href="http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html">MySQL innodb中各种SQL语句加锁分析</a></li>
<li><a href="http://www.cnblogs.com/yelbosh/p/5813865.html">MySQL的并发控制与加锁分析</a></li>
<li>[克鲁斯卡尔的博客 - InnoDB 锁](<a href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB">http://novoland.github.io/数据库/2015/08/17/InnoDB</a> 锁.html)</li>
<li><a href="http://www.uml.org.cn/sjjm/201205302.asp">MySQL数据库InnoDB存储引擎中的锁机制</a></li>
<li><a href="http://www.fordba.com/lock-analyse-of-delete.html">MySQL DELETE 删除语句加锁分析</a></li>
<li><a href="http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/">MySQL锁系列（七）之 锁算法详解</a></li>
<li>[<a href="http://mysqllover.com/?p=708">MySQL 5.6] 初识5.6的optimizer trace</a></li>
<li>[<a href="http://mysqllover.com/?p=431">MySQL学习] Innodb锁系统(4) Insert&#x2F;Delete 锁处理及死锁示例分析</a></li>
</ol>]]></content>
      <categories>
        <category>经验</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一次晋升</title>
    <url>/2023/04/19/talk-about-a-promotion.html</url>
    <content><![CDATA[<p>待更新</p>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>给应用加上守卫-Prometheus实战</title>
    <url>/2022/12/04/prometheus-use.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近和团队开发应用「京返吧」，开发完成后想完善一下监控报警。在公司，都是自研的监控体系，提供各种 metric 和报警策略，自己做项目，平时公司的工具必然使用不上，只能考虑合适的开源方案。</p>
<p>Prometheus 应该是目前监控体系里面的领导者，开箱即用，丰富的插件，配合 Grafana 图表展示，很直观的体现各种数据。</p>
<h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><p>这里还是简单介绍一下什么是 <a href="https://prometheus.io/">Prometheus</a> ？<br>由于本人也是第一次接触，所以，介绍和使用说明还是以官网介绍为准。</p>
<blockquote>
<p>Power your metrics and alerting with the leading open-source monitoring solution.</p>
</blockquote>
<p>从官网的描述可以知道，Prometheus 是一个支持指标和报警的开源监控解决方案。一个监控系统，核心能力是报警，报警的前提是有数据，有了数据，才能根据一些特征来决定系统或服务是否存在问题。</p>
<p>这里从官网引用一张架构图。可以看到有一个 server，从名字上可以知道这是一个服务端，这是 Prometheus 提供数据存储，查询数据等能力。Alertmanager 为监控报警，报警通知方式有邮件、webhook等方式。Prometheus WebUI 为可视化操作平台，或者使用 Grafana 可视化数据。Pushgateway 为推送网关。</p>
<p><img src="https://prometheus.io/assets/architecture.png" alt="架构图"></p>
<p>数据交互主要有两种方式，推和拉，Prometheus 默认的方式是拉，就是说使用者需要提供指标查询接口供 Prometheus 查询。 另外一种方式，就是通过推，即我们的一些指标产生后，通过 Prometheus 提供的接口写入数据。Prometheus 并没有直接提供这种接口，而是由 Pushgateway 提供，这样设计达到和 Prometheus 解耦。Prometheus 在从 Pushgateway 拉取数据，这样就可以通过 Prometheus WebUI 查询我们的指标数据。</p>
<p>「京返吧」是通过 springboot 开发，可以通过 spring actuator 暴露指标数据，这种方式简单，但是不适合暴露在公网的服务，毕竟总有人在网上攻击。所以，最终采用的方案是通过暴露 Pushgateway，应用通过 Pushgateway 将指标数据写入 Prometheus。</p>
<p>除了 Pushgateway 外，Prometheus 还提供了很多的 exporter，用于指标直接上报 Prometheus，比如需要</p>
<ul>
<li><a href="https://prometheus.io/download/#blackbox_exporter">blackbox_exporter</a></li>
<li><a href="https://prometheus.io/download/#consul_exporter">consul_exporter</a></li>
<li><a href="https://prometheus.io/download/#graphite_exporter">graphite_exporter</a></li>
<li><a href="https://prometheus.io/download/#haproxy_exporter">haproxy_exporter</a></li>
<li><a href="https://prometheus.io/download/#memcached_exporter">memcached_exporter</a></li>
<li><a href="https://prometheus.io/download/#mysqld_exporter">mysqld_exporter</a></li>
<li><a href="https://prometheus.io/download/#node_exporter">node_exporter</a></li>
<li><a href="https://prometheus.io/download/#promlens">promlens</a></li>
<li><a href="https://prometheus.io/download/#pushgateway">pushgateway</a></li>
<li><a href="https://prometheus.io/download/#statsd_exporter">statsd_exporter</a></li>
</ul>
<p>方便我们监控 MySQL、RocketMQ 等。</p>
<p><a href="https://prometheus.io/">Prometheus</a>、<a href="https://prometheus.io/download/#pushgateway">Pushgateway</a>、<a href="https://grafana.com/">Grafana</a>  三大件的安装方式略，可以参考 <a href="https://zhuanlan.zhihu.com/p/355075613">https://zhuanlan.zhihu.com/p/355075613</a> </p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>上面三个工具安装好后，接下来就是代码配置相关能力。</p>
<p>micrometer-registry-prometheus 配置后才会上报，simpleclient_pushgateway 为 pushgateway 相关配置。引入下面依赖后，在 application.yml（或者 application.properties）配置 pushgateway 相关内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_logback<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_spring_web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.mweirauch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-jvm-extras<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置好以下内容后，启动应用，会发现指标数据上报到 pushgateway</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">prometheus:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">pushgateway:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">base-url:</span> <span class="string">pushgateway</span> <span class="string">访问地址</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">账号</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">密码</span></span><br><span class="line">          <span class="attr">pushRate:</span> <span class="string">10s</span></span><br><span class="line">          <span class="attr">job:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">shutdown-operation:</span> <span class="string">push</span></span><br><span class="line">          <span class="attr">grouping-key:</span></span><br><span class="line">            <span class="attr">instance:</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<p>在 Prometheus 配置 job 采集 Pushgateway 的数据</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;prometheus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;localhost:9093&quot;</span>]</span><br><span class="line">  <span class="comment"># pushgateway    </span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;pushgateway&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">#metrics_path: &#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">  <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">      <span class="comment">#enable_http2: false</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;localhost:9091&quot;</span>]  </span><br></pre></td></tr></table></figure>

<p>有了数据源，接下来就是展示功能了。</p>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>图表展示这里使用 grafana，模板有很多人分享了，这里使用的是 <a href="https://grafana.com/grafana/dashboards/12856-jvm-micrometer/">https://grafana.com/grafana/dashboards/12856-jvm-micrometer/</a> </p>
<p><img src="https://cdn.0x4096.com//cdn/image/202212032139153.png"></p>
<p>效果还不错，能查看当前应用基本指标。</p>]]></content>
      <categories>
        <category>稳定性建设</category>
      </categories>
      <tags>
        <tag>稳定性建设</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅使用错误码</title>
    <url>/2022/10/11/use-error-codes-gracefully.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>系统开发中，随着功能的迭代升级，我们会开发越来越多的接口，每个接口的作用都不一样，有些涉及数据库操作、有些涉及下游接口调用，在接口调用过程中，会有各种各样的问题，比如参数校验是否合法、请求是否超时、数据查询是否错误等，面对各种各样的问题，我们应该做出不同的响应。</p>
<p>如今接口交互的数据都是通过 JSON 格式，每个公司都有一套自己的约束，不过都是通用的方案，比如下面的结构：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们会约定，code 为 200 时表示成功，其他表示不同情况下的返回，比如参数不合法，我们会返回 400，无权限返回 403，服务器内部错误返回 500，等等。</p>
<p>推荐一下自己封装的 <a href="https://github.com/0x4096/common-base">https://github.com/0x4096/common-base</a>，个人平时写写小项目可以用起来。这里 code 为啥要定义为 string 呢，按照 HTTP 状态码的规范他是数字，这里用 string 是想海纳百川，避免有系统是数字，有系统是字符串，万物皆字符串嘛。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当然，上面状态码的定义是理想态，实际上，我们的系统可能会存在状态码问题。</p>
<ol>
<li>万能错误码，大多数程序员为了偷懒，都是随意抛出错误，最常见的可能是“系统错误，请稍后再试” 这种万能的错误信息。一旦他人把这种错误给你，你就需要看服务器日志才知道具体是哪里有问题，非常低效。</li>
<li>错误码重复配置，同一个错误码各地使用，如何才能避免重复配置？</li>
<li>接口调用涉及下游、数据库、网络请求等，在各个环节都会产生业务相关错误码，如何标准化管理错误码？</li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>面对上述问题，我们从下面几个方面着手解决。</p>
<ol>
<li>对错误码分类，确定好每种错误码的职责；</li>
<li>明确命名规则，能做到见名知意；</li>
<li>对外统一，需要屏蔽内部信息，给到外部时需要干净简洁；</li>
<li>配置集中管理；</li>
</ol>
<h1 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h1><p>在接口调用中，请求流程大致如下<br><img src="https://cdn.0x4096.com//cdn/image/202210112259756.png" alt="image.png"></p>
<p>我们可以整体分类为：内部错误码、第三方错误码、外部错误码。</p>
<h2 id="内部错误码"><a href="#内部错误码" class="headerlink" title="内部错误码"></a>内部错误码</h2><p>来源：内部错误码为系统内部处理各种业务所产生的错误信息<br>用途：直接定位到失败原因，比如入参校验、业务逻辑<br>定位：需要最细粒度的错误分类，便于进行问题排查</p>
<h2 id="外部错误码"><a href="#外部错误码" class="headerlink" title="外部错误码"></a>外部错误码</h2><p>来源：根据系统内部错误码转换外部错误码<br>用途：用于返回给业务方，当前处理结果，以及原因和解决方案<br>定位：进行错误码归类，屏蔽内部错误信息</p>
<h2 id="第三方错误码"><a href="#第三方错误码" class="headerlink" title="第三方错误码"></a>第三方错误码</h2><p>来源：我们依赖第三方、下游<br>用途：记录每个依赖方的错误码，快速与他们文档核查<br>定位：外部系统特有，便于文档核查</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>错误码的定位和用途确定后，接下来，我们就需要约束每种错误码的命名规则。</p>
<h2 id="内部错误码-1"><a href="#内部错误码-1" class="headerlink" title="内部错误码"></a>内部错误码</h2><p>内部错误码是最细粒度的错误码，因为从参数校验、数据库更新、业务处理，到接口返回，各个环节都会产生内部错误码，因此，内部错误规则比较详细：<br>内部错误码命名，共分为三个层次，规则如下：<em></em>，如：O_CHN_NOT_ENOUGH_BALANCE ，O 代表外部系统错误；CHN代表渠道错误，NOT_ENOUGH_BALANCE 代表具体错误原因，即余额不足。</p>
<p>整理成表格如下：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>前缀</th>
<th>前缀含义</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>一级</td>
<td>O</td>
<td>OUTER</td>
<td>外部系统错误</td>
</tr>
<tr>
<td></td>
<td>V</td>
<td>VALIDATE</td>
<td>校验类错误码</td>
</tr>
<tr>
<td></td>
<td>I</td>
<td>INNER</td>
<td>公司内部系统错误，如 redis</td>
</tr>
<tr>
<td>二级</td>
<td>CHN</td>
<td>CHANNEL</td>
<td>渠道错误</td>
</tr>
<tr>
<td>三级</td>
<td>NOT_ENOUGH_BALANCE</td>
<td>NOT_ENOUGH_BALANCE</td>
<td>具体错误原因</td>
</tr>
</tbody></table>
<h2 id="外部错误码-1"><a href="#外部错误码-1" class="headerlink" title="外部错误码"></a>外部错误码</h2><p>外部错误码，无需体现具体系统错误原因，只需要进行大体分类即可，如参数错误、余额不足等。针对这部分，可以根据自身业务定义，只要风格统一即可，没有太多约束。</p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>错误信息</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>PARAM_ERROR</td>
<td>参数校验失败</td>
<td>按照要求传值</td>
</tr>
</tbody></table>
<p>参考 common-base 的规范：<a href="https://github.com/0x4096/common-base/blob/master/src/main/java/com/github/Is0x4096/common/base/interf/IEnum.java">https://github.com/0x4096/common-base/blob/master/src/main/java/com/github/Is0x4096/common/base/interf/IEnum.java</a> </p>
<h2 id="第三方错误码-1"><a href="#第三方错误码-1" class="headerlink" title="第三方错误码"></a>第三方错误码</h2><p>第三方错误码，是对接的外部渠道提供的，我们无法自定义，但需要映射为内部错误码。在做支付时，我们以此来屏蔽渠道间的差异。<br>比如：两个外部渠道支付宝和微信都有各自的参数错误的错误码，但转换后，都是同一个系统内部错误码：</p>
<table>
<thead>
<tr>
<th>外部渠道</th>
<th>渠道错误码</th>
<th>内部错误码</th>
</tr>
</thead>
<tbody><tr>
<td>Alipay</td>
<td>ACQ.INVALID_PARAMETER</td>
<td>O_CHN_PARAM_ERROR</td>
</tr>
<tr>
<td>WeiXinPay</td>
<td>PARAM_ERROR</td>
<td>O_CHN_PARAM_ERROR</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码不仅仅是写给自己看，也是写给他人看，好的代码不仅在工程结构上要合理，每个模块也需要清晰，细分到每个接口，每个函数，都需要有合适的注释，合理的返回值。一个工程越来越多人接手时，规范至为重要。</p>
<p>我们定义各种状态码，在执行过程中，对不符合预期的场景，我们可以抛异常处理，异常有助于提供一种一致的方式来解决运行时的问题，并且有助于写出干净的代码，同时我们也应该对异常做监控和清理，要知道，线上环境，异常本不应该是常态。</p>]]></content>
      <categories>
        <category>系统设计</category>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的内存优化</title>
    <url>/2022/03/22/redis-memory-optimization.html</url>
    <content><![CDATA[<blockquote>
<p>声明：本文内容来自《Redis 开发与运维》一书第八章，如转载请声明。  <a href="https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#chapter6">https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#chapter6</a></p>
</blockquote>
<p>Redis 所有的数据都在内存中，而内存又是非常宝贵的资源。对于如何优化内存使用一直是 Redis 用户非常关注的问题。本文让我们深入到 Redis 细节中，学习内存优化的技巧。分为如下几个部分：</p>
<p>一 . redisObject 对象<br>二 . 缩减键值对象<br>三 . 共享对象池<br>四 . 字符串优化<br>五 . 编码优化<br>六 . 控制 key 的数量</p>
<h2 id="一-redisObject-对象"><a href="#一-redisObject-对象" class="headerlink" title="一 . redisObject 对象"></a>一 . redisObject 对象</h2><p>Redis 存储的所有值对象在内部定义为 redisObject 结构体，内部结构如下图所示。</p>
<p><a href="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png"><img src="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png" alt="img"></a></p>
<p>Redis 存储的数据都使用 redisObject 来封装，包括 string,hash,list,set,zset 在内的所有数据类型。理解 redisObject 对内存优化非常有帮助，下面针对每个字段做详细说明：</p>
<h3 id="1-type-字段"><a href="#1-type-字段" class="headerlink" title="1.type 字段 :"></a>1.type 字段 :</h3><p>表示当前对象使用的数据类型，Redis 主要支持 5 种数据类型 :string,hash,list,set,zset。可以使用 type {key} 命令查看对象所属类型，type 命令返回的是值对象类型，键都是 string 类型。</p>
<h3 id="2-encoding-字段"><a href="#2-encoding-字段" class="headerlink" title="2.encoding 字段 :"></a>2.encoding 字段 :</h3><p>表示 Redis 内部编码类型，encoding 在 Redis 内部使用，代表当前对象内部采用哪种数据结构实现。理解 Redis 内部编码方式对于优化内存非常重要 ，同一个对象采用不同的编码实现内存占用存在明显差异，具体细节见之后编码优化部分。</p>
<h3 id="3-lru-字段"><a href="#3-lru-字段" class="headerlink" title="3.lru 字段 :"></a>3.lru 字段 :</h3><p>记录对象最后一次被访问的时间，当配置了 maxmemory 和 maxmemory-policy&#x3D;volatile-lru | allkeys-lru 时， 用于辅助 LRU 算法删除键数据。可以使用 object idletime {key} 命令在不更新 lru 字段情况下查看当前键的空闲时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发提示：可以使用scan + object idletime  命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理降低内存占用。</span><br></pre></td></tr></table></figure>

<h3 id="4-refcount-字段"><a href="#4-refcount-字段" class="headerlink" title="4.refcount 字段 :"></a>4.refcount 字段 :</h3><p>记录当前对象被引用的次数，用于通过引用次数回收内存，当 refcount&#x3D;0 时，可以安全回收当前对象空间。使用 object refcount {key} 获取当前对象引用。当对象为整数且范围在 [0-9999] 时，Redis 可以使用共享对象的方式来节省内存。具体细节见之后共享对象池部分。</p>
<h3 id="5-ptr-字段"><a href="#5-ptr-字段" class="headerlink" title="5. *ptr 字段 :"></a>5. *ptr 字段 :</h3><p>与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针。Redis 在 3.0 之后对值对象是字符串且长度 &lt;&#x3D;39 字节的数据，内部编码为 embstr 类型，字符串 sds 和 redisObject 一起分配，从而只要一次内存操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发提示：高并发写入场景中，在条件允许的情况下建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数从而提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="二-缩减键值对象"><a href="#二-缩减键值对象" class="headerlink" title="二 . 缩减键值对象"></a>二 . 缩减键值对象</h2><p>降低 Redis 内存使用最直接的方式就是缩减键（key）和值（value）的长度。</p>
<ul>
<li>key 长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li>
<li>value 长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入 Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以 JAVA 为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如 : protostuff，kryo 等，下图是 JAVA 常见序列化工具空间压缩对比。</li>
</ul>
<p><a href="http://i2.itc.cn/20170216/3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png"><img src="http://i2.itc.cn/20170216/3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png" alt="img"></a></p>
<p>其中 java-built-in-serializer 表示 JAVA 内置序列化方式，更多数据见 jvm-serializers 项目 :<a href="https://github.com/eishay/jvm-serializers/wiki">https://github.com/eishay/jvm-serializers/wiki</a> 其它语言也有各自对应的高效序列化工具。</p>
<p>值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如 :json，xml 等作为字符串存储在 Redis 中。这种方式优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩 json,xml 后再存入 Redis，从而降低内存占用，例如使用 GZIP 压缩后的 json 可降低约 60% 的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发提示：当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。</span><br></pre></td></tr></table></figure>

<h2 id="三-共享对象池"><a href="#三-共享对象池" class="headerlink" title="三 . 共享对象池"></a>三 . 共享对象池</h2><p>对象共享池指 Redis 内部维护 [0-9999] 的整数对象池。创建大量的整数类型 redisObject 存在内存开销，每个 redisObject 内部结构至少占 16 字节，甚至超过了整数自身空间消耗。所以 Redis 内存维护一个 [0-9999] 的整数对象池，用于节约内存。 除了整数值对象，其他类型如 list,hash,set,zset 内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。<br>整数对象池在 Redis 中通过变量 REDIS_SHARED_INTEGERS 定义，不能通过配置修改。可以通过 object refcount 命令查看对象引用数验证是否启用整数对象池技术，如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; set foo 100 </span><br><span class="line">OK</span><br><span class="line">redis&gt; object refcount foo</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; set bar 100</span><br><span class="line">OK</span><br><span class="line">redis&gt; object refcount bar</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>设置键 foo 等于 100 时，直接使用共享池内整数对象，因此引用数是 2，再设置键 bar 等于 100 时，引用数又变为 3，如下图所示。</p>
<p><a href="http://i0.itc.cn/20170216/3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png"><img src="http://i0.itc.cn/20170216/3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png" alt="img"></a></p>
<p>使用整数对象池究竟能降低多少内存？让我们通过测试来对比对象池的内存优化效果，如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">操作说明</th>
<th align="left">是否对象共享</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">used_mem</th>
<th align="left">used_memory_rss</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入 200 万</td>
<td align="left">否</td>
<td align="left">20 字节</td>
<td align="left">[0-9999] 整数</td>
<td align="left">199.91MB</td>
<td align="left">205.28MB</td>
</tr>
<tr>
<td align="left">插入 200 万</td>
<td align="left">是</td>
<td align="left">20 字节</td>
<td align="left">[0-9999] 整数</td>
<td align="left">138.87MB</td>
<td align="left">143.28MB</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意本文所有测试环境都保持一致，信息如下:</span><br><span class="line">服务器信息: cpu=Intel-Xeon E5606@2.13GHz memory=32GB</span><br><span class="line">Redis版本:Redis server v=3.0.7 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64</span><br></pre></td></tr></table></figure>

<p>使用共享对象池后，相同的数据内存使用降低 30% 以上。可见当数据大量使用 [0-9999] 的整数时，共享对象池可以节约大量内存。需要注意的是对象池并不是只要存储 [0-9999] 的整数就可以工作。当设置 maxmemory 并启用 LRU 相关淘汰策略如 :volatile-lru，allkeys-lru 时，Redis 禁止使用共享对象池，测试命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; set key:1 99</span><br><span class="line">OK //设置key:1=99</span><br><span class="line">redis&gt; object refcount key:1</span><br><span class="line">(integer) 2 //使用了对象共享,引用数为2</span><br><span class="line">redis&gt; config set maxmemory-policy volatile-lru</span><br><span class="line">OK //开启LRU淘汰策略</span><br><span class="line">redis&gt; set key:2 99</span><br><span class="line">OK //设置key:2=99</span><br><span class="line">redis&gt; object refcount key:2</span><br><span class="line">(integer) 3 //使用了对象共享,引用数变为3</span><br><span class="line">redis&gt; config set maxmemory 1GB</span><br><span class="line">OK //设置最大可用内存</span><br><span class="line">redis&gt; set key:3 99</span><br><span class="line">OK //设置key:3=99</span><br><span class="line">redis&gt; object refcount key:3</span><br><span class="line">(integer) 1 //未使用对象共享,引用数为1</span><br><span class="line">redis&gt; config set maxmemory-policy volatile-ttl</span><br><span class="line">OK //设置非LRU淘汰策略</span><br><span class="line">redis&gt; set key:4 99</span><br><span class="line">OK //设置key:4=99</span><br><span class="line">redis&gt; object refcount key:4</span><br><span class="line">(integer) 4 //又可以使用对象共享,引用数变为4</span><br></pre></td></tr></table></figure>

<h3 id="为什么开启-maxmemory-和-LRU-淘汰策略后对象池无效"><a href="#为什么开启-maxmemory-和-LRU-淘汰策略后对象池无效" class="headerlink" title="为什么开启 maxmemory 和 LRU 淘汰策略后对象池无效 ?"></a>为什么开启 maxmemory 和 LRU 淘汰策略后对象池无效 ?</h3><p>LRU 算法需要获取对象最后被访问时间，以便淘汰最长未访问数据，每个对象最后访问时间存储在 redisObject 对象的 lru 字段。对象共享意味着多个引用共享同一个 redisObject，这时 lru 字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置 maxmemory，直到内存被用尽 Redis 也不会触发内存回收，所以共享对象池可以正常工作。</p>
<p>综上所述，共享对象池与 maxmemory+LRU 策略冲突，使用时需要注意。 对于 ziplist 编码的值对象，即使内部数据为整数也无法使用共享对象池，因为 ziplist 使用压缩且内存连续的结构，对象共享判断成本过高，ziplist 编码细节后面内容详细说明。</p>
<h3 id="为什么只有整数对象池？"><a href="#为什么只有整数对象池？" class="headerlink" title="为什么只有整数对象池？"></a>为什么只有整数对象池？</h3><p>首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis 之所以只有整数对象池，是因为整数比较算法时间复杂度为 O(1)，只保留一万个整数为了防止对象池浪费。如果是字符串判断相等性，时间复杂度变为 O(n)，特别是长字符串更消耗性能 (浮点数在 Redis 内部使用字符串存储)。对于更复杂的数据结构如 hash,list 等，相等性判断需要 O(n2)。对于单线程的 Redis 来说，这样的开销显然不合理，因此 Redis 只保留整数共享对象池。</p>
<h2 id="四-字符串优化"><a href="#四-字符串优化" class="headerlink" title="四 . 字符串优化"></a>四 . 字符串优化</h2><p>字符串对象是 Redis 内部最常用的数据类型。所有的键都是字符串类型， 值对象数据除了整数之外都使用字符串存储。比如执行命令 :lpush cache:type “redis” “memcache” “tair” “levelDB” ，Redis 首先创建”cache:type”键字符串，然后创建链表对象，链表对象内再包含四个字符串对象，排除 Redis 内部用到的字符串对象之外至少创建 5 个字符串对象。可见字符串对象在 Redis 内部使用非常广泛，因此深刻理解 Redis 字符串对于内存优化非常有帮助 :</p>
<h3 id="1-字符串结构"><a href="#1-字符串结构" class="headerlink" title="1. 字符串结构"></a>1. 字符串结构</h3><p>Redis 没有采用原生 C 语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串 (simple dynamic string)，简称 SDS。结构下图所示。</p>
<p><a href="http://i2.itc.cn/20170216/3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png"><img src="http://i2.itc.cn/20170216/3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png" alt="img"></a></p>
<p>Redis 自身实现的字符串结构有如下特点 :</p>
<ul>
<li>O(1) 时间复杂度获取：字符串长度，已用长度，未用长度。</li>
<li>可用于保存字节数组，支持安全的二进制数据存储。</li>
<li>内部实现空间预分配机制，降低内存再分配次数。</li>
<li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。</li>
</ul>
<h3 id="2-预分配机制"><a href="#2-预分配机制" class="headerlink" title="2. 预分配机制"></a>2. 预分配机制</h3><p>因为字符串 (SDS) 存在预分配机制，日常开发中要小心预分配带来的内存浪费，例如下表的测试用例。</p>
<h4 id="表：字符串内存预分配测试"><a href="#表：字符串内存预分配测试" class="headerlink" title="表：字符串内存预分配测试"></a>表：字符串内存预分配测试</h4><table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">数据量</th>
<th align="left">操作说明</th>
<th align="left">命令</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">used_mem</th>
<th align="left">used_memory_rss</th>
<th align="left">mem_fragmentation_ratio</th>
</tr>
</thead>
<tbody><tr>
<td align="left">阶段 1</td>
<td align="left">200w</td>
<td align="left">新插入 200w 数据</td>
<td align="left">set</td>
<td align="left">20 字节</td>
<td align="left">60 字节</td>
<td align="left">321.98MB</td>
<td align="left">331.44MB</td>
<td align="left">1.02</td>
</tr>
<tr>
<td align="left">阶段 2</td>
<td align="left">200w</td>
<td align="left">在阶段 1 上每个对象追加 60 字节数据</td>
<td align="left">append</td>
<td align="left">20 字节</td>
<td align="left">60 字节</td>
<td align="left">657.67MB</td>
<td align="left">752.80MB</td>
<td align="left">1.14</td>
</tr>
<tr>
<td align="left">阶段 3</td>
<td align="left">200w</td>
<td align="left">重新插入 200w 数据</td>
<td align="left">set</td>
<td align="left">20 字节</td>
<td align="left">120 字节</td>
<td align="left">474.56MB</td>
<td align="left">482.45MB</td>
<td align="left">1.02</td>
</tr>
</tbody></table>
<p>从测试数据可以看出，同样的数据追加后内存消耗非常严重，下面我们结合图来分析这一现象。阶段 1 每个字符串对象空间占用如下图所示。</p>
<p><a href="http://i3.itc.cn/20170216/3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png"><img src="http://i3.itc.cn/20170216/3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png" alt="img"></a></p>
<p>阶段 1 插入新的字符串后，free 字段保留空间为 0，总占用空间 &#x3D; 实际占用空间+1 字节，最后 1 字节保存‘\0’标示结尾，这里忽略 int 类型 len 和 free 字段消耗的 8 字节。在阶段 1 原有字符串上追加 60 字节数据空间占用如下图所示。</p>
<p><a href="http://i2.itc.cn/20170216/3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png"><img src="http://i2.itc.cn/20170216/3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png" alt="img"></a></p>
<p>追加操作后字符串对象预分配了一倍容量作为预留空间，而且大量追加操作需要内存重新分配，造成内存碎片率 (mem_fragmentation_ratio) 上升。直接插入与阶段 2 相同数据的空间占用，如下图所示。</p>
<p><a href="http://i1.itc.cn/20170216/3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png"><img src="http://i1.itc.cn/20170216/3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png" alt="img"></a></p>
<p>阶段 3 直接插入同等数据后，相比阶段 2 节省了每个字符串对象预分配的空间，同时降低了碎片率。<br>字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。字符串预分配每次并不都是翻倍扩容，空间预分配规则如下 :</p>
<ul>
<li>第一次创建 len 属性等于数据实际大小，free 等于 0，不做预分配。</li>
<li>修改后如果已有 free 空间不够且数据小于 1M，每次预分配一倍容量。如原有 len&#x3D;60byte，free&#x3D;0，再追加 60byte，预分配 120byte，总占用空间 :60byte+60byte+120byte+1byte。</li>
<li>修改后如果已有 free 空间不够且数据大于 1MB，每次预分配 1MB 数据。如原有 len&#x3D;30MB，free&#x3D;0，当再追加 100byte , 预分配 1MB，总占用空间 :1MB+100byte+1MB+1byte。<br>开发提示 : 尽量减少字符串频繁修改操作如 append，setrange, 改为直接使用 set 修改字符串，降低预分配带来的内存浪费和内存碎片化。</li>
</ul>
<h3 id="3-字符串重构"><a href="#3-字符串重构" class="headerlink" title="3. 字符串重构"></a>3. 字符串重构</h3><p>字符串重构 : 指不一定把每份数据作为字符串整体存储，像 json 这样的数据可以使用 hash 结构，使用二级结构存储也能帮我们节省内存。同时可以使用 hmget,hmset 命令支持字段的部分读取修改，而不用每次整体存取。例如下面的 json 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;vid&quot;: &quot;413368768&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;搜狐屌丝男士&quot;,</span><br><span class="line">    &quot;videoAlbumPic&quot;: &quot;http://photocdn.sohu.com/60160518/vrsa_ver8400079_ae433_pic26.jpg&quot;,</span><br><span class="line">    &quot;pid&quot;: &quot;6494271&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;1024&quot;,</span><br><span class="line">    &quot;playlist&quot;: &quot;6494271&quot;,</span><br><span class="line">    &quot;playTime&quot;: &quot;468&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别使用字符串和 hash 结构测试内存表现，如下表所示。</p>
<h4 id="表：测试内存表现"><a href="#表：测试内存表现" class="headerlink" title="表：测试内存表现"></a>表：测试内存表现</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key</th>
<th align="left">存储类型</th>
<th align="left">value</th>
<th align="left">配置</th>
<th align="left">used_mem</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">string</td>
<td align="left">json 字符串</td>
<td align="left">默认</td>
<td align="left">612.62M</td>
</tr>
<tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">hash</td>
<td align="left">key-value 对</td>
<td align="left">默认</td>
<td align="left">默认 1.88GB</td>
</tr>
<tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">hash</td>
<td align="left">key-value 对</td>
<td align="left">hash-max-ziplist-value:66</td>
<td align="left">535.60M</td>
</tr>
</tbody></table>
<p>根据测试结构，第一次默认配置下使用 hash 类型，内存消耗不但没有降低反而比字符串存储多出 2 倍，而调整 hash-max-ziplist-value&#x3D;66 之后内存降低为 535.60M。因为 json 的 videoAlbumPic 属性长度是 65，而 hash-max-ziplist-value 默认值是 64，Redis 采用 hashtable 编码方式，反而消耗了大量内存。调整配置后 hash 类型内部编码方式变为 ziplist，相比字符串更省内存且支持属性的部分操作。下一节将具体介绍 ziplist 编码优化细节。</p>
<h2 id="五-编码优化"><a href="#五-编码优化" class="headerlink" title="五 . 编码优化"></a>五 . 编码优化</h2><h3 id="1-了解编码"><a href="#1-了解编码" class="headerlink" title="1. 了解编码"></a>1. 了解编码</h3><p>Redis 对外提供了 string,list,hash,set,zet 等类型，但是 Redis 内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。使用 object encoding {key} 命令获取编码类型。如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; set str:1 hello</span><br><span class="line">OK</span><br><span class="line">redis&gt; object encoding str:1</span><br><span class="line">&quot;embstr&quot; // embstr编码字符串</span><br><span class="line">redis&gt; lpush list:1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;ziplist&quot; // ziplist编码列表</span><br></pre></td></tr></table></figure>

<p>Redis 针对每种数据类型 (type) 可以采用至少两种编码方式来实现，下表表示 type 和 encoding 的对应关系。</p>
<h4 id="表：type-和-encoding-对应关系表"><a href="#表：type-和-encoding-对应关系表" class="headerlink" title="表：type 和 encoding 对应关系表"></a>表：type 和 encoding 对应关系表</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码方式</th>
<th align="left">数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">raw embstr int</td>
<td align="left">动态字符串编码 优化内存分配的字符串编码 整数编码</td>
</tr>
<tr>
<td align="left">hash</td>
<td align="left">hashtable ziplist</td>
<td align="left">散列表编码 压缩列表编码</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">linkedlist ziplist quicklist</td>
<td align="left">双向链表编码 压缩列表编码 3.2 版本新的列表编码</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">hashtable intset</td>
<td align="left">散列表编码 整数集合编码</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">skiplist ziplist</td>
<td align="left">跳跃表编码 压缩列表编码</td>
</tr>
</tbody></table>
<p>了解编码和类型对应关系之后，我们不禁疑惑 Redis 为什么需要对一种数据结构实现多种编码方式？<br>主要原因是 Redis 作者想通过不同编码实现效率和空间的平衡。比如当我们的存储只有 10 个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要 : 前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表 (ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为 O(n2) 性能也可满足需求。</p>
<h3 id="2-控制编码类型"><a href="#2-控制编码类型" class="headerlink" title="2. 控制编码类型"></a>2. 控制编码类型</h3><p>编码类型转换在 Redis 写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; lpush list:1 a b c d</span><br><span class="line">(integer) 4 //存储4个元素</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;ziplist&quot; //采用ziplist压缩列表编码</span><br><span class="line">redis&gt; config set list-max-ziplist-entries 4</span><br><span class="line">OK //设置列表类型ziplist编码最大允许4个元素</span><br><span class="line">redis&gt; lpush list:1 e</span><br><span class="line">(integer) 5 //写入第5个元素e</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;linkedlist&quot; //编码类型转换为链表</span><br><span class="line">redis&gt; rpop list:1</span><br><span class="line">&quot;a&quot; //弹出元素a</span><br><span class="line">redis&gt; llen list:1</span><br><span class="line">(integer) 4 // 列表此时有4个元素</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;linkedlist&quot; //编码类型依然为链表，未做编码回退</span><br></pre></td></tr></table></figure>

<p>以上命令体现了 list 类型编码的转换过程，其中 Redis 之所以不支持编码回退，主要是数据增删频繁时，数据向压缩编码转换非常消耗 CPU，得不偿失。以上示例用到了 list-max-ziplist-entries 参数，这个参数用来决定列表长度在多少范围内使用 ziplist 编码。当然还有其它参数控制各种数据类型的编码，如下表所示：</p>
<h4 id="表：hash-list-set-zset-内部编码配置"><a href="#表：hash-list-set-zset-内部编码配置" class="headerlink" title="表：hash,list,set,zset 内部编码配置"></a>表：hash,list,set,zset 内部编码配置</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码</th>
<th align="left">决定条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">ziplist</td>
<td align="left">满足所有条件 : value 最大空间 (字节)&lt;&#x3D;hash-max-ziplist-value field 个数 &lt;&#x3D;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">hashtable</td>
<td align="left">满足任意条件 : value 最大空间 (字节)&gt;hash-max-ziplist-value field 个数 &gt;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">ziplist</td>
<td align="left">ziplist 满足所有条件 : value 最大空间 (字节)&lt;&#x3D;list-max-ziplist-value 链表长度 &lt;&#x3D;list-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">linkedlist</td>
<td align="left">满足任意条件 value 最大空间 (字节)&gt;list-max-ziplist-value 链表长度 &gt;list-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">quicklist</td>
<td align="left">3.2 版本新编码 : 废弃 list-max-ziplist-entries 和 list-max-ziplist-entries 配置 使用新配置 :  list-max-ziplist-size: 表示最大压缩空间或长度 , 最大空间使用 [-5-1] 范围配置，默认-2 表示 8KB, 正整数表示最大压缩长度 list-compress-depth: 表示最大压缩深度，默认 &#x3D;0 不压缩</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">intset</td>
<td align="left">满足所有条件 : 元素必须为整数 集合长度 &lt;&#x3D;set-max-intset-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">hashtable</td>
<td align="left">满足任意条件 元素非整数类型 集合长度 &gt;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">ziplist</td>
<td align="left">满足所有条件 : value 最大空间 (字节)&lt;&#x3D;zset-max-ziplist-value 有序集合长度 &lt;&#x3D;zset-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">skiplist</td>
<td align="left">满足任意条件 : value 最大空间 (字节)&gt;zset-max-ziplist-value 有序集合长度 &gt;zset-max-ziplist-entries</td>
</tr>
</tbody></table>
<p>掌握编码转换机制，对我们通过编码来优化内存使用非常有帮助。下面以 hash 类型为例，介绍编码转换的运行流程，如下图所示。</p>
<p>掌握编码转换机制，对我们通过编码来优化内存使用非常有帮助。下面以 hash 类型为例，介绍编码转换的运行流程，如下图所示。</p>
<p><a href="http://i2.itc.cn/20170216/3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png"><img src="http://i2.itc.cn/20170216/3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png" alt="img"></a></p>
<p>理解编码转换流程和相关配置之后，可以使用 config set 命令设置编码相关参数来满足使用压缩编码的条件。对于已经采用非压缩编码类型的数据如 hashtable,linkedlist 等，设置参数后即使数据满足压缩编码条件，Redis 也不会做转换，需要重启 Redis 重新加载数据才能完成转换。</p>
<h3 id="3-ziplist-编码"><a href="#3-ziplist-编码" class="headerlink" title="3.ziplist 编码"></a>3.ziplist 编码</h3><p>ziplist 编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist 编码是应用范围最广的一种，可以分别作为 hash、list、zset 类型的底层数据结构实现。首先从 ziplist 编码结构开始分析，它的内部结构类似这样 :&lt;….&gt;。一个 ziplist 可以包含多个 entry(元素)，每个 entry 保存具体的数据 (整数或者字节数组)，内部结构如下图所示。</p>
<p><a href="http://i1.itc.cn/20170216/3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png"><img src="http://i1.itc.cn/20170216/3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png" alt="img"></a></p>
<p>ziplist 结构字段含义：</p>
<ul>
<li>zlbytes: 记录整个压缩列表所占字节长度，方便重新调整 ziplist 空间。类型是 int-32，长度为 4 字节</li>
<li>zltail: 记录距离尾节点的偏移量，方便尾节点弹出操作。类型是 int-32，长度为 4 字节</li>
<li>zllen: 记录压缩链表节点数量，当长度超过 216-2 时需要遍历整个列表获取长度，一般很少见。类型是 int-16，长度为 2 字节</li>
<li>entry: 记录具体的节点，长度根据实际存储的数据而定。<ul>
<li>prev_entry_bytes_length: 记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代。</li>
<li>encoding: 标示当前节点编码和长度，前两位表示编码类型：字符串 &#x2F; 整数，其余位表示数据长度。 </li>
<li>contents: 保存节点的值，针对实际数据长度做内存占用优化。</li>
</ul>
</li>
<li>zlend: 记录列表结尾，占用一个字节。</li>
</ul>
<p>根据以上对 ziplist 字段说明，可以分析出该数据结构特点如下 :</p>
<ul>
<li>内部表现为数据紧凑排列的一块连续内存数组。</li>
<li>可以模拟双向链表结构，以 O(1) 时间复杂度入队和出队。</li>
<li>新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。</li>
<li>读写操作涉及复杂的指针移动，最坏时间复杂度为 O(n2)。</li>
<li>适合存储小对象和长度有限的数据。</li>
</ul>
<p>下面通过测试展示 ziplist 编码在不同类型中内存和速度的表现，如下表所示。 </p>
<h4 id="表：ziplist-在-hash-list-zset-内存和速度测试"><a href="#表：ziplist-在-hash-list-zset-内存和速度测试" class="headerlink" title="表：ziplist 在 hash,list,zset 内存和速度测试"></a>表：ziplist 在 hash,list,zset 内存和速度测试</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">数据量</th>
<th align="left">key 总数量</th>
<th align="left">长度</th>
<th align="left">value 大小</th>
<th align="left">普通编码内存量 &#x2F; 平均耗时</th>
<th align="left">压缩编码内存量 &#x2F; 平均耗时</th>
<th align="left">内存降低比例</th>
<th align="left">耗时增长倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">103.37M&#x2F;0.84 微秒</td>
<td align="left">43.83M&#x2F;13.24 微秒</td>
<td align="left">57.5%</td>
<td align="left">15 倍</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">92.46M&#x2F;2.04 微秒</td>
<td align="left">39.92M&#x2F;5.45 微秒</td>
<td align="left">56.8%</td>
<td align="left">2.5 倍</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">151.84M&#x2F;1.85 微秒</td>
<td align="left">43.83M&#x2F;77.88 微秒</td>
<td align="left">71%</td>
<td align="left">42 倍</td>
</tr>
</tbody></table>
<p>测试数据采用 100W 个 36 字节数据，划分为 1000 个键，每个类型长度统一为 1000。从测试结果可以看出：</p>
<ul>
<li>使用 ziplist 可以分别作为 hash,list,zset 数据类型实现。</li>
<li>使用 ziplist 编码类型可以大幅降低内存占用。</li>
<li>ziplist 实现的数据类型相比原生结构，命令操作更加耗时，不同类型耗时排序 :list &lt; hash &lt; zset。<br>ziplist 压缩编码的性能表现跟值长度和元素个数密切相关，正因为如此 Redis 提供了{type}-max-ziplist-value 和{type}-max-ziplist-entries 相关参数来做控制 ziplist 编码转换。最后再次强调使用 ziplist 压缩编码的原则：追求空间和时间的平衡。<br>开发提示：</li>
<li>针对性能要求较高的场景使用 ziplist，建议长度不要超过 1000，每个元素大小控制在 512 字节以内。</li>
<li>命令平均耗时使用 info Commandstats 命令获取，包含每个命令调用次数，总耗时，平均耗时，单位微秒。</li>
</ul>
<h3 id="4-intset-编码"><a href="#4-intset-编码" class="headerlink" title="4.intset 编码"></a>4.intset 编码</h3><p>intset 编码是集合 (set) 类型编码的一种，内部表现为存储有序，不重复的整数集。当集合只包含整数且长度不超过 set-max-intset-entries 配置时被启用。执行以下命令查看 intset 表现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set:test 3 4 2 6 8 9 2</span><br><span class="line">(integer) 6 //乱序写入6个整数</span><br><span class="line">127.0.0.1:6379&gt; object encoding set:test</span><br><span class="line">&quot;intset&quot; //使用intset编码</span><br><span class="line">127.0.0.1:6379&gt; smembers set:test</span><br><span class="line">&quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; &quot;9&quot; // 排序输出整数结合</span><br><span class="line">redis&gt; config set set-max-intset-entries 6</span><br><span class="line">OK //设置intset最大允许整数长度</span><br><span class="line">redis&gt; sadd set:test 5</span><br><span class="line">(integer) 1 //写入第7个整数 5</span><br><span class="line">redis&gt; object encoding set:test</span><br><span class="line">&quot;hashtable&quot; // 编码变为hashtable</span><br><span class="line">redis&gt; smembers set:test</span><br><span class="line">&quot;8&quot; &quot;3&quot; &quot;5&quot; &quot;9&quot; &quot;4&quot; &quot;2&quot; &quot;6&quot; //乱序输出</span><br></pre></td></tr></table></figure>

<p>以上命令可以看出 intset 对写入整数进行排序，通过 O(log(n)) 时间复杂度实现查找和去重操作，intset 编码结构如下图所示。<br><a href="http://i1.itc.cn/20170216/3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png"><img src="http://i1.itc.cn/20170216/3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png" alt="img"></a></p>
<p>intset 的字段结构含义：</p>
<ul>
<li>encoding: 整数表示类型，根据集合内最长整数值确定类型，整数类型划分三种 :int-16，int-32，int-64。</li>
<li>length: 表示集合元素个数。</li>
<li>contents: 整数数组，按从小到大顺序保存。<br>intset 保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再做回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组。<br>开发提示：使用 intset 编码的集合时，尽量保持整数范围一致，如都在 int-16 范围内。防止个别大整数触发集合升级操作，产生内存浪费。<br>下面通过测试查看 ziplist 编码的集合内存和速度表现，如下表所示。</li>
</ul>
<h4 id="表：ziplist-编码在-set-下内存和速度表现"><a href="#表：ziplist-编码在-set-下内存和速度表现" class="headerlink" title="表：ziplist 编码在 set 下内存和速度表现"></a>表：ziplist 编码在 set 下内存和速度表现</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">编码</th>
<th align="left">集合长度</th>
<th align="left">内存量</th>
<th align="left">内存降低比例</th>
<th align="left">平均耗时</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">hashtable</td>
<td align="left">1 千</td>
<td align="left">61.97MB</td>
<td align="left">–</td>
<td align="left">0.78 毫秒</td>
</tr>
<tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">intset</td>
<td align="left">1 千</td>
<td align="left">4.77MB</td>
<td align="left">92.6%</td>
<td align="left">0.51 毫秒</td>
</tr>
<tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">ziplist</td>
<td align="left">1 千</td>
<td align="left">8.67MB</td>
<td align="left">86.2%</td>
<td align="left">13.12 毫秒</td>
</tr>
</tbody></table>
<p>根据以上测试结果发现 intset 表现非常好，同样的数据内存占用只有不到 hashtable 编码的十分之一。intset 数据结构插入命令复杂度为 O(n)，查询命令为 O(log(n))，由于整数占用空间非常小，所以在集合长度可控的基础上，写入命令执行速度也会非常快，因此当使用整数集合时尽量使用 intset 编码。上表测试第三行把 ziplist-hash 类型也放入其中，主要因为 intset 编码必须存储整数，当集合内保存非整数数据时，无法使用 intset 实现内存优化。这时可以使用 ziplist-hash 类型对象模拟集合类型，hash 的 field 当作集合中的元素，value 设置为 1 字节占位符即可。使用 ziplist 编码的 hash 类型依然比使用 hashtable 编码的集合节省大量内存。</p>
<h2 id="六-控制-key-的数量"><a href="#六-控制-key-的数量" class="headerlink" title="六 控制 key 的数量"></a>六 控制 key 的数量</h2><p>当使用 Redis 存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis 本质是一个数据结构服务器，它为我们提供多种数据结构，如 hash，list，set，zset 等结构。使用 Redis 时不要进入一个误区，大量使用 get&#x2F;set 这样的 API，把 Redis 当成 Memcached 使用。对于存储相同的数据内容利用 Redis 的数据结构降低外层键的数量，也可以节省大量内存。如下图所示，通过在客户端预估键规模，把大量键分组映射到多个 hash 结构中降低键的数量。</p>
<p><a href="http://i1.itc.cn/20170216/3084_d48315af_6789_08d6_823d_beec6378e7da_1.png"><img src="http://i1.itc.cn/20170216/3084_d48315af_6789_08d6_823d_beec6378e7da_1.png" alt="img"></a></p>
<p>hash 结构降低键数量分析：</p>
<ul>
<li>根据键规模在客户端通过分组映射到一组 hash 对象中，如存在 100 万个键，可以映射到 1000 个 hash 中，每个 hash 保存 1000 个元素。</li>
<li>hash 的 field 可用于记录原始 key 字符串，方便哈希查找。</li>
<li>hash 的 value 保存原始值对象，确保不要超过 hash-max-ziplist-value 限制。<br>下面测试这种优化技巧的内存表现，如下表所示。</li>
</ul>
<h4 id="表：hash-分组控制键规模测试"><a href="#表：hash-分组控制键规模测试" class="headerlink" title="表：hash 分组控制键规模测试"></a>表：hash 分组控制键规模测试</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">string 类型占用内存</th>
<th align="left">hash-ziplist 类型占用内存</th>
<th align="left">内存降低比例</th>
<th align="left">string:set 平均耗时</th>
<th align="left">hash:hset 平均耗时</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">512byte</td>
<td align="left">1392.64MB</td>
<td align="left">1000.97MB</td>
<td align="left">28.1%</td>
<td align="left">2.13 微秒</td>
<td align="left">21.28 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">200byte</td>
<td align="left">596.62MB</td>
<td align="left">399.38MB</td>
<td align="left">33.1%</td>
<td align="left">1.49 微秒</td>
<td align="left">16.08 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">100byte</td>
<td align="left">382.99MB</td>
<td align="left">211.88MB</td>
<td align="left">44.6%</td>
<td align="left">1.30 微秒</td>
<td align="left">14.92 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">50byte</td>
<td align="left">291.46MB</td>
<td align="left">110.32MB</td>
<td align="left">62.1%</td>
<td align="left">1.28 微秒</td>
<td align="left">13.48 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">20byte</td>
<td align="left">246.40MB</td>
<td align="left">55.63MB</td>
<td align="left">77.4%</td>
<td align="left">1.10 微秒</td>
<td align="left">13.21 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">5byte</td>
<td align="left">199.93MB</td>
<td align="left">24.42MB</td>
<td align="left">87.7%</td>
<td align="left">1.10 微秒</td>
<td align="left">13.06 微秒</td>
</tr>
</tbody></table>
<p>通过这个测试数据，可以说明：</p>
<ul>
<li>同样的数据使用 ziplist 编码的 hash 类型存储比 string 类型节约内存</li>
<li>节省内存量随着 value 空间的减少，越来越明显。</li>
<li>hash-ziplist 类型比 string 类型写入耗时，但随着 value 空间的减少，耗时逐渐降低。<br>使用 hash 重构后节省内存量效果非常明显，特变对于存储小对象的场景，内存只有不到原来的 1&#x2F;5。下面分析这种内存优化技巧的关键点：<ul>
<li>hash 类型节省内存的原理是使用 ziplist 编码，如果使用 hashtable 编码方式反而会增加内存消耗。</li>
<li>ziplist 长度需要控制在 1000 以内，否则由于存取操作时间复杂度在 O(n) 到 O(n2) 之间，长列表会导致 CPU 消耗严重，得不偿失。</li>
<li>ziplist 适合存储的小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时。</li>
<li>需要预估键的规模，从而确定每个 hash 结构需要存储的元素数量。</li>
<li>根据 hash 长度和元素大小，调整 hash-max-ziplist-entries 和 hash-max-ziplist-value 参数，确保 hash 类型使用 ziplist 编码。</li>
</ul>
</li>
</ul>
<p>关于 hash 键和 field 键的设计：</p>
<ul>
<li>当键离散度较高时，可以按字符串位截取，把后三位作为哈希的 field，之前部分作为哈希的键。如：key&#x3D;1948480 哈希 key&#x3D;group:hash:1948，哈希 field&#x3D;480。</li>
<li>当键离散度较低时，可以使用哈希算法打散键，如 : 使用 crc32(key)&amp;10000 函数把所有的键映射到“0-9999”整数范围内，哈希 field 存储键的原始值。</li>
<li>尽量减少 hash 键和 field 的长度，如使用部分键内容。</li>
</ul>
<p>使用 hash 结构控制键的规模虽然可以大幅降低内存，但同样会带来问题，需要提前做好规避处理。如下 :</p>
<ol>
<li>客户端需要预估键的规模并设计 hash 分组规则，加重客户端开发成本。</li>
<li>hash 重构后所有的键无法再使用超时 (expire) 和 LRU 淘汰机制自动删除，需要手动维护删除。</li>
<li>对于大对象，如 1KB 以上的对象。使用 hash-ziplist 结构控制键数量。<br>不过瑕不掩瑜，对于大量小对象的存储场景，非常适合使用 ziplist 编码的 hash 类型控制键的规模来降低内存。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发提示：使用ziplist+hash优化keys后，如果想使用超时删除功能，开发人员可以存储每个对象写入的时间，再通过定时任务使用hscan命令扫描数据，找出hash内超时的数据项删除即可。</span><br></pre></td></tr></table></figure>

<p>本文主要讲解 Redis 内存优化技巧，Redis 的数据特性是 “ALL IN MEMORY”，优化内存将变得非常重要。对于内存优化建议读者先要掌握 Redis 内存存储的特性比如字符串，压缩编码，整数集合等，再根据数据规模和所用命令需求去调整，从而达到空间和效率的最佳平衡。建议使用 Redis 存储大量数据时，把内存优化环节加入到前期设计阶段，否则数据大幅增长后，开发人员需要面对重新优化内存所带来开发和数据迁移的双重成本。当 Redis 内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化。当遇到瓶颈时，再去考虑水平扩展。即使对于集群化方案，垂直层面优化也同样重要，避免不必要的资源浪费和集群化后的管理成本。</p>]]></content>
      <categories>
        <category>Redis</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>退避策略</title>
    <url>/2022/03/12/backoff-strategy.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源  <a href="https://www.zcool.com.cn/work/ZNTQ3NzE5OTI=.html">https://www.zcool.com.cn/work/ZNTQ3NzE5OTI=.html</a>  PS：未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<p><a name="c7h2l"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系统之间的交互大多是通过 RPC 的方式，交互的协议包括 HTTP、Dubbo、gRpc 等，无论什么协议，在接口之间的调用时会存在一种异常情况，那就是超时。导致接口超时的原因大多是网络抖动，或者服务提供方能力受限，无法处理大量请求，比如 IO 网络消耗，数据库消耗，磁盘等。</p>
<p>在遇到接口超时问题时，我们可能会考虑重试接口调用，通过重试策略来减低接口超时错误，那么每次重试的时间间隔是多少呢？有什么规律呢？这就涉及退避策略。</p>
<p><a name="zD0XZ"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>退避是指怎么去做下一次的重试，通俗简单的理解就是等待多长时间，常见的退避策略有以下两种方式。</p>
<ul>
<li><p>固定时间间隔重试：一个接口调用失败了，不是立马返回失败，而是 hold 住线程，每隔一定时长重新调用接口，最多调用一定次数，只要其中一次成功了就直接返回。如果达到最大调用上限次数都没成功，接口返回失败。</p>
</li>
<li><p>指数时间间隔重试：重试的时间间隔不在是按照固定时间，而是按照一定的增加方式增加，比如第一次 1s，第二次 2s，第三次 4s 秒，依次按照某种规律增加。使用此类重试机制的如 RocketMQ 的消息重试。</p>
</li>
</ul>
<p>需要注意的是，退避策略和重试策略需要区分开来。重试策略，主要是用来判断调用接口异常时是否需要重试。退避策略着重的是在重试过程中怎么去做下一次的重试。</p>
<p><a name="uNXp6"></a></p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p><a name="o2hwI"></a></p>
<h3 id="Spring-BackOff"><a href="#Spring-BackOff" class="headerlink" title="Spring BackOff"></a>Spring BackOff</h3><p>清楚了退避策略，那么在代码中我们如何实现呢？这里可以参考 Spring 的 BackOff ，代码比较简单，具体的代码路径为 <code>org.springframework.util.backoff.BackOff</code> 该类为接口，具体实现有固定时间间隔重试 <code>FixedBackOff</code> 和指数时间间隔重试 <code>ExponentialBackOff</code> 。下面介绍一下如何使用。</p>
<p>通过查看 <code>BackOff</code>类里面注释，可以知道使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FixedBackOff</span> <span class="variable">backOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>();</span><br><span class="line"><span class="type">BackOffExecution</span> <span class="variable">exec</span> <span class="operator">=</span> backOff.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the operation recovery/retry loop:</span></span><br><span class="line"><span class="type">long</span> <span class="variable">waitInterval</span> <span class="operator">=</span> exec.nextBackOff();</span><br><span class="line"><span class="keyword">if</span> (waitInterval == BackOffExecution.STOP) &#123;</span><br><span class="line">    <span class="comment">// do not retry operation</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// sleep, e.g. Thread.sleep(waitInterval)</span></span><br><span class="line">    <span class="comment">// retry operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体使用时，我们需要在使用重试的代码中进行循环，直到重试策略停止。</p>
<p><a name="soOoQ"></a></p>
<h4 id="FixedBackOff"><a href="#FixedBackOff" class="headerlink" title="FixedBackOff"></a>FixedBackOff</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FixedBackOff</span> <span class="variable">fixedBackOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FixedBackOff</span>();</span><br><span class="line">fixedBackOff.setInterval(<span class="number">2_000</span>); <span class="comment">// 重试时间间隔, 单位毫秒</span></span><br><span class="line">fixedBackOff.setMaxAttempts(<span class="number">2</span>); <span class="comment">// 最大重试次数 </span></span><br><span class="line"><span class="type">BackOffExecution</span> <span class="variable">backOffExecution</span> <span class="operator">=</span> fixedBackOff.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> backOffExecution.nextBackOff();</span><br><span class="line">    <span class="keyword">if</span> (value == BackOffExecution.STOP) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.sleep(value);</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        System.err.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="cd8pe"></a></p>
<h4 id="ExponentialBackOff"><a href="#ExponentialBackOff" class="headerlink" title="ExponentialBackOff"></a>ExponentialBackOff</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">initialInterval</span> <span class="operator">=</span> <span class="number">100</span>;           <span class="comment">// 初始间隔</span></span><br><span class="line"><span class="type">double</span> <span class="variable">multiplier</span> <span class="operator">=</span> <span class="number">2.0</span>;              <span class="comment">// 递增倍数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxInterval</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000L</span>;         <span class="comment">// 最大间隔</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxElapsedTime</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000L</span>;     <span class="comment">// 累计最大的时间间隔</span></span><br><span class="line"></span><br><span class="line"><span class="type">ExponentialBackOff</span> <span class="variable">backOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackOff</span>(initialInterval, multiplier);</span><br><span class="line">backOff.setMaxInterval(maxInterval);</span><br><span class="line">backOff.setMaxElapsedTime(maxElapsedTime);</span><br><span class="line"></span><br><span class="line"><span class="type">BackOffExecution</span> <span class="variable">backOffExecution</span> <span class="operator">=</span> backOff.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> backOffExecution.nextBackOff();</span><br><span class="line">    <span class="keyword">if</span> (value == BackOffExecution.STOP) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(value);</span><br><span class="line">        Thread.sleep(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要自定义退避策略，只需要实现 <code>BackOff</code>和 <code>BackOffExecution</code>接口即可。</p>
<p><a name="mv2FF"></a></p>
<h3 id="Spring-Retry"><a href="#Spring-Retry" class="headerlink" title="Spring Retry"></a>Spring Retry</h3><p>Spring BackOff 提供的退避策略很清晰，如果我们在代码中去这样做，实在过于繁琐，遵从设计模式的开闭原则，我们应该避免直接修改核心逻辑，而是通过其他方式来进行代码控制。Spring 就为我们提供了相关工具，Spring Retry，通过 AOP 的方式来对一个方法进行重试 。在 maven 中，该包是这样描述的</p>
<blockquote>
<p>Spring Retry provides an abstraction around retrying failed operations, with an emphasis on declarative control of the process and policy-based behaviour that is easy to extend and customize. For instance, you can configure a plain POJO operation to retry if it fails, based on the type of exception, and with a fixed or exponential backoff.</p>
</blockquote>
<p>具体的使用和原理可以参考这篇文章 <a href="https://ost.51cto.com/posts/3324">Spring 中的重试机制，简单、实用！</a>，核心原理实现就是通过 AOP 。<br />在 Spring Retry 中，重试策略更为丰富。<br /><img src="https://cdn.0x4096.com//cdn/image/202203122146525.png"></p>
<ul>
<li>SimpleRetryPolicy<br />默认最多重试3次</li>
<li>TimeoutRetryPolicy<br />默认在1秒内失败都会重试</li>
<li>ExpressionRetryPolicy<br />符合表达式就会重试</li>
<li>CircuitBreakerRetryPolicy<br />增加了熔断的机制，如果不在熔断状态，则允许重试</li>
<li>CompositeRetryPolicy<br />可以组合多个重试策略</li>
<li>NeverRetryPolicy<br />从不重试</li>
<li>AlwaysRetryPolicy<br />总是重试</li>
</ul>
<p>退避策略也进行了丰富。<br /><img src="https://cdn.0x4096.com//cdn/image/202203122147544.png"></p>
<ul>
<li>FixedBackOffPolicy<br />默认固定延迟1秒后执行下一次重试</li>
<li>ExponentialBackOffPolicy<br />指数递增延迟执行重试，默认初始0.1秒，系数是2，那么下次延迟0.2秒，再下次就是延迟0.4秒，如此类推，最大30秒。</li>
<li>ExponentialRandomBackOffPolicy<br />在上面那个策略上增加随机性</li>
<li>UniformRandomBackOffPolicy<br />这个跟上面的区别就是，上面的延迟会不停递增，这个只会在固定的区间随机</li>
<li>StatelessBackOffPolicy<br />这个说明是无状态的，所谓无状态就是对上次的退避无感知，从它下面的子类也能看出来</li>
</ul>
<p>在使用时我们通过注解的方式进行重试和退避策略的设置，如果项目没有使用 Spring 框架，我们应该怎么使用呢？我们可以通过 RetryTemplate 进行重试和退避策略的构造，在 execute 方法入参中实现 RetryCallback 接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RetryTemplate</span> <span class="variable">retryTemplate</span> <span class="operator">=</span> RetryTemplate.builder()</span><br><span class="line">        .infiniteRetry()</span><br><span class="line">        .retryOn(Exception.class)</span><br><span class="line">        .uniformRandomBackoff(<span class="number">1000</span>, <span class="number">3000</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">retryTemplate.execute(<span class="keyword">new</span> <span class="title class_">HelloServiceRetryCallbackImpl</span>());</span><br></pre></td></tr></table></figure>

<p><a name="XVEs3"></a></p>
<h3 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h3><p>除了 Spring 提供的重试框架，<a href="https://resilience4j.readme.io/">resilience4j</a>  也提供了重试框架，resilience4j 功能比较丰富，有下面几个模块功能。</p>
<ul>
<li>resilience4j-circuitbreaker: Circuit breaking</li>
<li>resilience4j-ratelimiter: Rate limiting</li>
<li>resilience4j-bulkhead: Bulkheading</li>
<li>resilience4j-retry: Automatic retrying (sync and async)</li>
<li>resilience4j-cache: Result caching</li>
<li>resilience4j-timelimiter: Timeout handling</li>
</ul>
<p>这里需要使用 resilience4j-retry 的能力。具体使用需要通过编码的方式，没有像 Spring Retry 那样提供注解。示例如下，更多方法使用，自行阅读 API。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RetryConfig</span> <span class="variable">config</span> <span class="operator">=</span> RetryConfig.custom()</span><br><span class="line">        .maxAttempts(<span class="number">2</span>)</span><br><span class="line">        .waitDuration(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        <span class="comment">//.retryOnResult(response -&gt; response.getStatus() == 500)</span></span><br><span class="line">        .retryOnException(e -&gt; e <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">        .retryExceptions(IOException.class, TimeoutException.class)</span><br><span class="line">        .ignoreExceptions(IllegalArgumentException.class)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">RetryRegistry</span> <span class="variable">retryRegistry</span> <span class="operator">=</span> RetryRegistry.of(config);</span><br><span class="line"></span><br><span class="line"><span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> retryRegistry.retry(<span class="string">&quot;retry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">TestService</span> <span class="variable">testService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestService</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> Retry.decorateRunnable(retry, testService::test);</span><br><span class="line">runnable.run();</span><br></pre></td></tr></table></figure>


<p><a name="KV4vZ"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序的稳定性要想做好不是一件简单的事情，网络因素影响是常事，遇到网络抖动，网络拥堵，程序需要自适应调整，配置重试策略，结合实际情况选择合适的退避策略，尽可能的保证程序的可用性。</p>
<p><a name="s2Dif"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/54chensongxia/p/12376966.html">接口调用失败的退避策略</a> </li>
<li><a href="https://www.cnblogs.com/linyufeng/p/13361188.html">Spring retry使用和采坑记录</a></li>
<li><a href="https://ost.51cto.com/posts/3324">Spring 中的重试机制，简单、实用！</a></li>
<li><a href="https://www.jianshu.com/p/5531b66b777a">Resilience4j-轻量级熔断框架</a> </li>
<li><a href="https://resilience4j.readme.io/">resilience4j 官网</a></li>
</ol>]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>亿级用户中心的设计与实践</title>
    <url>/2021/07/05/design-and-practice-of-100-million-user-center.html</url>
    <content><![CDATA[<p>转载来源：vivo游戏技术团队 <a href="https://mp.weixin.qq.com/s/68ktS5d4B2fCub8SqVeUEw">https://mp.weixin.qq.com/s/68ktS5d4B2fCub8SqVeUEw</a></p>
<blockquote>
<p>用户中心是互联网最为基础的核心系统，随着业务和用户的增长，势必会带来不断的挑战。如何在亿级的情况下保证系统的高可用，高性能以及高安全，本文能够给你一套实践方案。</p>
<p>注1：本文讨论的是微服务框架下的用户中心，不涉及授权等功能；</p>
<p>注2：本文所涉及的用户中心设计与vivo自身业务无关。</p>
</blockquote>
<p>用户中心，顾名思义就是管理用户的地方，几乎是所有互联网公司最为核心的子系统之一。它的核心功能是登录与注册，主要功能是修改密码、换绑手机号码、获取用户信息、修改用户信息和一些延伸服务，同时还有登录之后生成Token以及校验Token的功能。下面我们从几个维度来拆解用户中心。</p>
<h1 id="一、服务架构"><a href="#一、服务架构" class="headerlink" title="一、服务架构"></a>一、服务架构</h1><p>用户中心既需要为用户提供服务，也会承担其他业务的频繁调用；既然需要为用户提供服务，它就会自带一些业务逻辑，比如用户在登录过程中需要风控或短信的校验，那么就会存在不可用的风险。而比如获取用户信息的接口，则没有那么多的依赖，可能只需要调用数据库或者缓存就可以。获取用户信息接口要求稳定，而核心的登录注册接口也需要稳定，但是当我们在接口层面加一些策略或者修改的时候，不希望因为上线问题导致整个服务不可用，而且上线后，需要对整个服务功能做全量的回归，导致资源严重浪费。</p>
<p>因此，基于业务特性，我们可以将用户中心拆成3个独立的微服务: 网关服务，核心服务，异步消费者服务。网关服务，提供http服务，聚合了各种业务逻辑和服务调用，比如登录时候需要校验的风控或者短信；核心服务，处理简单的业务逻辑以及数据存储，核心服务处在调用链路的终端，几乎不依赖调用其他服务，比如校验Token或者获取用户信息，他们就只依赖于redis或者数据库；而异步消费者服务，则处理并消费异步消息。下文会详细介绍。</p>
<p><img src="https://cdn.0x4096.com//cdn/image/202201052218135.webp" alt="图片"></p>
<p>这样的设计之后，当有新功能上线时，核心服务和异步消费服务几乎不需要重新发布，只需要发布网关服务，依赖我们核心服务的第三方非常放心，层级也非常的清晰。当然，这样做的代价就是服务的调用链路变长了。由于涉及到网关和核心服务，就需要发布两个服务，而且要做兼容性测试。</p>
<h1 id="二、接口设计"><a href="#二、接口设计" class="headerlink" title="二、接口设计"></a>二、接口设计</h1><p>用户中心的接口涉及到用户的核心信息，安全性要求高；同时，承接了较多第三方的调用，可用性要求也高。因此，对用户中心的接口做以下设计：</p>
<p>首先，接口可以拆分为面向Web和面向App的接口。Web接口需要做到跨域情况下的单点登录，加密、验签和token校验的方式也同App端的不一样。</p>
<p>其次，对核心接口做特殊处理。比如登录接口，在逻辑和链路上做了一些优化。为什么要对这些接口做特殊处理呢？假如用户不能登录，用户会非常恐慌，客诉量会立马上来。</p>
<p>那怎么做呢？一方面，我们将用户核心信息表做简单。用户的信息当中会包含userId、手机号码、密码、头像、昵称等字段，假如把用户的这些所有信息都保存在一张表中，那么这张表将会异常庞大，变更字段变得异常困难。因此，需要将用户表拆分，将核心的信息保存在用户表中，比如userId、username、手机号码、密码、盐值（随机生成）等；而一些如性别，头像，昵称等信息保存在用户资料表中。</p>
<p>另一方面，我们需要将登录的核心链路做短，短到只依赖于读库。一般情况下，用户登录后，需要记录用户登录信息，调用风控或者短信等服务。对于登录链路来说，任何一个环节出现问题都有可能导致用户无法登录，那么怎么样才能做到最短的链路呢？方法就是依赖的服务可自动降级。比如说反欺诈校验出问题了，那么它自动降级后使用它的默认策略，极端情况下只做密码校验，主库挂了之后还能到从库读取用户信息。</p>
<p>最后就是接口的安全性校验。对App接口我们需要做防重放和验签。验签可能大家比较熟悉，但是对防重放这个概念可能相对陌生。防重放，顾名思义就是防止请求重复发送。用户请求在特定时间段内只能请求一次。即使用户请求被攻击者挟持，在一段时间内也无法重复请求。如果攻击者想要篡改用户请求再发送，对不起，请求不会通过。得益于大数据的支持，结合终端，我们还可以把每个用户行为画像存储在系统中（或者调用第三方服务）。用户发起请求后，我们的接口会根据用户画像对用户进行诸如手机号码校验、实名认证、人脸或者活体校验。</p>
<p><img src="https://cdn.0x4096.com//cdn/image/202201052218385.webp" alt="图片"></p>
<h1 id="三、分库分表"><a href="#三、分库分表" class="headerlink" title="三、分库分表"></a>三、分库分表</h1><p>随着用户的增长，数据超过了1亿，怎么办？常见的办法就是分库分表。我们来分析一下用户中心常见的一些表结构：用户信息表，第三方登录关联表，用户事件表。从上述表中可以看出来，用户相关的数据表增长相对缓慢，因为用户增长是有天花板的。用户事件表的增长是呈指数级增长，因为每个用户登录、变更等密码及变更手机号码等操作是不限次数。</p>
<p>因此，首先我们可以先把用户信息表垂直切分。正如上面说的，将用户ID、密码、手机号、盐值等常见字段从用户信息表中拆分，其他用户相关的信息用单独一张表。另外，把用户事件表迁移至其他库中。相比于水平切分，垂直切分的代价相对较少，操作起来相对简单。用户核心信息表由于数据量相对较少，即使是亿级别的数据，利用数据库缓存的机制，也能够解决性能问题。</p>
<p>其次，我们可以利用前后台业务的特性采用不同的方式来区别对待。对于用户侧前台访问：用户通过username&#x2F;mobile登录或者通过uid来查询用户信息。用户侧信息的访问通常是单条数据的查询，我们可以通过索引多次查询来解决一致性和高可用问题。对于运营侧后台访问：根据年龄、性别、登录时间段、注册时间段等来进行查询，基本上都是批量分页查询。但是由于是内部系统，查询量低，对一致性要求低。如果用户侧和运营侧的查询采用同一个数据库，那么运营侧的排序查询会导致整个库的CPU上升，查询效率下降，影响到用户侧。因此，运营侧使用的数据库可以是和用户侧同样的MySQL离线库，如果想要增加运营侧的查询效率，可以采用ES非关系型数据库。ES支持分片与复制，方便水平分割和扩展，复制保证了ES的高可用与高吞吐，同时能够满足运营侧的查询需求。</p>
<p>最后，如果还是要水平切分来保证系统的性能，那么我们采取什么样的切分方式呢？常见的方法有索引表法和基因法。索引表法的思路主要是UID能够直接定位到库，但是手机号码或者username是无法直接定位到库的，需要建立一个索引表来记录mobile与UID或者username与UID的映射关系的方式来解决这个问题。通常这类数据比较少，可以不用分库分表，但是相比直接查询，多了一次数据库查询的同时，在新增数据的时候还多了一次映射关系的插入，事务变大。基因法的思路是我们将username或者mobile融入到UID中。具体做法如下：</p>
<ol>
<li>用户注册时，根据用户的手机号码，利用函数生成N bit的基因mobile_gen，使得mobile_gen&#x3D;f(mobile);</li>
<li>生成M bit全局唯一的id，作为用户标识；</li>
<li>拼接M和N，作为UID赋给用户；</li>
<li>根据N bit来取余来插入到特定数据库；</li>
<li>查找用户数据的时候，将用户UID的后N bit取余来落到最终的库中。</li>
</ol>
<p>从上述过程中看，基因法只适用于某类经常查询的场景，比如用手机号码登录，如果用户使用username登录就比较麻烦了。因此大家也可以根据自己的业务场景来选择不同的方式水平切分。</p>
<h1 id="四、Token之柔性降级"><a href="#四、Token之柔性降级" class="headerlink" title="四、Token之柔性降级"></a>四、Token之柔性降级</h1><p>用户登录之后，另一个重要的事情就是Token的生成与校验。用户的Token分为两类， 一类是web端登陆生成的Token， 这个Token可以和Cookie结合， 达到单点登陆的效果，在此不细说了。另外一类就是APP端登录生成的Token。用户在我们的APP输入用户名密码之后，服务端会对用户的用户名密码进行校验，成功之后从系统配置中心获取加密算法的版本以及秘钥，并按照一定的格式排列用户ID，手机号、随机码以及过期时间，经过一系列的加密之后，生成了Token之后并将其存入Redis缓存。而Token的校验就是把用户ID和Token组合并校验是否在Redis中存在。那么假如Redis不可用了怎么办呢？这里有一个高可用和自动降级的设计。当Redis不可用的时候， 服务端会生成一个特殊格式的Token。当校验Token的时候，会对Token的格式进行一个判断。</p>
<p><img src="https://cdn.0x4096.com//cdn/image/202201052218814.webp" alt="图片"></p>
<p>假如判断为Redis不可用时生成的Token，那么服务端会对Token进行解密，而Token的生成是由用户ID，手机号、随机码和过期时间等数据按照特定顺序排列并加密而来的， 那么解密出来的数据中也包含了ID，手机号码，随机码和过期时间。服务端会根据获取到的数据查询数据库， 比对之后告诉用户是否登录成功。由于内存缓存redis和数据库缓存性能的差距，在redis不可用的情况下，降级有可能会导致数据库无法及时响应，因此需要在降级的方法上加入限流。</p>
<p><img src="https://cdn.0x4096.com//cdn/image/202201052218656.webp" alt="图片"></p>
<h1 id="五、数据安全"><a href="#五、数据安全" class="headerlink" title="五、数据安全"></a>五、数据安全</h1><p>数据安全对用户中心来说非常重要。敏感数据需要脱敏处理，对密码更是要做多重的加密处理。应用虽然有自己的安全策略，但如果把黑客限制在登录之前，那应用的安全性将得到大幅度的提升。互联网上用户明文数据遭到泄露的案件屡屡发生，因此各大企业对数据安全的认识也提到了前所未有的高度。而即使使用了MD5和salt的加密方式，依然可以使用彩虹表的方式来破解。那么用户中心对用户信息是怎么保存的呢？</p>
<p>首先，正如上文中提到的用户密码、手机号等登录信息和其他的信息分离，而且在不同的数据库中。其次，对用户设置的密码进行了黑名单校验，只要符合条件的弱密码，都会拒绝提交，因为不管使用了什么加密方式的弱密码，都极其容易破解。为什么呢？因为人的记性很差，大部分人总是最倾向于选择生日，单词等来当密码。6位纯数字可以生成100万个不同的密码，8位小写字母和数字的组合大概可以生成2.8万亿个不同的密码。一个规模为7.8万亿的密码库足以覆盖大部分用户的密码，对于不同的加密算法都可以拥有这样一个密码库，这也就是为什么大部分网站都建议用户使用8位以上数字加字母密码的原因。当然，如果一方面加了盐值，另一方面对密钥分开保管，破解难度会指数级增加。</p>
<p>最后，可以用bcrypt&#x2F;scrypt的方式来加密。bcrypt算法是基于Blowfish块密钥算法来实现的，bcrypt内部实现了随机加盐处理，使用bcrypt之后每次加密后的密文都不一样，同时还会使用内存初始化hash过程。由于使用内存，虽然在CPU上运行很快，但是在GPU上并行运算并不快。随着新的FPGA集成了大型RAM，解决了内存密集IO的问题，但是破解难度依然不小。而scrypt算法弥补了bcrypt算法的不足，它将CPU计算与内存使用开销都指数级提升了。bcrypt和scrypt算法能够有效抵御彩虹表，但是安全性的提升带来了用户登录性能的下降。用户登录注册并不是一个高并发的接口，所以影响并不会特别大。因此在安全和性能方面需要依据业务类型和大小来做平衡，并不是所有的应用都需要使用这种加密方式来保护用户密码。</p>
<h1 id="六、异步消费设计"><a href="#六、异步消费设计" class="headerlink" title="六、异步消费设计"></a>六、异步消费设计</h1><p>此处的异步消费，就是上文提到的异步消费服务。用户在做完登录注册等操作后，需要记录用户的操作日志。同时，用户注册登录完毕后，下游业务需要对用户增加积分，赠送礼券等奖励操作。这些系统如果都同步依赖于用户中心，那么整个用户中心将异常庞大，链路非常冗长，也不符合业内的“大系统做小“的原则。依赖的服务不可用之后将会造成用户无法登录注册。因此，用户中心在用户操作完之后，将用户事件入库后发送至MQ，第三方业务监听用户事件。用户中心和下游业务解耦，同时用户操作事件入库后，在MQ不可用或者消息丢失的时候可做补偿处理。用户的画像数据也在很大程度上来源于此处的数据。</p>
<h1 id="七、灵活多样的监控"><a href="#七、灵活多样的监控" class="headerlink" title="七、灵活多样的监控"></a>七、灵活多样的监控</h1><p>用户中心涉及到用户的登录注册更改密码等核心功能，能否及时发现系统的问题成为关键指标，因此对业务的监控显得尤为重要。需要对用户中心重要接口的QPS、机器的内存使用量、垃圾回收的时间、服务的调用时间等做详细的监控。当某个接口的调用量下降的时候，监控会及时发出报警。除了这些监控之外，还有对数据库Binlog的写入，前端组件，以及基于ZipKin全链路调用时间的监控，实现从用户发起端到结束端的全面监控，哪怕出现一点问题，监控随时会告诉你哪里出问题了。比如运营互动推广注册量下降的时候，用户中心就会发出报警，可以及时通知业务方改正问题，挽回损失。</p>]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈线程</title>
    <url>/2021/06/30/talk-about-thread-again.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源  <a href="https://www.zcool.com.cn/work/ZNDU3ODY1NzY=.html">https://www.zcool.com.cn/work/ZNDU3ODY1NzY=.html</a><br>未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<p>​</p>
<p>谈起线程，大多数问起的话题无非是线程有几种状态（6种），几种创建方式（三种），他们的区别是什么，进而引申多线程，线程安全，线程池等。<br>​</p>
<p>在 Java 中，线程的几种状态。<br>​</p>
<blockquote>
<p>A thread state. A thread can be in one of the following states:<br>​</p>
</blockquote>
<blockquote>
<p><strong>NEW</strong> A thread that has not yet started is in this state.<br><strong>RUNNABLE</strong> A thread executing in the Java virtual machine is in this state.<br><strong>BLOCKED</strong> A thread that is blocked waiting for a monitor lock is in this state.<br><strong>WAITING</strong> A thread that is waiting indefinitely for another thread to perform a particular action is in this state.<br><strong>TIMED_WAITING</strong> A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.<br><strong>TERMINATED</strong> A thread that has exited is in this state.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>校招那会，一个面试官问过我，什么守护线程，和用户线程有什么区别，什么情况下使用使用特定的线程？回想，竟是两年前的事情。<br>​</p>
<p>和同事一起开发项目，遇到一件奇怪的事。同事把服务发在测试环境，发现 http 请求不通，但是通过 PS 命令能看见应用的进程，并且有 info 级别的日志在输出，且没有错误日志（日志配置不规范，大忌，配置可参考：），同事找到我，我是新人，瑟瑟发抖的帮忙解决问题（之前帮忙解决了一个日志无法输出的问题）。 应用是 SpringBoot 框架搭建的，服务没起来（tomcat没起来），但是依然有日志在输出，通过 PS 命令查看能发现进程存在。<br>​</p>
<p>如果是你，你能第一时间知道或者猜测哪里出问题了吗？我第一次遇见这样的情况，一脸懵逼的看着PS命令的结果和 tail -f info.log 一行行的日志，陷入了沉思，主线程挂了，子线程不应该也挂了吗？我和旁边的同事说起这个质疑，他给我的回答说：是啊。可实际上，我们看到的情况并不是这样，主线程挂了，但是子线程还在执行。<br>​</p>
<p>补补基础知识，在 Java 中，线程分为两种，用户线程和守护线程，通过 Thread.setDaemon(true) 设置为守护线程，默认为用户线程。主线程结束子线程不一定结束，如果是用户线程则子线程可一直运行，若是守护线程，则主线程结束时，子线程结束。守护线程用完就没了，比如  JVM 的垃圾回收器就是守护线程在执行。总结一句话就是：主线程结束后用户线程还会继续运行，JVM存活。<br>​</p>
<p>我们来看一段代码。<br>​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">CommandRunnable</span>());</span><br><span class="line">        <span class="comment">//thread.setDaemon(true);</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;主线程异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CommandRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                log.error(UUID.randomUUID().toString());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>执行记录如下，可以看出，即使主线程结束，他的子线程（用户线程）依然在执行。如果把 thread.setDaemon(true) 启用，当主线程发生异常时，子线程（此时为守护线程）则会停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: 主线程异常</span><br><span class="line">	at com.github.Is0x4096.demo.ThreadTest.main(ThreadTest.java:<span class="number">20</span>)</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">01.559</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 98dcacae-0f42-4b1b-a65e-cf2713019afe</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">02.065</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 350b9cee-287e-40d8-abad-e6629dc42ce7</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">02.569</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 08367116-c49c-4b2d-a6e5-e242168dabf9</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">03.072</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 21e4e0da-9df3-4fe2-97bd-3bc473c871d1</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">03.577</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 1465d1a4-55b8-<span class="number">4e46</span>-90be-f2c4c8fadc4b</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">04.081</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 552e5bef-c0af-4ad1-<span class="number">8995</span>-366788199f3f</span><br><span class="line"><span class="number">22</span>:<span class="number">24</span>:<span class="number">04.586</span> [Thread-<span class="number">0</span>] ERROR com.github.Is0x4096.demo.ThreadTest - 8436bf4f-<span class="number">3566</span>-40a5-a8f9-6d6790da0ab6</span><br></pre></td></tr></table></figure>


<p>补完基础知识点，在看来 SpringBoot 启动过程的核心代码。org.springframework.boot.SpringApplication#run(java.lang.String…)<br>​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">	<span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	<span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	<span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">	listeners.starting();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">		<span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		<span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context);</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           <span class="comment">// 应用启动错误，被 catch 住，看方面里面的逻辑</span></span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		listeners.running(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>程序发生了异常，接下来 Spring 会去关闭容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRunFailure</span><span class="params">(ConfigurableApplicationContext context, Throwable exception,</span></span><br><span class="line"><span class="params">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters, SpringApplicationRunListeners listeners)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			handleExitCode(context, exception);</span><br><span class="line">			<span class="keyword">if</span> (listeners != <span class="literal">null</span>) &#123;</span><br><span class="line">				listeners.failed(context, exception);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			reportFailure(exceptionReporters, exception);</span><br><span class="line">			<span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">				context.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		logger.warn(<span class="string">&quot;Unable to close ApplicationContext&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 再次抛异常，把错误信息抛出去，走到这里主线程结束</span></span><br><span class="line">	ReflectionUtils.rethrowRuntimeException(exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>断点走到这里，发现了 Spring 没启动的根本原因，但是这个时候主线程结束了，为什么还有日志在输出？<br>​</p>
<p>仔细看了一下日志的输出时间间隔，十秒一次，这肯定是一个定时任务的杰作，找到输出日志的类，发现果然有一个定时任务在执行，问题定位到了。下面的代码可以复现这种情况，三种方式均能导致服务没起来但是进程存在。<br>​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleThreadComponent</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor(Thread::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        executor.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">CommandRunnable</span>(), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02</span></span><br><span class="line">    <span class="comment">//public ScheduleThreadComponent() &#123;</span></span><br><span class="line">    <span class="comment">//    executor.scheduleWithFixedDelay(new CommandRunnable(), 1, 5, TimeUnit.SECONDS);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 03</span></span><br><span class="line">    <span class="comment">//@PostConstruct</span></span><br><span class="line">    <span class="comment">//public void test() &#123;</span></span><br><span class="line">    <span class="comment">//    executor.scheduleWithFixedDelay(new CommandRunnable(), 1, 5, TimeUnit.SECONDS);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他地方替换字符串，注意test并没有配置内容，模拟 Spring 启动失败</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>问题定位到了，其实是我们使用代码的方式不规范，我们在实际开发中会使用到线程池或者开启子线程去执行任务，这个任务的执行一定会在 Spring 容器启动后才会去执行，但是现在的情况是在 Spring 启动过程中我们的任务就开始执行，并且任务会一直执行，这是不太合理的做法。<br>​</p>
<p>约定大于配置，规范才能避免踩坑。<br>​</p>]]></content>
      <categories>
        <category>Java</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>一生中最可怕的时期，30岁上下，决定男人的一生</title>
    <url>/2021/06/02/thirtysomething.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面来源 <a href="https://www.zcool.com.cn/work/ZMTQ1ODY2MA==.html">https://www.zcool.com.cn/work/ZMTQ1ODY2MA==.html</a> 作者设置了图片禁止保存，还是很想使用，看看作者的故事吧。未授权… 若作者看到后不愿意授权可联系下架</p>
</blockquote>
<blockquote>
<p>说明： 本文转载 <a href="http://www.kanshangjie.com/article/65597-1.html">http://www.kanshangjie.com/article/65597-1.html</a> 作者：王剑</p>
</blockquote>
<p>6月1号，儿童节，群里收到信息说</p>
<ul>
<li><a href="http://www.kanshangjie.com/article/65597-1.html">http://www.kanshangjie.com/article/65597-1.html</a></li>
<li>少年们 加油</li>
<li>我已经过了这个坎了 但是还是一塌糊涂   哈哈哈哈哈</li>
</ul>
<p>看了文章发现太真实了，有一个朋友今年就29岁了，不知道他是不是也有类似的想法，上次和他喝酒，他说太失败了… 五味杂陈… 再过几年，我也到这个年纪，我会是怎样呢？</p>
<p>关于创业，有个想法好想去做，天时地利人和吧，再等等时间…</p>
<hr>
<p>今天我们就来讨论下男人创业最佳时机，希望所有准备创业以及正在创业的男人女人，都能在最佳时机创业成功！</p>
<p>30岁是人生的一道坎</p>
<p>30岁是男人的一个关口，要么你就此飞黄腾达，要么你就此一生潦倒！这绝非耸人听闻。2500年前，孔子就告诫前来求学的人：“吾十有五而志于学，三十而立。”这句话至今仍足以振聋发聩，警醒世人。30岁之前是助跑，30岁之后才是真正的启航。只有那些在30岁之前做好准备的人，起步才会有力，才有可能在30岁之后的岁月里披荆斩棘，有所建树。</p>
<p>30岁是人生的一道坎，已经失去所有可以为自己掩饰的借口。</p>
<p>你已经别无选择、无路可逃，只有背水一战，拿出更多的成就来应对世人的一切白眼……’三十而立’的咒语从古至今留传下来的’三十而立’，像一道魔咒，将30岁男人逼得即将跳墙！</p>
<p>30岁是人生一道坎，是男人不想面对但又无法逃避的枷锁和咒语。</p>
<p>一个个人生的关卡，30岁男人不得不铆足劲儿往前冲；他们深深感到了恐慌和危机，害怕自己30岁仍将一事无成？当男人快到30岁时，总会倒抽一口寒气。如果30岁仍无事业的根基，又无能给人’打杂’的高学历，那么，30岁男人便会在内心不住的咒骂自己–30岁了，我怎么还是个喽罗，我是不是要废了？！</p>
<p>其间的感受甚至远远超过了’万箭穿心’！</p>
<p>即便在穿着上，30岁男人也显得无所适从。如果每天西装革履，会被人误认为卖保险的；如果穿得松垮，则被当成下岗工人。面对这些，30岁男人总想邀知己小酌几杯，以便倾吐心中的苦水。然而，在这个朋友比熊猫都稀缺的时代，如果你没有钱借给他们，没有关系帮助他们，没有胆量和闲心陪他们泡桑拿、赌通宵，那还有谁愿意理你？</p>
<p>在夹缝中生存的30岁男人，已经不可挽回地陷入了’三十而立’的魔咒之中。他们已经失去所有可以为自己掩饰的借口，所有的解释都显得苍白和可笑。30岁男人已经别无选择、无路可逃，只有背水一战，拿出更多的成就来应对世人的一切白眼！</p>
<p>男人30，在夹缝中求生存30岁，是男人一生中最为可怕的时期。</p>
<p>我们都听过这样一句老掉牙的台词：’我上有80岁的老母，下有3岁小儿，求大爷放小的一条生路。’这是电视或电影中，小贼被抓后的情景，而拿它用来形容也许再恰当不过了。29岁的老刘在接近而立之年的时候，才找到一个女友。女友来自云南，其家庭条件和老刘的老家一样贫困，而且家里还有两个弟弟在读书。</p>
<p>这时候的老刘已经’北漂’了5年，一直以来，他都是租房住。22岁的女友距离大学毕业还有半年。老刘决定用自己辛辛苦苦存下的10万元存款买套房子。于是，他就带着自己的女友开始东奔西走忙碌自己的置房大事。历经数月之后，终于在北京远郊的一处房产商那里付清了首付，以月供的方式购置了属于自己的房子。不过房子离市区太远，只有一路公交车，小区对面还是绿油油的麦田。</p>
<p>从此，老刘开始了自己的’房奴’生活。当时正是他工作最不开心的时候，一个月收入才2000元左右，女友还在见习期，一个月才800元。每月还款1268元，快到两人收入的一半了，加上吃饭和交通费用，那简直就是捉襟见肘。每月的贷款，渐渐成了老刘的心病，他比以前更不敢消费了，’总像背着个什么东西’，老刘描述’心里总有什么不能放下’。</p>
<p>在第三年，老刘提前偿还了5万元贷款，这样他的月供就从1268元降低到862元，利息也少支出不少。但就在这时，他的女友却和他的一位朋友好上了，朋友的条件要比他好多了，房子是一次性付款的，事业也比老刘发达，而且人也比老刘年轻帅气。</p>
<p>正如老刘一样，几乎每天都在夹缝中求生存，为生计费尽心血、四处奔波。为有足够的钱去支付房费、水电费、柴米油盐，或者在天气炎热时装台空调，在饭菜变质前能买台冰箱。有了孩子之后，还要满足孩子的正常需要，不为学费而发愁，不会在孩子看上一件喜欢的玩具时掏不出足够的钱……</p>
<p>就在30岁男人为生活和事业而劳累奔波的时候，丁磊、张朝阳等在青春痘还没褪尽便成就了百万身价，80后的韩寒也拿到终身成就奖，《福布斯》上中国富人榜上的年轻人也越来越多。于是，他们开始接受这一次又一次的心灵刺激，面对生活的残酷和压力，他们不得不学会为自己找各种借口，使自己在看到20几岁便功成名就的男人时能安然处之！</p>
<p>30岁，对男人来说，的确是人生中最为可怕的时期。</p>
<p>他们都属于在夹缝中求生存一族，不仅没有了20几岁的阳光和朝气，也同样不具备40几岁的成熟和持重。一句简简单单的’30而立’便能将其折磨得像只病入膏肓的雄狮。</p>
<p>30岁，不再是风花雪月的年龄在香港导演许鞍华的电影《男人四十》里，张学友面对引诱自己出轨的女学生时，一脸疲惫地靠在车窗上感叹，人生就是考不完的联考。女生说，你要学会给自己放假。然而，对于30岁的男人，也许大考才刚刚开始，而假期还遥遥无期。要知道，已经不再是那个风花雪月的年龄了！</p>
<p>‘男人在20几岁的时候，可以刺青割腕，可以破衣烂衫，可以赌气辞职四处借宿，也可以念着某女孩的名字醉卧街头。总之，做事越不苟世俗，越显得青春残酷，以为这就算是真我的风采了。</p>
<p>然而，男人到了30岁的时候，却突然变得激情不再，愈加现实起来。虽然非常讨厌上司和同事，但为了饭碗，只好选择乖乖就范。也许会在某天突然对一个女孩动情，但却突然想到’又能怎样呢？’于是从心潮澎湃安静了下来。来来往往、匆匆忙忙，30岁的男人，开始把成本和收益作为择偶时的先决条件，年轻漂亮的自己奉陪不起，年龄大的又担心色衰爱弛，既不想伤害别人又舍不得全心付出。所有的风花雪月，都在这反反复复的衡量和计较中消磨殆尽。</p>
<p>男人到了30岁，必须要选定人生的方向、行业和未来。</p>
<p>这时候，所有的风花雪月都已远逝，留下的只有现实，而且是一个要持久努力才能够看到成就的现实。要有紧迫感，男人一过30老得快’男人一过30老得快’，30岁男人强烈地感到生命在飞速流逝，而现实中的自己却依然两手空空，一事无成。只要仔细观察就会发现，那些站在彩票机前痴痴不倦买彩票的大都是30岁男人。</p>
<p>但上天偏偏喜欢捉弄他们，越想得到的东西就越得不到，最后中500万大奖的不是五六十岁的老头，就是二十来岁的愣头青。如果没有丁俊晖，估计没有几个中国人知道斯诺克为何物。丁俊晖1987年出生，8岁半接触台球，13岁获得亚洲邀请赛季军，15岁拿到亚洲锦标赛冠军，他是中国最具传奇色彩的’台球神童’。2002年的釜山亚运会，丁俊晖杀出重围，获得了台球单项冠军，改写了中国在亚运会台球项目上没有金牌的历史。</p>
<p>成为明星之后，他被贴上了’台球神童’、’斯诺克天才’的标签。此时，他还只有19岁。《亚洲新闻人物》记者曾这样问丁俊晖：你对自己的台球生涯有怎样的规划？下一个目标是什么？丁俊晖的回答霸气十足：’我希望成为世界第一的时间越短越好。’</p>
<p>看到才二十出头就功成名就的丁俊晖，已过30岁的你是否感到惭愧和汗颜？！</p>
<p>也许有人说，那是因为人家小丁天生就是台球神童，我怎么能跟人家比？但你想过没有，不抓住一点一滴的时间进行刻苦训练，丁俊晖会有今天吗？在采访中，他想当’世界第一’的渴望甚至比你更迫不及待，这足以令你警醒–30岁的男人，该有紧迫感了！</p>
<p>你已经没有任何时间可供浪费了！</p>
<p>紧迫感，就像一场肆无忌惮的狂暴龙卷风袭向我们这一代人，而且，越来越多的人被卷了进来，成为一股驱动我们生活的神秘力量。中国有名的谚语’三十而立’，被人悄悄地改了一个字，变成了’三十而急’。急什么？急位子、急票子、急房子、急妻子，急资历、急学历、急智力、急能力，个中别有一番人生滋味。每天，当太阳升起来的时候，大草原上的动物们就开始奔跑了。狮子妈妈在教育自己的孩子：’孩子，你必须跑得再快一点，再快一点，你要是跑不过最慢的羚羊，你就会活活地饿死！</p>
<p>‘在另外一个场地上，羚羊妈妈也在教育自己的孩子：’孩子，你必须跑得再快一点，再快一点，如果你不能比跑得最快的狮子还要快，那你就肯定会被他们吃掉！</p>
<p>‘在这个能者上、庸者下的时代，如果你不努力，也许第二天就会下岗、失业。那时候，你如何去面对自己的亲朋好友？也许你认为自己并不比别人差，但人们看重的更是结果，无论你做得多好，能力多强，在众人眼里，只要没有功成名就你就是彻底的失败者，就是在不务正业。也许对于20几岁的人来说，他们有资格反感和逃避这种充满紧迫感的生活，他们崇尚玩乐、自由和把世界抓在自己手里。</p>
<p>但到了30岁，即使没有人逼迫你，你也应该不假思索地跳入这个充满紧迫感的漩涡。</p>
<p>30岁对男人来说，是人生的黄金季节。</p>
<p>所以，30岁的男人必须带着成功的野心和时不我待的紧迫感奋力地打拼未来。如果你现在仍将时间消耗在麻将桌上、电子游戏厅，甚至是歌舞厅里，那你简直就是自己一生的罪人，正为自己的后半生挖掘坟墓！</p>
<p>30岁，是男人一个质的飞跃30岁，是一个男孩转变为男人的重要标志，也是男人蜕变的重要时期。问鼎天下，豪情万丈，用双手打造一片自己的天下，这才是30岁男人的光荣与梦想！</p>
<p>此时，无论你是否成功，但作为30岁男人，至少应该已蜕变为一个真正的男人。希望集团是全国最大的民营企业之一，2001年实现了113亿元的产销值。刘永好先生是该集团创业者并任集团总裁。但让你绝对想不到的是，20岁之前，他竟没有穿过一双像样的鞋子，没有一件新衣服！</p>
<p>为了让孩子过年的时候能够吃上一点肉，他和三个哥哥一起被逼上了创业之路。他曾有趣地声称在16岁时希望有一双鞋，20岁希望吃上一份回锅肉，30岁创业关键时期，希望有人能借钱给自己发展。</p>
<p>在30岁的时候，他还一无所有。但第二年，在他31岁的时候，他决定与三位兄长一道，变卖手表、自行车、黑白电视等家产，筹集1000元人民币，作为创业初期的投入，从种植、养殖起步，6年时间积累了1000万元。上世纪80年代末期，刘永好转向饲料生产成立希望集团，一跃成为中国内地的第一代首富。而今他已经是48亿的身价了。</p>
<p>30岁的男同胞们，你是否仍像20岁前的刘永好那样穿着一双旧鞋子？是否仍保留着太多青春时期的举止和习惯？这时，你一定要明白幻想天上掉馅饼是根本不现实的，为了心中的梦想，我们都必须把握好这一重要机遇，磨练自我，实现一生质的飞跃！</p>
<p>《麦田里的守望者》中有这样一句话：一个不成熟男人的标志是他愿意为了事业英勇地牺牲，一个成熟男人的标志是他愿意为了事业卑贱地活着。由此可见，如何从一个满面稚气的青年变成成熟老练的30岁男人，往往是做成功人士的第一步。</p>
<p>一个成熟的人在思想、感情、行动、经济上具有较强的独立性，对别人的依赖性少；明白人生之为何物，清楚自己要做什么事，有明确的人生目标，并且有切实的行动；能够控制住自己的情绪，并且具备观察和洞察事物的能力；面对现实生活有较好的态度，对挫折、困难有相当的承受和抵抗能力。</p>
<p>所以，30岁对于男人来说，是成熟和发生质变的飞跃阶段。只有抓住这一关键的黄金时期，尽一切可能地完善自我，化蛹为蝶，蜕变为一名成功人士，才能彻底赢得光辉一生和别人的尊重！。</p>
<p>30岁，是男人创造财富的转折点。</p>
<p>在很多人看来，30岁之前成功似乎是一个遥不可及的梦想，但一些真正有野心的男人却暗暗发誓：30岁时一定要拥有自己的房子和车！</p>
<p>其实这并不是不可能的！</p>
<p>要知道，李嘉诚在30岁时其资产已经突破了千万元；盛大网络创办人陈天桥30岁时其个人资产达到了40亿！</p>
<p>前通用电气董事长兼首席执行官杰克·韦尔奇，在30岁时建议公司建造一座价值1000万美元的工厂，生产塑料制品诺瑞尔。到了指定一名经理的时候，没有人愿意为这种商业价值未能证明的产品去冒险。只有杰克渴望这个工作。当时所有的家用器具都是用金属制造的，杰克就用诺瑞尔制造出了电动罐头起子，作为可以销售的终端商品。</p>
<p>借此他让人们相信，诺瑞尔还可以有许多其他用途，包括汽车车身和计算机外壳等。由于当时的市场对塑料制品的需求不大，杰克几乎走遍了可能的大小市场，不断地让那些婴儿奶瓶、汽车、小器具用品的制造商们了解：利用塑料来制造这些东西，不但便宜、轻巧，而且更加耐用。’</p>
<p>我这一生中最兴奋、最值得纪念的时光，就是那段使塑料部门突破成长的璀璨岁月，它让我深深懂得–快速流动的水不会结冰。’杰克·韦尔奇说。对于30岁的男人来说，如何加强自己的资金积淀，拓宽收入来源是非常重要的事情。到了30岁，就应该努力工作，致力于积累财富。因为这个时期是创造财富的最佳时期，这一时期的生命如同杰克·韦尔奇所说的快速流动的水，保持着汹涌澎湃的激情和活力，几乎没有什么事情做不成功。</p>
<p>如果你在30岁时存款还屈指可数的话，一定要告诫自己在这个创造财富的转折点上，千万要好好把握，否则你不仅是位失败者，而且还要为今后的20年生活将如何度过而忧虑不堪。虽然大多数人在这段时期所拥有的财富并不是很多，但若能够及早为自己的财富增长做出有效的计划和操作，那么你的人生便会有更多的保障，也会为将来的成功打下一个坚实的基础。时钟已经敲响了30岁的大门，30岁的男人应该有更多的思考，更多的行动，紧紧抓住人生的转折创造出更多的财富，在通往财富的道路上一路狂奔。</p>
<p>30岁的男人，已经把自己打造成一把锋利的宝剑，心态和思维都已达到炉火纯青的地步，举手投足间透出一种成功人士的成熟。他们一旦出手创业，就意味着无往而不胜。</p>
<p>男人创业的黄金时间</p>
<p>创业，上天堂还是下地狱哈佛商学院杰弗里·蒂蒙斯的统计显示，创立高潜力企业的创业者平均年龄在30岁左右。进入互联网时代，看看那些满脸青春痘的家伙，他们的成功来势汹汹，更让人愈发紧迫地感觉到，创业要趁早。趁青春有效期截止以前赶快行动，否则你将被打上’过期’的烙印！</p>
<p>1998年21岁的丁恒立大学毕业后，就职于北京某大型IT企业。来自云南的他，从销售干起，很快做到了市场推广部的部门经理。这一职位的年薪超过10万元，而且北京至云南的来回机票可报销，还有年终奖。但’不安分’的他还是于2001年辞职，与合作伙伴共同在上海开办了一家存储系统有限公司，他们希望研制中国第一款自主知识产权的存储服务器，这在当时仅有世界500强才能做到。</p>
<p>在做企业时，上海某集团公司看中他，愿出50万元年薪来聘用他。就在这时，他又做了更加’出格’的事：不但拒聘，还烧掉了自己的大学毕业证、学位证，以破釜沉舟，背水一战。丁恒立回忆，他当时铁了心不再打工，烧证书可防止大公司出更高年薪的’诱惑’。结果，丁恒立在上海创办的公司还是失败了。</p>
<p>不过，也正是由于这次的创业，使他的管理和各项能力都得到了很大的提高，为他今后的创业之路打下了坚实的基础。后来，他又回到了云南与伙伴办企业。而今，已经身为云南高阳科技开发有限公司总经理的丁恒立正踌躇满志地准备再次大干一场，他说：’我的目标很明确：就是争取进入《赢在中国》5强之列。拿到创业基金后，可加速实现二次创业。’</p>
<p>当记者问道：’现在是否后悔放弃在上海的50万元年薪的工作？’丁恒立肯定地回答：’不后悔，因为我不但在经济上有更大回报，而且实现了第一次成功创业。’</p>
<p>毋庸置疑，30岁绝对是男人创业的巅峰时期，此时积累了创业所需的金钱、历练和管理能力。当这些资本集于一身的时候，也就是创业的最佳时机。30岁已经不再是青春逼人的年龄。真正有危机感的男人总会长远考虑现在的工作是否是自己一生的事业，在自己被迫退休的时候，是否还有能力去承担繁重的家庭经济负担？</p>
<p>所以许多30岁的男人，开始按捺不住内心的创业冲动，为此他们不惜放弃高薪高职，勇敢地孤注一掷。不过，30岁的男人创业同样也存在一些弱点。最大的弱势就是容易躁进，因为心太野、太冲而经常眼高手低，不服输的个性也容易误判市场情势。</p>
<p>而创业需要兢兢业业、勤勤恳恳以及不断地去学习新的东西，进行各种调查、分析、研究市场和挖掘创业资源；需要不断地克服一个又一个困难和经营中的问题，总结失败的教训和成功经验，扩充自己的实力和规模……到底是选择眼前比较舒服的工作，还是大胆地跳出来自己去创业好呢？毕竟，创业的前景虽然美好，但终究还是一个不可预测的未知数！</p>
<p>创业成功虽然会带来巨大的收益，但失败也同样会导致毁灭性的打击。</p>
<p>作为一个创业者，必须先清楚地了解自己，彻底弄清楚自己是否适合创业，自己是否已经做好了充分的准备，然后再做进一步的决定。30岁的男人，如打磨了十年的宝剑提起创业，30岁男人最头疼两个问题：项目和资金。但为什么有了项目和资金后，很多人仍然创业失败呢？有这样一句话：’没有不赚钱的行业，只有在行业里赚不到钱的人。’</p>
<p>要知道，创业者本人的能力如何往往决定一个创业项目的成败。</p>
<p>只有创业者的能力超群，创业项目成功的几率才大。有一种昆虫叫做帝王蛾，双翼长几十厘米，飞翔本领无可匹敌。是谁给了帝王蛾如此强健的翅膀呢？不是别人，正是它自己用娇嫩的身驱拼尽全力破茧而出，冲出狭小茧洞，才拥有了飞翔的快乐。</p>
<p>在这一涅磐的过程中，有许多幼虫力竭身亡，成了飞翔的牺牲品。有人见之，顿生怜悯之心，拿来剪刀，剪大洞口，让幼虫轻易地从茧洞钻出来。可是，这种好心反而弄巧成拙，并没有让这样的蛾子成为帝王，因为它们只能拖着累赘的双翅在地上笨拙地爬行。原来，帝王蛾在冲撞茧口用力挤压时，血液才能顺利送到双翼的组织中，从而使帝王蛾双翅强健有力、振翅高飞，否则，帝王蛾永远无法锤炼出有力的双翼。记住，能拯救你的只能是自己！</p>
<p>30岁的男人也正如帝王蛾一样，不要等待任何施舍和怜悯，只有把自己单薄的身躯锤炼成一把锋利的宝剑，才能破茧而出。剪刀的拯救，只会让你的一生在地上爬行，像一只苍蝇那样卑微和一事无成！</p>
<p>只有在不断的冲撞和锤击下，你的’双翼’才能强健有力起来。事实上，许多30岁的男人已经把自己打造成一把锋利的宝剑了，他们的心态和思维都已达炉火纯青地步，举手投足都透出一股成功人士的成熟。这主要是由于他们不断沉淀自己的结果。毫无疑问，他们一旦出手创业，就意味着无往而不胜。</p>
<p>此时正是他们既有经验又有魄力的时候，他们很了解自己的能力，他们不会像20几岁的人那样茫然无措。他们的创新思维最为活跃、精力最充沛、创造欲最旺盛。特别是在网络软件、广告、策划、咨询、证券、投资等知识密集型行业，经验已经不再是要命问题，重要的是30岁男人的那种’创新精神’。</p>
<p>就像生于1971年的丁磊，26岁创办网易，32岁成为中国首富；更年轻的陈天桥，21岁就成为上海某集团分公司的副总经理，26岁创办盛大，32岁身家过百亿，取代丁磊成为新一代中国首富。这些男人无一例外，都在创业前把自己打造得锋利无比，以致于出手无敌，所向披靡。</p>
<p>大千世界、芸芸众生，何人没有目标？哪个没有梦想？在这个年龄段，为了实现自己的梦想，大部分的男人都会选择创业。然而，创业道路上的辛酸与痛苦却不是每个人都能承受和坦然面对的。平凡终究掩藏不了出类拔萃，要想成为顶尖人物，就只有不断地磨练自己，把自己锤炼成锋利无比的宝剑！</p>
<p>30岁，掘取第一桶金的最佳时期</p>
<p>大凡白手起家的富翁，都有一段发迹史。其中最重要的阶段，是获取第一桶金。然后，再靠自己的努力或者运气，很快就令自己的财富以几何级数暴涨，就这样一个富翁诞生了。</p>
<p>男人30上下正是掘取第一桶金的最佳时期。在25～35岁之间，是一个人创新思维最为活跃、精力最充沛，脑筋也最好使的阶段，其创造欲望也是最为旺盛的时期。那么，作为打算创业者，又该如何去掘取第一桶金呢？</p>
<p>1.在自己熟悉的行业寻找由于自己对这个行业比较熟悉，因此会避免因陌生而浪费时间。</p>
<p>比尔·盖茨在创业之初便是在自己最熟悉的行业中寻找并获得成功的，至今微软在成为巨无霸的同时，比尔·盖茨也从来没有做过与电脑无关的生意。</p>
<p>2.把勤奋作为挖取第一桶金的工具。</p>
<p>在最初的阶段，资金短缺、规模过小和没有知名度以及受到大公司排挤是非常常见的情况。所以这时候如果不勤奋的话，将很难获得成功。曾宪梓由最初推小车在商场和大街小巷叫卖领带，到最终使自己的金利来领带步入了世界名牌的行列，其成就和他的勤奋是密不可分的。</p>
<p>3.要善于把握时机，同时具有冒险精神。</p>
<p>对于十拿九稳的事情，总是那些回报最少的事情，所以创业者要敢于冒险。一件事情，你觉得没把握，别人也同样没把握，但你做了，就有了成功的可能，如果不做，那只能够看着别人成功。所以，风险与收益向来都是成正比的，创业是这样，生活也是如此。一个一味求得安稳的人无论如何也成就不了大事。</p>
<p>4.学一门手艺人们都知道，腰缠万贯，不如一技在身。</p>
<p>就凭这身薄技，最低目标是能养家糊口，最高目标是能发家致富而创下万贯家财。陈逸飞刚到美国，最先是给博物馆修画，报酬是1小时3美金。后来，由于画技出众而进入画廊，当听到有人出价每张画3000美金时，陈逸飞说：’我一下觉得中了头彩，仿佛天上掉了个馅饼下来。’也正是由于他的手艺，才造就了他以后的产业。</p>
<p>5.他山之石，可以攻玉。</p>
<p>人无爪牙之利，筋骨之强，却能与虎谋皮，何也？善假于物也。由此可见，善于利用各种条件，学会如何借鸡生蛋，对创业者来说是多么重要。创办四通利方公司的王志东在1993年向四通融资500万元港币，后来，四通利方又与华渊网合并，易名新浪。1999年，在国际上融资2500万美元，后来，又向戴尔电脑和软银等融资6000万美元。2000年，纳斯达克上市，从而打开了一片新的天地。6?自己动手去做居里夫人说：’弱者等待时机，强者创造时机！</p>
<p>‘有个成功人士也说过同样的话：’有条件要上，没条件也要创造条件上。’</p>
<p>这说明攫取第一桶金的机会不是别人提供，大多是自己亲手创造的。吉利汽车集团的董事长李书福的第一桶金是开照相馆掘得的。有一次，由于他买不起1000多元的反光罩，就干脆自己动手做了一个，结果只花了2元钱就做成了。而且，连照相机上装胶片的东西，都是自己做的。</p>
<p>就这样，他逐渐改造冰箱、摩托车、汽车等。在他眼里，’汽车只不过有4个轮子，1个方向盘，1个发动机，1个车壳，里面还有两只沙发而已’。创业是一条不归路，对30岁男人来说，如何掘到第一桶金非常关键。立志在最佳年龄阶段掘取’第一桶金’的创业者要想成功，就必须要有强烈的成功欲望，就像我们有强烈的求生欲望一样；同时还必须有胆量和决心，敢做’第一个吃螃蟹’的人！</p>
<p>谨防成为死于温水的青蛙美国一所大学做过一项实验，科研人员将一只青蛙猛地丢进装有沸水的铁锅中，青蛙受到意外的强烈刺激，作出了灵敏的反应，奋力一跳，跃出锅外，自我拯救了生命。而后，科研人员又将这只青蛙放进装满凉水的铁锅，然后在锅下逐渐加温，青蛙毫无觉察地在温水里悠然自得，直到它感到水烫无法忍受时，再想跃出水面却已动弹不得，枉送了性命。’</p>
<p>青蛙未死于沸水而灭顶于温水’的结局，很是耐人寻味。青蛙第一次能死里逃生，是因为它意识到危险，尽其所能进行了抗争；第二次葬身锅底，则是由于它思想懈怠，在不知不觉中失去求生弹跳的能力。若是锅中之蛙能时刻保持警醒，在水温刚热之时迅速跃出也为时不晚，不至于发展到难以自拔被煮死。</p>
<p>拥有硕士学历的小王在一家高科技公司担任技术应用经理，他在公司已任职7年，是公司里的一个小头目，薪水待遇也还不错。看上去，小王的工作状况不错，然而，他却终日焦躁不安，总想换个环境，觉得自己实在没法在这里待下去了，究竟是为什么呢？</p>
<p>原来，小王这个技术应用经理只是个头衔，也就带着一两个助手，每天要做的事情也就是等待客户的电话，随时待命为客户的机器更换损坏的电路板。而且，这个工作他已经做了5年了，大约在工作3年以后，他已经感觉自己根本就学不到新东西了，不但没有进步和提高，工作内容全部是在重复！</p>
<p>小王意识到这样下去不行，于是他也投递过一些简历，但像他这样已经工作7年的人，在找工作时还真是’高不成低不就’。对于下家公司的工作职位也好，薪水待遇也好，他都有比较高的要求。另外，他对自己的工作能力也没有足够的信心，害怕风险、安于现状的他担心自己不能胜任，不敢轻易跳槽。</p>
<p>就这样一拖几年，跳槽的想法一直有，可他担心离职后找不到这样薪水尚可又游刃有余的工作，有时又遗憾自己比较中意的公司没有主动向他抛出橄榄枝，觉得不如再等等看。这样一来，小王寻寻觅觅而最终是一无所获。面对一份外人看来不错的工作，小王自己却痛苦万分。他意识到：继续这样下去，自己就像’温水中的青蛙’一样最终只能留在原来的公司等待着’安乐死’。因此，焦虑无时无刻不在折磨着小王。</p>
<p>也许你是正处于春风得意的青蛙王子，也许你是正处于中层领导的青蛙大臣，也许你只是一只初出茅庐的青蛙，对未来充满憧憬，梦想着光明的未来。但无论处于何种职位，这个温水中青蛙的故事都足以令你警醒–因为你稍不留意，就可能会变成温水中的’死蛙’！</p>
<p>处于王子地位，当你率领手下获得巨大成功时，是不是打算庆祝？处于大臣地位，工作能力无比的熟练，而且各项收入都非常不错，这时候，你是否打算休息一下？对于小青蛙来说，你终于进入了梦想中的的公司，是否就前程无忧了？</p>
<p>在草原上蚊群遮天蔽日，为了抵御蚊子的攻击，蒙古战马常常会逆风狂奔，用最快的速度将恶毒的蚊群远远抛在身后。而我们身上的惰性，有时候就像蚊子一样，纠缠着我们，不断地吸食着我们的鲜血。不过，它又同蚊子有些区别，因为它不声不响，不痛不痒！甚至会让人感到安逸舒适。</p>
<p>每个人都是有惰性的，当你有了这些想法之后，便会在无意识中放松对自己的要求，这时候，你便在不知不觉中滑入到危险的温水中。当你正闭目享受温水中舒适的’半身浴’时，危机像魔鬼一样临近了！</p>
<p>当温水被缓慢加热，火势越来越旺，你离穷困潦倒的结局也就不远了！</p>]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>时间轮算法是如何实现的？</title>
    <url>/2021/01/03/how-is-the-time-wheel-algorithm-implemented.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源  <a href="https://www.zcool.com.cn/work/ZNDg3OTA5NjA=.htmlPS">https://www.zcool.com.cn/work/ZNDg3OTA5NjA=.htmlPS</a><br>未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<blockquote>
<p>转载来源：<a href="https://www.cnblogs.com/luozhiyun/p/12075326.html">https://www.cnblogs.com/luozhiyun/p/12075326.html</a> 作者：<a href="https://www.cnblogs.com/luozhiyun/">luozhiyun</a><br>本文有修改</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果让你用 Java 代码写一个定时调度任务，大多数人第一时间可能会想到用 quartz 去实现，如果我们用纯生的 Java 代码怎么实现呢？我们可以使用 TimerTask、Timer 去实现这么一个功能，或者使用 ScheduledExecutorService 通过调度线程池去完成。使用定时任务有很多场景，比如订单定时关闭，定时推送广告，一定时间后默认好评等。拿订单超时关闭来说，最简单的实现方式就是为每个订单创建一个定时任务。</p>
<h3 id="时间轮用来解决什么问题？"><a href="#时间轮用来解决什么问题？" class="headerlink" title="时间轮用来解决什么问题？"></a>时间轮用来解决什么问题？</h3><p>如果一个系统中存在着大量的调度任务，而大量的调度任务如果每一个都使用自己的调度器来管理任务的生命周期的话，浪费 CPU 的资源并且很低效。</p>
<p>时间轮是一种高效来利用线程资源来进行批量化调度的一种调度模型。把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理（manager），触发（trigger）以及运行（runnable）。能够高效的管理各种延时任务，周期任务，通知任务等等。</p>
<p>不过，时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太适合。因为时间轮算法的精度取决于，时间段“指针”单元的最小粒度大小，比如时间轮的格子是一秒跳一次，那么调度精度小于一秒的任务就无法被时间轮所调度。</p>
<h3 id="时间轮结构"><a href="#时间轮结构" class="headerlink" title="时间轮结构"></a>时间轮结构</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmal4o6n7ij30pj0c0abi.jpg" alt="时间轮结构"></p>
<p>如图，JRaft中时间轮（HashedWheelTimer）是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（HashedWheelBucket），HashedWheelBucket是一个环形的双向链表，链表中的每一项表示的都是定时任务项（HashedWheelTimeout），其中封装了真正的定时任务（TimerTask）。</p>
<p>时间轮由多个时间格组成，每个时间格代表当前时间轮的基本时间跨度（tickDuration）。时间轮的时间格个数是固定的，可用 wheel.length 来表示。</p>
<p>时间轮还有一个表盘指针（tick），用来表示时间轮当前指针跳动的次数，可以用tickDuration * (tick + 1)来表示下一次到期的任务，需要处理此时间格所对应的 HashedWheelBucket 中的所有任务。</p>
<h3 id="时间轮运行逻辑"><a href="#时间轮运行逻辑" class="headerlink" title="时间轮运行逻辑"></a>时间轮运行逻辑</h3><p>时间轮在启动的时候会记录一下当前启动的时间赋值给startTime。时间轮在添加任务的时候首先会计算延迟时间（deadline），比如一个任务的延迟时间为24ms，那么会将当前的时间（currentTime）+24ms-时间轮启动时的时间（startTime）。然后将任务封装成HashedWheelTimeout加入到timeouts队列中，作为缓存。</p>
<p>时间轮在运行的时候会将timeouts中缓存的HashedWheelTimeout任务取10万个出来进行遍历。<br>然后需要计算出几个参数值：</p>
<ol>
<li>HashedWheelTimeout的总共延迟的次数：将每个任务的延迟时间（deadline）&#x2F;tickDuration 计算出tick需要总共跳动的次数；</li>
<li>计算时间轮round次数：根据计算的需要走的（总次数- 当前tick数量）&#x2F; 时间格个数（wheel.length）。比如tickDuration为1ms，时间格个数为20个，那么时间轮走一圈需要20ms，那么添加进一个延时为24ms的数据，如果当前的tick为0，那么计算出的轮数为1，指针没运行一圈就会将round取出来减一，所以需要转动到第二轮之后才可以将轮数round减为0之后才会运行</li>
<li>计算出该任务需要放置到时间轮（wheel）的槽位，然后加入到槽位链表最后</li>
</ol>
<p>将timeouts中的数据放置到时间轮wheel中之后，计算出当前时针走到的槽位的位置，并取出槽位中的链表数据，将deadline和当前的时间做对比，运行过期的数据。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码以 netty 中的 HashedWheelTimer 为例。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new timer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory        a &#123;<span class="doctag">@link</span> ThreadFactory&#125; that creates a</span></span><br><span class="line"><span class="comment"> *                             background &#123;<span class="doctag">@link</span> Thread&#125; which is dedicated to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> TimerTask&#125; execution.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tickDuration         the duration between tick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit                 the time unit of the &#123;<span class="doctag">@code</span> tickDuration&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticksPerWheel        the size of the wheel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leakDetection        &#123;<span class="doctag">@code</span> true&#125; if leak detection should be enabled always,</span></span><br><span class="line"><span class="comment"> *                             if false it will only be enabled if the worker thread is not</span></span><br><span class="line"><span class="comment"> *                             a daemon thread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  maxPendingTimeouts  The maximum number of pending timeouts after which call to</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@code</span> newTimeout&#125; will result in</span></span><br><span class="line"><span class="comment"> *                             &#123;<span class="doctag">@link</span> java.util.concurrent.RejectedExecutionException&#125;</span></span><br><span class="line"><span class="comment"> *                             being thrown. No maximum pending timeouts limit is assumed if</span></span><br><span class="line"><span class="comment"> *                             this value is 0 or negative.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException     if either of &#123;<span class="doctag">@code</span> threadFactory&#125; and &#123;<span class="doctag">@code</span> unit&#125; is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if either of &#123;<span class="doctag">@code</span> tickDuration&#125; and &#123;<span class="doctag">@code</span> ticksPerWheel&#125; is &amp;lt;= 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashedWheelTimer</span><span class="params">(</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> tickDuration, TimeUnit unit, <span class="type">int</span> ticksPerWheel, <span class="type">boolean</span> leakDetection,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> maxPendingTimeouts)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ObjectUtil.checkNotNull(threadFactory, <span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">&quot;unit&quot;</span>);</span><br><span class="line">    ObjectUtil.checkPositive(tickDuration, <span class="string">&quot;tickDuration&quot;</span>);</span><br><span class="line">    ObjectUtil.checkPositive(ticksPerWheel, <span class="string">&quot;ticksPerWheel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize ticksPerWheel to power of two and initialize the wheel.</span></span><br><span class="line">    <span class="comment">// 创建一个HashedWheelBucket数组 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></span><br><span class="line">    <span class="comment">// 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.</span></span><br><span class="line">  	<span class="comment">// 但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：</span></span><br><span class="line">    <span class="comment">// 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length</span></span><br><span class="line">    <span class="comment">// java中的HashMap在进行hash之后，进行index的hash寻址寻址的算法也是和这个一样的</span></span><br><span class="line">    mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert tickDuration to nanos.</span></span><br><span class="line">    <span class="comment">//tickDuration传入是1的话，这里会转换成1000000</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent overflow.</span></span><br><span class="line">    <span class="comment">// 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(</span><br><span class="line">                <span class="string">&quot;tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d&quot;</span>,</span><br><span class="line">                tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms.&quot;</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">        <span class="built_in">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tickDuration = duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将worker包装成thread</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">//如果HashedWheelTimer实例太多，那么就会打印一个error日志</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">        WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        reportTooManyInstances();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个构造器中有几个细节需要注意：</p>
<ol>
<li>调用createWheel方法创建的wheel数组一定是2次方数，比如传入的ticksPerWheel是6，那么初始化的wheel长度一定是8。这样做是为了让mask &amp; tick 来计算出槽位</li>
<li>tickDuration用的是纳秒</li>
<li>在构造里面并不会里面启动时间轮，而是要等到有第一个任务加入到时间轮的时候才启动。在构造器里面会将工作线程worker封装成workerThread</li>
</ol>
<h3 id="放入任务到时间轮中"><a href="#放入任务到时间轮中" class="headerlink" title="放入任务到时间轮中"></a>放入任务到时间轮中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Timeout <span class="title function_">newTimeout</span><span class="params">(TimerTask task, <span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">&quot;unit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">pendingTimeoutsCount</span> <span class="operator">=</span> pendingTimeouts.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">        pendingTimeouts.decrementAndGet();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Number of pending timeouts (&quot;</span></span><br><span class="line">            + pendingTimeoutsCount + <span class="string">&quot;) is greater than or equal to maximum allowed pending &quot;</span></span><br><span class="line">            + <span class="string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果时间轮没有启动，则启动</span></span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">    <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Guard against overflow.</span></span><br><span class="line">    <span class="comment">//在delay为正数的情况下，deadline是不可能为负数</span></span><br><span class="line">		<span class="comment">//如果为负数，那么说明超过了long的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        deadline = Long.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，</span></span><br><span class="line">		<span class="comment">// 会从队列里取出最多100000个任务加入到指定的格子中</span></span><br><span class="line">    <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimeout</span>(<span class="built_in">this</span>, task, deadline);</span><br><span class="line">    <span class="comment">//Worker会去处理timeouts队列里面的数据</span></span><br><span class="line">    timeouts.add(timeout);</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>如果时间轮没有启动，那么就调用start方法启动时间轮，启动时间轮之后会为startTime设置为当前时间</li>
<li>计算延迟时间deadline</li>
<li>将task任务封装到HashedWheelTimeout中，然后添加到timeouts队列中进行缓存</li>
</ol>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startTimeInitialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//workerState一开始的时候是0（WORKER_STATE_INIT），然后才会设置为1（WORKER_STATE_STARTED）</span></span><br><span class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">            <span class="comment">//使用cas来获取启动调度的权力，只有竞争到的线程允许来进行实例启动</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                <span class="comment">//如果成功设置了workerState，那么就调用workerThread线程</span></span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;cannot be started once stopped&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid WorkerState&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until the startTime is initialized by the worker.</span></span><br><span class="line">   	<span class="comment">// 等待worker线程初始化时间轮的启动时间</span></span><br><span class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里使用countDownLauch来确保调度的线程已经被启动</span></span><br><span class="line">            startTimeInitialized.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">            <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>start方法会根据当前的workerState状态来启动时间轮。并且用了startTimeInitialized来控制线程的运行，如果workerThread没有启动起来，那么newTimeout方法会一直阻塞在运行start方法中。如果不阻塞，newTimeout方法会获取不到startTime。</p>
<h3 id="启动时间轮"><a href="#启动时间轮" class="headerlink" title="启动时间轮"></a>启动时间轮</h3><p>时间轮的启动在HashedWheelTimer的内部类Worker中。调用workerThread#start方法会调用Worker的run方法启动时间轮。</p>
<p>下面我们看时间轮启动做了什么，下面的分析不考虑任务被取消的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the startTime.</span></span><br><span class="line">    startTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span></span><br><span class="line">        startTime = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">    <span class="comment">//HashedWheelTimer的start方法会继续往下运行</span></span><br><span class="line">    startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//返回的是当前的nanoTime- startTime</span></span><br><span class="line">				<span class="comment">//也就是返回的是 每 tick 一次的时间间隔</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> waitForNextTick();</span><br><span class="line">        <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//算出时间轮的槽位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (<span class="type">int</span>) (tick &amp; mask);</span><br><span class="line">            <span class="comment">//移除cancelledTimeouts中的bucket</span></span><br><span class="line">    				<span class="comment">// 从bucket中移除timeout</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">            <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[idx];</span><br><span class="line">            <span class="comment">// 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中</span></span><br><span class="line">            transferTimeoutsToBuckets();</span><br><span class="line">            bucket.expireTimeouts(deadline);</span><br><span class="line">            tick++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 校验如果workerState是started状态，那么就一直循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></span><br><span class="line">    <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">        bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有没有被处理的timeout，那么加入到unprocessedTimeouts对列中</span></span><br><span class="line">        <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">            unprocessedTimeouts.add(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理被取消的任务</span></span><br><span class="line">    processCancelledTasks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间轮运行的时候首先会记录一下启动时间（startTime），然后调用startTimeInitialized释放外层的等待线程；</li>
<li>进入dowhile循环，调用waitForNextTick睡眠等待到下一次的tick指针的跳动，并返回当前时间减去startTime作为deadline</li>
<li>由于mask&#x3D; wheel.length -1 ，wheel是2的次方数，所以可以直接用tick &amp; mask 计算出此次在wheel中的槽位</li>
<li>调用processCancelledTasks将cancelledTimeouts队列中的任务取出来，并将当前的任务从时间轮中移除</li>
<li>调用transferTimeoutsToBuckets方法将timeouts队列中缓存的数据取出加入到时间轮中</li>
<li>运行目前指针指向的槽位中的bucket链表数据</li>
</ol>
<h3 id="时间轮指针跳动"><a href="#时间轮指针跳动" class="headerlink" title="时间轮指针跳动"></a>时间轮指针跳动</h3><p><strong>waitForNextTick</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">waitForNextTick</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//tickDuration这里是100000</span></span><br><span class="line">	<span class="comment">//tick表示总tick数</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	    <span class="comment">// 计算需要sleep的时间, 之所以加999999后再除10000000,前面是1所以这里需要减去1，</span></span><br><span class="line">				<span class="comment">// 才能计算准确，还有通过这里可以看到 其实线程是以睡眠一定的时候再来执行下一个ticket的任务的，</span></span><br><span class="line">				<span class="comment">//这样如果ticket的间隔设置的太小的话，系统会频繁的睡眠然后启动，</span></span><br><span class="line">				<span class="comment">//其实感觉影响部分的性能，所以为了更好的利用系统资源步长可以稍微设置大点</span></span><br><span class="line">	    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.nanoTime() - startTime;</span><br><span class="line">	    <span class="type">long</span> <span class="variable">sleepTimeMs</span> <span class="operator">=</span> (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line">	  </span><br><span class="line">	    <span class="comment">//sleepTimeMs小于零表示走到了下一个时间轮位置</span></span><br><span class="line">	    <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">	            <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            <span class="keyword">return</span> currentTime;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">	    <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">	    <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">	    <span class="comment">//</span></span><br><span class="line">	    <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">	    <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">	        sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">	        <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">	            sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        Thread.sleep(sleepTimeMs);</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">	            <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以想象一下在时钟的秒钟上面秒与秒之间的时间是需要等待的，那么waitForNextTick这个方法就是根据当前的时间计算出跳动到下个时间的间隔时间，并进行sleep操作，然后返回当前时间距离时间轮启动时间的时间段。</p>
<h3 id="转移任务到时间轮中"><a href="#转移任务到时间轮中" class="headerlink" title="转移任务到时间轮中"></a>转移任务到时间轮中</h3><p>在调用时间轮的方法加入任务的时候并没有直接加入到时间轮中，而是缓存到了timeouts队列中，所以在运行的时候需要将timeouts队列中的任务转移到时间轮数据的链表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferTimeoutsToBuckets</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></span><br><span class="line">    <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">    <span class="comment">// 每次tick只处理10w个任务，以免阻塞worker线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">        <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// all processed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经被取消了；</span></span><br><span class="line">        <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">            <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//calculated = tick 次数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line">        <span class="comment">// 计算剩余的轮数, 只有 timer 走够轮数, 并且到达了 task 所在的 slot, task 才会过期</span></span><br><span class="line">        timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line">			<span class="comment">//如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line">        <span class="comment">// 算出任务应该插入的 wheel 的 slot, slotIndex = tick 次数 &amp; mask, mask = wheel.length - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">        <span class="comment">//将timeout加入到bucket链表中</span></span><br><span class="line">        bucket.addTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个转移方法中，写死了一个循环，每次都只转移10万个任务。</p>
<p>然后根据HashedWheelTimeout的deadline延迟时间计算出时间轮需要运行多少次才能运行当前的任务，如果当前的任务延迟时间大于时间轮跑一圈所需要的时间，那么就计算需要跑几圈才能到这个任务运行。</p>
<p>最后计算出该任务在时间轮中的槽位，添加到时间轮的链表中。</p>
<h3 id="运行时间轮中的任务"><a href="#运行时间轮中的任务" class="headerlink" title="运行时间轮中的任务"></a>运行时间轮中的任务</h3><p>当指针跳到时间轮的槽位的时间，会将槽位的HashedWheelBucket取出来，然后遍历链表，运行其中到期的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法</span></span><br><span class="line"><span class="comment">//根据deadline和remainingRounds判断任务是否过期</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expireTimeouts</span><span class="params">(<span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">      <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// process all timeouts</span></span><br><span class="line">		<span class="comment">//遍历格子中的所有定时任务</span></span><br><span class="line">      <span class="keyword">while</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">HashedWheelTimeout</span> <span class="variable">next</span> <span class="operator">=</span> timeout.next;</span><br><span class="line">          <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//从bucket链表中移除当前timeout，并返回链表中下一个timeout</span></span><br><span class="line">              next = remove(timeout);</span><br><span class="line">              <span class="comment">//如果timeout的时间小于当前的时间，那么就调用expire执行task</span></span><br><span class="line">              <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                  timeout.expire();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                  <span class="comment">//不可能发生的情况，就是说round已经为0了，deadline却&gt;当前槽的deadline</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(</span><br><span class="line">                          <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">              next = remove(timeout);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//因为当前的槽位已经过了，说明已经走了一圈了，把轮数减一</span></span><br><span class="line">              timeout.remainingRounds --;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//把指针放置到下一个timeout</span></span><br><span class="line">          timeout = next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>HashedWheelBucket是一个链表，所以我们需要从head节点往下进行遍历。如果链表没有遍历到链表尾部那么就继续往下遍历。</p>
<p>获取的timeout节点节点，如果剩余轮数remainingRounds大于0，那么就说明要到下一圈才能运行，所以将剩余轮数减一；</p>
<p>如果当前剩余轮数小于等于零了，那么就将当前节点从bucket链表中移除，并判断一下当前的时间是否大于timeout的延迟时间，如果是则调用timeout的expire执行任务。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>finalize() ，都知道这个方法是 Object 的方法，开发这么久也没有使用过，也很少看到他人使用，在这里终于看到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// This object is going to be GCed and it is assumed the ship has sailed to do a proper shutdown. If</span></span><br><span class="line">        <span class="comment">// we have not yet shutdown then we want to make sure we decrement the active instance count.</span></span><br><span class="line">        <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="built_in">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用说明再看一遍注释</p>
<blockquote>
<p>Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup.<br>The general contract of finalize is that it is invoked if and when the Java™ virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input&#x2F;output connection might perform explicit I&#x2F;O transactions to break the connection before the object is permanently discarded.<br>The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition.<br>The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.<br>After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded.<br>The finalize method is never invoked more than once by a Java virtual machine for any given object.<br>Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.<br>Throws:<br>Throwable – the Exception raised by this method<br>See Also:<br>ref.WeakReference, ref.PhantomReference</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalizeTest</span> <span class="variable">finalizeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizeTest</span>();</span><br><span class="line">        finalizeTest = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;FinalizeTest&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(finalizeTest);</span><br><span class="line">        weakReference.clear();</span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;被回收处理了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意的是，并不是每次执行都能输出 被回收处理了… ，这是因为我们在调用 System.gc(); 方法时 JVM 不一定会垃圾回收，只是建议 JVM，嘿，哥们，你可以垃圾回收试试。</p>]]></content>
      <categories>
        <category>Java</category>
        <category>时间轮</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>时间轮</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程执行1+2+3+...+n</title>
    <url>/2020/12/26/MultiThread-execution-1+2+...n.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源  <a href="https://www.zcool.com.cn/work/ZNDgwMzg3MzI=.html">https://www.zcool.com.cn/work/ZNDgwMzg3MzI=.html</a> PS：未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<p>如果不涉及操作共享资源，那么每个线程操作执行的结果都是一样，一旦涉及多线程操作就可能带来线程安全问题，线程安全问题的根本原因无非有三点，可见性、原子性、有序性。</p>
<p>一个线程执行 1+2+3+…+n 很容易实现，每个方法都有他自己的栈帧，JVM层面就保证了线程私有，如果多个线程执行这么一个方法，如何保证结果依然是对的呢？</p>
<p>多线程操作，保证线程安全，无非是通过加锁的方式去保证，这里使用轻量级锁 Lock 去实现。</p>
<p>先看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多线程执行 1+2+3+..+n = ((n+1))/2 * n</span><br><span class="line"> *</span><br><span class="line"> * @author 0x4096.peng@gmail.com</span><br><span class="line"> * @date 2020/12/26</span><br><span class="line"> */</span><br><span class="line">public class MultiThreadAdd &#123;</span><br><span class="line"></span><br><span class="line">    private final int max = 100;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private int res;</span><br><span class="line">    private int count = 1;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        while (count &lt;= max) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                /* 让线程睡一会 有足够的时间来抢 */</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    /**/</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /* 上锁 多个线程只有一个进来获取到锁 其他线程会进入休眠状态（源码解释） */</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                /* 线程释放锁后 之前进入的线程获取到 count 值被修改 此时可能大于 max 再次 check */</span><br><span class="line">                if (count &gt; max) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.err.println(Thread.currentThread().getName() + &quot;, res=&quot; + (res += count) + &quot;, count=&quot; + count++);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                /* 释放锁 */</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MultiThreadAdd multiThreadAdd = new MultiThreadAdd();</span><br><span class="line"></span><br><span class="line">        /* 被执行的次数 */</span><br><span class="line">        int threadCount = 15;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(threadCount);</span><br><span class="line">        for (int i = 1; i &lt;= threadCount; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                multiThreadAdd.add();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, &quot;Thread-&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.err.println(&quot;\n&quot; + multiThreadAdd.res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码开启了 15 个线程去执行，每个线程都有执行的机会，操作下来结果是 5050 。比较有意思的代码是这块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 上锁 多个线程只有一个进来获取到锁 其他线程会进入休眠状态（源码解释） */</span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">/* 线程释放锁后 之前进入的线程获取到 count 值被修改 此时可能大于 max 再次 check */</span><br><span class="line">if (count &gt; max) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始写的代码没有加 count &gt; max 这个判断，运行了几次执行结果都是对的，当我多跑了几次出现了 bug ，结果大于 5050 ，觉得很奇怪。去看 Lock 的源码才发现，一旦线程没有拿到锁实际上会进入休眠，而不是像 synchronized 重量级锁一样让线程阻塞，相比 synchronized ，Lock 的特点很明显，1、不阻塞线程 2、可超时，相比不那么容易发生死锁 。所以当线程被唤醒时，这时的 count 的值被 +1 了，这里需要 double check 一下。</p>
<p>如果你认真看代码会发现， count 没有用 volatile 修饰，但是这里依然保证了可见性，具体是怎么实现的呢？我们知道 Java 中的可见性是通过 Happens-Before 规则保证的，除了 volatile 可以保证可见性外，synchronize 和 final 也可以保证可见性。那么 Lock 是如何保证可见性的呢？其实它是利用了 volatile 相关的 Happens-Before 规则。Java SDK 里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写 state 的值；解锁的时候，也会读写 state 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><span class="line"></span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure>



<p>留个有趣的问题：线程安全的中的原子性和数据库中的原子性是一个意思吗？线程安全中的原子性是怎么导致的呢？</p>]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>工作感悟</title>
    <url>/2020/08/01/work-thinking.html</url>
    <content><![CDATA[<h3 id="工作目的"><a href="#工作目的" class="headerlink" title="工作目的"></a>工作目的</h3><p>只有钱和部分人</p>
<h3 id="工作心态"><a href="#工作心态" class="headerlink" title="工作心态"></a>工作心态</h3><ul>
<li>和喜欢的人，做人人喜欢的产品</li>
<li>包容，放下，顺其自然，快乐工作</li>
</ul>
<h3 id="工作职责"><a href="#工作职责" class="headerlink" title="工作职责"></a>工作职责</h3><ul>
<li>业务贡献：通过一定手段，给业务带来增长</li>
<li>技术贡献：通过研发xxx工具，给大家带来xx提效</li>
<li>团队贡献：团队分享等</li>
<li>技术风险：通过一定手段，降低了团队故障次数</li>
</ul>
<h3 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h3><ul>
<li>使命驱动，做正确的事情</li>
<li>真实不装，言行一致，诚信正直</li>
<li>尊重包容，心中有人</li>
<li>有利他精神，乐于成就他人</li>
<li>谦虚自省，心态开放，拥抱变化</li>
<li>有好奇心和想象力，乐于学习</li>
<li>愿意花时间走近并真正了解他人</li>
<li>客观公正，不仅仅凭主观感觉</li>
<li>在团队中营造开放简单、彼此信任的氛围，激发群体智慧</li>
<li>有感召力和影响力，协同不同人群奔向共同目标</li>
<li>知人善用，用人所长</li>
<li>找对人，养成人，建梯队</li>
<li>看得清本质：有眼光，看问题不停留在表面，能追本溯源</li>
<li>看得见未来：能感知并把握未来趋势，可以识别机会和危机</li>
<li>能清晰向团队传递方向和打法</li>
<li>敢于做决定，善于做取舍</li>
<li>有足够的视野，能够判断创新破局的时机</li>
<li>主动为创新争取资源和条件，愿赌服输</li>
<li>走近客户，了解客户需求，注重客户体验，且有行动和结果</li>
<li>不只KPI导向，以实现客户价值为目标</li>
<li>有担当，没有条件创造条件也要上</li>
<li>有强大的决心，不等不靠，积极主动</li>
</ul>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>感悟</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年遇上的线上故障</title>
    <url>/2020/06/02/met-online-fault.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源 <a href="https://www.zcool.com.cn/work/ZMjc0MTc4MTI=.html">https://www.zcool.com.cn/work/ZMjc0MTc4MTI=.html</a> PS：未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<p>做技术最怕什么？也许就是出现线上故障吧，因为它不仅仅和你的绩效有关，还体现着你的能力。</p>
<p>项目上线后，随着系统运行时间的增长，一瞬间用户访问量提升，用户某个奇怪行为都可能给系统带来致命的问题，本文总结了这一年来遇到的线上问题以及解决思路。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="订单查询"><a href="#订单查询" class="headerlink" title="订单查询"></a>订单查询</h4><p>在公司负责支付方面，离不开订单系统，订单系统提供了订单查询RPC接口，某天早上突然收到运营同学反馈，某业务系统服务首页一直提示报错（进入页面首页后会轮训查询当前用户未支付的订单），第一时间去查看日志，发现接口响应时长都接近10秒，同时找运维同学查看数据库状态，此时数据库的CPU已经达到了90%+（数据库CPU没做报警策略，没能第一时间知道），当时数据库的配置是4C16G，理论上不会轻易搞崩。</p>
<p>查看订单系统的日志后第一时间查看了CPU运行信息和内存使用情况，CPU和内存使用情况都正常，问题说明出现在了数据库。一台服务器CPU爆表说明有大量任务在执行或者出现了严重的资源竞争，比如死锁。数据库服务只部署了数据库，没有其他服务，那么问题可能是出现了资源竞争。</p>
<p>通过查看数据库当时的运行情况，出现几条严重的慢SQL，同时提示了行锁过多。由于订单服务是我后面接手的，前期的表创建我都没动过（说明一个问题，在接手一个服务后，除了了解业务流程外还要第一时间去了解数据库，比如索引！），当时的数据量达到了数十万，核心的订单表只有一个主键索引，导致每次查询（通过其他字段）都是全表扫描，行锁升级为表锁，导致数据库锁竞争情况严重，当时的解决方案是对查询频繁的字段加了索引（比如用户ID），通过索引这一优化很好的解决了该问题。</p>
<h4 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h4><p>年后上班接到一个需求，在他人负责的系统中写两个功能，信息录入和文件导出，当时提供了几个接口，一是通过身份证查询信息，确认当前用户是否录入过信息，一个是文件导出。前期上线后系统运行一切正常，在某天突然有人反馈不能保存数据了，通过身份证查询信息也十分的慢。第一反应是网络问题吗？访问服务页面偶尔响应慢，接口也是如此，开始怀疑网络问题，是否是专网的网络太慢，导致Nginx转发时出现大量等待的情况呢？于是带着怀疑去服务器检查网络情况，发现问题并非如此，在ping的情况下，没有丢包，响应时间也是正常，那么问题还可能会出现在哪呢？页面访问速度异常，接口也是异常，页面不会操作数据库资源，接口会查询数据，出问题的地方就只剩下两种情况了，一是服务器出问题，二是数据库出问题。由于页面访问也出现异常，可以先排除数据库问题。</p>
<p>既然是服务器问题，首先应该检查CPU负载，内存情况。通过top命令查看当时CPU负载情况，数值都属于正常范围，同时查看内存分配也处于正常情况。面对这样的情况一脸懵逼，回到问题，一共提供了几个接口，出现问题的时间基本发生在同一时间段，大量占用资源的操作就是导出数据，那么会不会和数据库连接有关？带着这个疑问去查看了项目的数据库配置，没有超时时间控制，最大连接数8。如果数据库连接没有超时时间控制，那么是不是意味着获取连接的线程会一直阻塞？为了方便排查具体问题，在服务器上安装了阿里开源的arthas，通过线程分析，发现大量的HTTP线程处于阻塞状态，而发生阻塞的代码就是获取数据库连接，问题定位到，修改了项目的数据库连接数和超时时间，问题解决。</p>
<p>当然，针对文件导出这样的需求，一般的做法是凌晨某个时间段生成文件，提供下载功能即可，要不然某个时间段大量的文件导出会大量消耗数据库资源，比如支付宝和微信的账单下载，他们就会提前生成文件。</p>
<p>数据库的配置和服务器配置一样，如果我们配置不合理，就会出现各种资源耗尽。面对多样的配置，一定要充满好奇心，去看看作用是啥，怎样合理使用会更好，这样才能尽可能的减少项目故障。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>服务器的日志你会保留多少天？做支付时日志我会选择保留180天，半年的时间，确保半年内出现支付问题能追溯。在接触的一些项目中，有一些没有做到很好的日志管理，导致磁盘刷爆。当时接手一个项目，其中也有文件导出功能，当时遇到的情况就是文件导出不了（使用的阿里开源的easy excel），通过排查系统日志并未发现系统错误或程序上的异常，问题出现在哪呢？</p>
<p>文件导出功能，它的执行过程是怎样的呢？首先是数据从数据库加载到内存，那么接下来就是从内存写文件了。把内存的数据写入文件有两种做法，一是先在内存中生成文件写入数据然后落磁盘，二是文件先落磁盘，然后从内存中输出到磁盘文件。两种方式各有利弊，大多数会选择后者，前者容易出现OOM，不太现实。</p>
<p>再排查了系统和程序问题后，偶然下执行了df -h 命令，发现磁盘没空间了，在确认了日志是否可删的前提下删除了部分日志，然后在执行文件导出功能，发现功能恢复正常。当时想，为什么文件导出与磁盘还有一定关系呢？通过查看easy excel写入文件的逻辑是有默认把文件写入磁盘的，如果你磁盘写不了，文件自然就无法导出了，具体源码代码段忘记了，遇到问题还是需要去看源码，那里是你找到答案最近的地方。</p>
<p>论，服务器运维的重要性。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>说到内存，内存的问题大致分两种，内存溢出和内存泄漏。</p>
<p>内存溢出：程序没有足够的内存使用时，就会发生内存溢出。内存溢出后程序基本上就无法正常运行了。</p>
<p>内存泄漏：当程序不能及时释放内存，导致占用内存逐渐增加，就是内存泄漏。</p>
<p>内存泄漏一般不会导致程序无法运行。不过持续的内存泄漏，累积到内存上限时，就会发生内存溢出。Java服务出现OOM，最常见的原因一般有以下三点：</p>
<ol>
<li><p>内存确实分配过小，内存确实不够用；</p>
</li>
<li><p>某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽；</p>
</li>
<li><p>某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接；</p>
</li>
</ol>
<p>当时的情况是，某服务存在大量的数据上传工作，即从数据库中读取数据，通过程序上传到ODPS。某天服务器报警说内存不够了，登上服务器查看了内存大小，4G内存，但并不代表JVM可用内存就是4G，通过jmap（jmap -heap pid）命令确认了JVM的内存分配情况，通过该命令可以查看新生代，老生代堆内存的分配大小以及使用情况。</p>
<p>内存分配正常，是不是存在对象被频繁申请呢？毕竟上传数据离不开数据查询，是否可能是一次性查询的数据过多，导致OOM，通过命令（jmap -histo:live pid | more）查看最耗内存的对象，果然，某个DO存在大量实例对象，由于都是强引用，JVM在垃圾回收时没有回收这些对象，导致出现OOM。</p>
<p>当时的解决方案是加大内存，从4G增加到8G，问题得等解决。当然这并不意味着这是最好的解决方案。后面我们对程序进行了优化，查询的数据是List<XxxDO> ，在处理完后及时clear集合中的数据，手动触发GC，建议JVM垃圾回收。控制数据查询量，避免一次性加载所有数据到内存，做好增量上传。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>有问题不可怕，我们需要自信，从容的面对他们，这样才能淡定的去解决问题。</li>
<li>配置合理化，使用框架或工具一定要充满好奇，去看看配置有哪些，作用是什么。</li>
<li>接手项目后，除了了解业务玩法还要重点关注数据库。</li>
</ol>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>当类出现冲突</title>
    <url>/2020/05/13/when-classes-conflict.html</url>
    <content><![CDATA[<blockquote>
<p>特别说明：封面图片来源  <a href="https://www.zcool.com.cn/work/ZMjEwNTQ3MTY=.html">https://www.zcool.com.cn/work/ZMjEwNTQ3MTY=.html</a>  PS：未授权…若作者看到后不愿意授权可联系下架</p>
</blockquote>
<p>做Java开发的同学应该都遇到过类冲突，一般都是各个依赖相互引用导致同一个类存在多个版本，我们一般采用依赖排除、依赖管理等常规方式来尝试解决该问题。那么类冲突的根本原因是什么呢？</p>
<p>在知道根本原因之前，我想还有两个有意思的问题，一是：怎么判断一个类是否存在；二是：同一类会加载多次吗？</p>
<h4 id="怎么判断一个类是否存在？"><a href="#怎么判断一个类是否存在？" class="headerlink" title="怎么判断一个类是否存在？"></a>怎么判断一个类是否存在？</h4><p> 先解决这个问题，怎么判断一个类是否存在？第一反应是搜索，在JVM当中怎么搜索一个类呢，第一反应是加载该类。在JVM中，加载一个类大致经过这几个过程：加载-&gt;验证-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。加载就是通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.Class对象。通过Java代码有两种方式去加载一个类，一是：Class.forName(String className) ，二是：ClassLoader.loadClass(String name);</p>
<p>两者之间的共同点是都是检查异常，即需要我们处理 ClassNotFoundException ，如果抛出此异常表明当前JVM中无此类。至于JVM底层是怎么实现的，这不是我们的关注点，因为两个方法是 native 修饰，细知更底层就需要…</p>
<p>Class.forName() 有两个重载，两者之前的区别在于是否初始化该类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize, ClassLoader loader)</span><br></pre></td></tr></table></figure>

<p>Class.forName(className)方法，内部实际调用的方法是  Class.forName(className, true, classloader); boolean initialize 参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static 块代码执行，static参数也会被再次初始化。</p>
<p>ClassLoader.loadClass(name) 该方法内部会调用 protected Class&lt;?&gt; loadClass(String name, boolean resolve) 实际 resolve 为false，表示不进行连接（类加载步骤中的验证、解析）。</p>
<p>如果我们只是判断一个类是否存在，而不需要初始化改类，用 ClassLoader.loadClass 是比较好的方式，当然也可以使用 Class.forName。</p>
<h4 id="同一个类会加载多次吗？"><a href="#同一个类会加载多次吗？" class="headerlink" title="同一个类会加载多次吗？"></a>同一个类会加载多次吗？</h4><p>换个问题，你可能听过多次，自定义一个String类，全限定名与JDK的 java.lang.String 一样，自定义的String可以执行吗？答案是否定的，为什么？因为Java的双亲委派机制，当一个类被加载时，首先会让其父类加载器去加载，父类加载器无法加载时子类加载器才会执行，JVM中定义类加载器主要包括，自定义类加载器 -&gt; 应用程序类加载器 -&gt; 扩展类加载器 -&gt; 启动类加载器。很显然，String会优先被启动类加载器加载，为什么需要双亲委派机制，原因有以下几点，一是规范，上面做了事情，下面就不要重复做了，这样可以避免重复加载，父类已经加载了，子类就不需要再次加载；二是安全，解决了各个类加载器的基础类的统一问题，只要父类加载器加载了，子类加载器就不能再加载，否者用户随意定义类加载器来加载核心api，会带来相关隐患。</p>
<p>再回到这个问题，同一个类会加载多次吗？从上文的分析可知，一个类（全限定名一样）只能被JVM加载一次。其实通过ClassLoader.loadClass() 方法也知道（具体实现的方法 loadClass(String name, boolean resolve)），在加载时首先会去查询类是否已经加载，若已加载则会直接返回，未加载才会进一步去加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类冲突的表现"><a href="#类冲突的表现" class="headerlink" title="类冲突的表现"></a>类冲突的表现</h4><p>类冲突的表现主要体现在一下几种情况。运行时错误和编译时异常。</p>
<ol>
<li>java.lang.ClassNotFoundException ，类找不到，这个问题一般是高版本或低版本缺失某个类，比如低版本有Test.class 这个类，而在高版本的依赖中没有了这个类，类加载器在加载时，加载了低版本的类，那么这个时候会报 ClassNotFoundException 异常，一般会在编译时抛出异常。根本原因是类加载器在当前classpath目录中没有找到这个字节码文件，而发生异常。</li>
<li>java.lang.NoSuchMethodError，没有特定的方法，这个问题和上述类似，同样的类中，不同版本存在不同的方法，比如高版本新增了某几个方法，在类加载时加载了低版本的类，我们在使用高版本类的方法时则会报这个错，编译时发生错误。</li>
<li>java.lang.NoClassDefFoundError，没有被定义的类，这类错误都是运行时错误，JVM在编译时能找到合适的类，但在运行期间找不到合适的类。</li>
</ol>
<p>比如下面的例子，在运行时我们想调用某个类的方法或者访问这个类的静态成员的时候，发现这个类不可用，此时Java虚拟机就会抛出NoClassDefFoundError错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wy.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 0x4096.peng@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoClassDefFoundErrorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassInitError</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">/* 因为初始化静态变量失败, 所以加载类失败 */</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassInitError</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">/* java.lang.NoClassDefFoundError: Could not initialize class com.wy.demo.test.NoClassDefFoundErrorTest$ClassInitError */</span></span><br><span class="line">            <span class="comment">/* 因为第一次类加载失败了, JVM不会重复加载类, 现在又去使用一个类, 导致在JVM中找不到该类, 抛出 NoClassDefFoundError 错误 */</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个类, 在初始化时会失败, 抛出异常 Caused by: java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassInitError</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">5</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>除了上面的例子外，出现 NoClassDefFoundError 错误也可能是jar冲突，此类问题遇到过一次，但是在测试环境没复现出来。当时的情况是A业务系统中的fastjson版本为1.2.49，我提供的二方库中使用的fastjson版本为1.2.62，业务系统在使用了二方库中某个类的toString方法时出现了 NoClassDefFoundError 错误，当时的解决方案是升级业务系统的fastjson版本。</p>
<h4 id="有效避免"><a href="#有效避免" class="headerlink" title="有效避免"></a>有效避免</h4><p>在发生问题之前，我们需要做的是有效防守，即在冲突发生之前能有效地规避。项目构建大多是使用maven，我们可以很好的利用的依赖管理，除此之外我们还可以使用一些插件去帮我们检查。在遇到一些依赖问题时，比如某个jar包是谁引入的？我们也可以使用命令去发现问题，mvn dependency:tree 。</p>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>野蛮生长 - 做支付的这一年</title>
    <url>/2020/05/01/savage-growth-make-pay.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果，回过头来看看这一年走过的路？</p>
<h2 id="留下的缘"><a href="#留下的缘" class="headerlink" title="留下的缘"></a>留下的缘</h2><p>玩支付这块的游戏得从大学开始。在学校呢，偶尔会做作业，而每次我选的课题都是与订单支付相关，比如，在线点餐、网上商城等，所以在订单这块玩的还挺溜。不过，个人账号申请不了支付相关的信息，需要相关的营业执照，所以每次演示项目效果都是简单的模拟支付结果，然后支付成功，评价…</p>
<p>两年前，我以实习生的身份入职这家公司，很意外的接触了公司的支付项目，然后，支付之旅就开始了。公司的支付系统从0到1，再到多个版本的迭代，然后进化成现在的统一支付平台，这一路还是有那么几个难忘的夜晚以及小故事。</p>
<h2 id="被迫成长"><a href="#被迫成长" class="headerlink" title="被迫成长"></a>被迫成长</h2><p>19年的春节是在2月5号，以学生的名义在家度过最后一个元宵节，然后匆忙到公司，写代码，完善服务。第一次项目上线是在2019年3月12号，服务一发就是两天，从12号发到13号凌晨一点多，那天应该是我实习那么久来，成长最多的一天（但这次，却不是我最后一次，因为服务归档没做好而导致发布意外多）。我相信，很多刚走出校门的人，对于关键日志的打印，异常堆栈的捕获等，都欠缺完善的处理。而我，就是其中一个。当时服务上线后，移动客户端初始化请求一直报错，日志不详细，我不知道哪里空指针了，哪个数据库字段缺失了？怎么办？当时的解决方案就是加日志、重写发布，再加日志、重写发布，远程断点… 那晚，我感到十分的内疚和自责，为什么那么多的前期工作没做好？我还拖着我的领导到凌晨一点。其实，发布的问题他可以很快的帮我解决，但他没有这样做，而是一步步的指引我，让我冷静去分析问题，再去解决问题。</p>
<p>有问题不可怕，只要敢于面对，最终不都得以解决嘛。</p>
<p>业务发展谈不上飞速，却在7、8月爆发，也就是我刚毕业的那一两个月。最糟的情况下，我一周四天没写过代码，每天都在排查、追踪各种问题，那段时间压力很大，所有的问题都需要一个人抗住。现在回过头来，真是被迫生长啊。</p>
<p>支付的链路比较长，日志排查成了痛点，日志上下文杂多，分布式项目只能靠订单号定位关键日志，却丢失上下文。怎么办？日志链路追踪，在了解了相关开源解决方案后，选择了蚂蚁的SOFATracer （<a href="https://www.sofastack.tech/projects/sofa-tracer/overview/%EF%BC%89">https://www.sofastack.tech/projects/sofa-tracer/overview/）</a> 作为学习目标，快速简单的实现了一个内部版本，问题排查的难点解决了（已开源一个简单实现，开箱即用  <a href="https://github.com/0x4096/tracer/">https://github.com/0x4096/tracer/</a> ）。至于为什么不直接用别人的工具，主要还是暂时没必要去使用这么一个较复杂的工具。</p>
<p>9月，支付项目有新需求需要上线，很幸运的是，那群同事刚好出现，替我分担了很多压力，否则我一个人，真的是做不完啊。而这个月也是我压力最大的一个月，我记得那天周四，我想去打个羽毛球，打了没20分钟，我就打车回公司了，我的心完全被束缚了。</p>
<p>经历了一个月的服务改动，四个人的代码增加、修改，项目上线的前提必须保证测试到位，服务完整归档。而那一天，服务发到凌晨三点，服务归档不详细，封版的代码还在改，MQ网络不通…，导致上线后出现一系列问题，哪能怎么办啊？我是主要负责人，所有问题都应由我一人承担…</p>
<p>从经历过这次以后，后面发服务都是沉稳…</p>
<h2 id="加过的班"><a href="#加过的班" class="headerlink" title="加过的班"></a>加过的班</h2><p>连续三个月的加班，周末，你要问我成长了什么？我不知道该怎么回答…但我还挺怀恋那段时间…</p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol>
<li>dubbo版本替换成Apache的，重试机制默认是2，由于网络问题，导致支付失败，重试出现问题…</li>
<li>订单查询核心参数没校验，导致支付错单号…</li>
<li>支付金额代码用double，导致精度丢失…</li>
<li>退款dubbo接口超时（其实已经成功），订单状态没改…</li>
<li>订单关闭，但是用户又支付…</li>
</ol>
<h2 id="项目进化"><a href="#项目进化" class="headerlink" title="项目进化"></a>项目进化</h2><p>支付作为一个基础服务，主要提供便捷的支付能力供业务系统使用，整个支付链路如下图</p>
<img src="http://cdn.0x4096.com//image/20200914215712.png"> 
<br/>

<p>公司的支付较为复杂，涉及好几个支付账号，同时又涉及多个支付场景，比如一家医院有多个支付宝账号授权，这时就需要配置使用哪个支付账号发起，那种业务场景操作。支付中心都屏蔽了这些细节，业务系统在使用接口时只需要关心核心参数即可，其他交付由支付中心处理。</p>
<p>支付涉及多个系统，将其拆分为支付中心，订单中心，通知中心，几个核心模块，业务系统接入支付能力，整体链路如下</p>
<img src="http://cdn.0x4096.com//image/20200914222145.png"> 
<br/>

<p>一般支付系统都会进行拆分订单中心和支付中心两个系统。在最初的设计上，订单系统只提供订单相关能力，支付中心支提供支付能力，当时的业务系统需要接入支付能力，成本非常高，需要在订单系统创建订单相关，然后去支付中心获取支付能力，在支付完成后需要调用订单系统修改订单状态，这一做法对业务系统来说，太繁琐了。同时，在业务系统创建订单后，能不能简化支付呢？在支付中心我们封装的接口都是最原始的接口，如果让业务系统去直接调用，那么成本还是比较高，字段多，场景丰富。其实，对于业务系统来说，他只关心使用哪种支付渠道支付哪笔订单即可。所以呢，我们在订单系统封装了一套支付能力，简化业务系统的操作，同时可以控制订单信息，避免关闭的订单业务系统还能支付等。为了防止网络问题，导致接口超时，订单系统与支付中心的核心交易接口增加了交易结果补偿，避免出现单边账。</p>
<p>支付架构经过多次迭代，最终演变成如下图（参考了马蜂窝支付）</p>
<img src="http://cdn.0x4096.com/image/%E6%94%AF%E4%BB%98%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png"> 
<br/>

<p>各模块各尽其责，职责单一。支付发展到今天，功能逐步完善，对账平台出现，聚合支付能力也跟上。</p>
<h2 id="支付链路有多复杂？"><a href="#支付链路有多复杂？" class="headerlink" title="支付链路有多复杂？"></a>支付链路有多复杂？</h2><p>我们在使用微信或支付宝付款之后，究竟发生了什么？来看个视频，微博原文 <a href="https://weibo.com/tv/show/1034:4523725815742474?from=old_pc_videoshow">https://weibo.com/tv/show/1034:4523725815742474?from=old_pc_videoshow</a></p>
<p><video src="https://f.video.weibocdn.com/M6pe8Ut3lx07ECVgHR7i010412062CQE0E030.mp4?label=mp4_1080p&template=1920x1080.25.0&trans_finger=daa7c63436091a9dfe20e4b554312cac&media_id=4523725815742474&tp=8x8A3El:YTkl0eM8&us=0&ori=1&bf=3&ot=h&ps=3lckmu&uid=6Au4TI&ab=966-g1,3370-g1&Expires=1604239915&ssig=CUoRsYWbiL&KID=unistore,video" width="900px" controls="controls"></video></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul>
<li>日志，十分重要（包括规范），dubbo接口请求入参必须要，链路追踪不可少；</li>
<li>监控，出现异常，必须第一时间通知相关人员，尽可能的减少单边账，支付不可用问题；</li>
<li>异步，能走异步通过消息处理的，一律异步处理，减低系统耦合性；</li>
</ul>
<h3 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h3><p>很幸运有机会去接触支付相关，领导的信任让我去负责这么一个事情，实现了公司支付系统从0到1的过程。这个过程，不仅仅是代码能力的提升…</p>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>当继承、接口出现代码冲突</title>
    <url>/2020/03/18/extends-interface-code-conflict.html</url>
    <content><![CDATA[<h2 id="一、代码冲突"><a href="#一、代码冲突" class="headerlink" title="一、代码冲突"></a>一、代码冲突</h2><p>看到代码冲突，也许你的第一反应是某个项目多人协作，操作同一分支而导致代码冲突。“醉翁之意不在酒”，本文的代码冲突是指当一个类继承某个类，实现多个接口，某个类与接口都具有相同的函数签名，这种情况下，类会选择使用哪一个函数？在实际情况中，像这样的冲突可能极少发生，但是一旦发生这样的状况，必须要有一套规则来确定按照什么样的约定处理这些冲突。</p>
<p>备注信息：JDK：1.8</p>
<h2 id="二、解决问题的三条规则"><a href="#二、解决问题的三条规则" class="headerlink" title="二、解决问题的三条规则"></a>二、解决问题的三条规则</h2><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或接口）继承了方法，通过三条<br>规则可以进行判断。</p>
<ol>
<li><p>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p>
</li>
<li><p>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。</p>
</li>
<li><p>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</p>
</li>
</ol>
<h3 id="1-选择提供了最具体实现的默认方法的接口"><a href="#1-选择提供了最具体实现的默认方法的接口" class="headerlink" title="1. 选择提供了最具体实现的默认方法的接口"></a>1. 选择提供了最具体实现的默认方法的接口</h3><p>我们来看看刚才举的例子，这个例子中C类同时实现了B接口和A接口，而这两个接口恰巧又都定义了名为hello的默认方法。另外， B继承自A。UML图如下：</p>
<p><img src="http://cdn.0x4096.com/image/2020/03/18/article/image-20200317232314440.png" alt="image-20200317232314440"></p>
<p>按照规则2，应该选择的是提供了最具体实现的默认方法的接口。由于B比A更具体，所以应该选择B的hello方法。所以，程序会打印输出“B”。</p>
<p>既然B比A更具体，如果我们在A的基础上再具体一点，例如D继承A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, A &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML图如下：</p>
<p><img src="http://cdn.0x4096.com/image/2020/03/18/article/image-20200317233335008.png" alt="image-20200317233335008"></p>
<p>依据规则1，类中声明的方法具有更高的优先级。 D并未覆盖hello方法，可是它实现了接口A。所以它就拥有了接口A的默认方法。规则2说如果类或者父类没有对应的方法，那么就应该选择提供了最具体实现的接口中的方法。因此，编译器会在接口A和接口B的hello方法之间做选择。由于B更加具体，所以程序会再次打印输出“B”。</p>
<p>如果我们在D中重写了A接口中的hello方法，则会执行D中的函数，因为符合规则1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-冲突及如何显式地消除歧义"><a href="#2-冲突及如何显式地消除歧义" class="headerlink" title="2. 冲突及如何显式地消除歧义"></a>2. 冲突及如何显式地消除歧义</h3><p>一个类 C 实现 A、B 两个接口，A、B 具有相同的函数签名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">B</span>, A &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看类 C ，你觉得会执行哪个方法？为什么呢？实际上类 C 中的代码是无法编译的。 这时规则2就无法进行判断了，因为从编译器的角度看没有哪一个接口的实现更加具体，两个都差不多。 A接口和B接口的hello方法都是有效的选项。所以， Java编译器这时就会抛出一个编译错误，因为它无法判断哪一个方法更合适：“Error: class C inherits unrelated defaults for hello() from types B and A.”</p>
<p><img src="http://cdn.0x4096.com/image/2020/03/18/article/image-20200317234118236.png" alt="image-20200317234118236"></p>
<h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>解决这种两个可能的有效方法之间的冲突，没有太多方案；你只能显式地决定你希望在C中使用哪一个方法。为了达到这个目的，你可以覆盖类C中的hello方法，在它的方法体内显式地调用你希望调用的方法。 Java 8中引入了一种新的语法X.super.m(…)，其中X是你希望调用的m方法所在的父接口。举例来说，如果你希望C使用来自于B的默认方法，它的调用方式看起来就如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 显示指定使用哪个方法 */</span></span><br><span class="line">        B.<span class="built_in">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-菱形继承问题"><a href="#3-菱形继承问题" class="headerlink" title="3. 菱形继承问题"></a>3. 菱形继承问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">		<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">B</span>, C &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">D</span>().hello();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML图如下：</p>
<p><img src="http://cdn.0x4096.com/image/2020/03/18/article/image-20200317235228987.png" alt="image-20200317235228987"></p>
<p>这种问题叫“菱形问题”，因为类的继承关系图形状像菱形。这种情况下类D中的默认方法到底继承自什么地方 ——源自B的默认方法，还是源自C的默认方法？实际上只有一个方法声明可以选择。只有A声明了一个默认方法。由于这个接口是D的父接口，代码会打印输出“Hello from A”。</p>
<p>现在，我们看看另一种情况，如果B中也提供了一个默认的hello方法，并且函数签名跟A中的方法也完全一致，这时会发生什么情况呢？根据规则2，编译器会选择提供了更具体实现的接口中的方法。由于B比A更加具体，所以编译器会选择B中声明的默认方法。如果B和C都使用相同的函数签名声明了hello方法，就会出现冲突，正如我们之前所介绍的，你需要显式地指定使用哪个方法。</p>
<p>说明：本文参考《Java8 实战》第九章，默认方法；</p>]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>567</title>
    <url>/2020/02/14/567.html</url>
    <content><![CDATA[<video controls="controls" autoplay="autoplay"> 
     <source src="https://tech.0x4096.com/cdn/video/567.mp4" type="video/mp4">
</video>]]></content>
  </entry>
</search>
