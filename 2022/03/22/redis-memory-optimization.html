<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tech.0x4096.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Redis的内存优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis的内存优化">
<meta property="og:url" content="https://tech.0x4096.com/2022/03/22/redis-memory-optimization.html">
<meta property="og:site_name" content="0x4096">
<meta property="og:description" content="Redis的内存优化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png">
<meta property="og:image" content="http://i2.itc.cn/20170216/3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png">
<meta property="og:image" content="http://i0.itc.cn/20170216/3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png">
<meta property="og:image" content="http://i2.itc.cn/20170216/3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png">
<meta property="og:image" content="http://i3.itc.cn/20170216/3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png">
<meta property="og:image" content="http://i2.itc.cn/20170216/3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png">
<meta property="og:image" content="http://i1.itc.cn/20170216/3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png">
<meta property="og:image" content="http://i2.itc.cn/20170216/3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png">
<meta property="og:image" content="http://i1.itc.cn/20170216/3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png">
<meta property="og:image" content="http://i1.itc.cn/20170216/3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png">
<meta property="og:image" content="http://i1.itc.cn/20170216/3084_d48315af_6789_08d6_823d_beec6378e7da_1.png">
<meta property="article:published_time" content="2022-03-22T14:24:48.000Z">
<meta property="article:modified_time" content="2022-03-22T14:24:48.000Z">
<meta property="article:author" content="0x4096">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png">


<link rel="canonical" href="https://tech.0x4096.com/2022/03/22/redis-memory-optimization.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tech.0x4096.com/2022/03/22/redis-memory-optimization.html","path":"2022/03/22/redis-memory-optimization.html","title":"Redis的内存优化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis的内存优化 | 0x4096</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?966d9db328492be47a2e40d36f047046"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<style type="text/css">
  code {
    color: red;
    background: #F0F0EC;
    margin: 0 5px;
    padding: 3px 5px;
    border: 0px solid #ddd;
  }
</style>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">0x4096</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">0x4096的技术分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-redisObject-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">一 . redisObject 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-type-%E5%AD%97%E6%AE%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.type 字段 :</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-encoding-%E5%AD%97%E6%AE%B5"><span class="nav-number">1.2.</span> <span class="nav-text">2.encoding 字段 :</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-lru-%E5%AD%97%E6%AE%B5"><span class="nav-number">1.3.</span> <span class="nav-text">3.lru 字段 :</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-refcount-%E5%AD%97%E6%AE%B5"><span class="nav-number">1.4.</span> <span class="nav-text">4.refcount 字段 :</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ptr-%E5%AD%97%E6%AE%B5"><span class="nav-number">1.5.</span> <span class="nav-text">5. *ptr 字段 :</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E7%BC%A9%E5%87%8F%E9%94%AE%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">二 . 缩减键值对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">3.</span> <span class="nav-text">三 . 共享对象池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%90%AF-maxmemory-%E5%92%8C-LRU-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%90%8E%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%97%A0%E6%95%88"><span class="nav-number">3.1.</span> <span class="nav-text">为什么开启 maxmemory 和 LRU 淘汰策略后对象池无效 ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%B1%A0%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">为什么只有整数对象池？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">四 . 字符串优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">1. 字符串结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%A2%84%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.</span> <span class="nav-text">2. 预分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D%E6%B5%8B%E8%AF%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">表：字符串内存预分配测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">3. 字符串重构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9A%E6%B5%8B%E8%AF%95%E5%86%85%E5%AD%98%E8%A1%A8%E7%8E%B0"><span class="nav-number">4.3.1.</span> <span class="nav-text">表：测试内存表现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">五 . 编码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%86%E8%A7%A3%E7%BC%96%E7%A0%81"><span class="nav-number">5.1.</span> <span class="nav-text">1. 了解编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9Atype-%E5%92%8C-encoding-%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="nav-number">5.1.1.</span> <span class="nav-text">表：type 和 encoding 对应关系表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">2. 控制编码类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9Ahash-list-set-zset-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E9%85%8D%E7%BD%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">表：hash,list,set,zset 内部编码配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ziplist-%E7%BC%96%E7%A0%81"><span class="nav-number">5.3.</span> <span class="nav-text">3.ziplist 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9Aziplist-%E5%9C%A8-hash-list-zset-%E5%86%85%E5%AD%98%E5%92%8C%E9%80%9F%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">表：ziplist 在 hash,list,zset 内存和速度测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-intset-%E7%BC%96%E7%A0%81"><span class="nav-number">5.4.</span> <span class="nav-text">4.intset 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9Aziplist-%E7%BC%96%E7%A0%81%E5%9C%A8-set-%E4%B8%8B%E5%86%85%E5%AD%98%E5%92%8C%E9%80%9F%E5%BA%A6%E8%A1%A8%E7%8E%B0"><span class="nav-number">5.4.1.</span> <span class="nav-text">表：ziplist 编码在 set 下内存和速度表现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E6%8E%A7%E5%88%B6-key-%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">6.</span> <span class="nav-text">六 控制 key 的数量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%9Ahash-%E5%88%86%E7%BB%84%E6%8E%A7%E5%88%B6%E9%94%AE%E8%A7%84%E6%A8%A1%E6%B5%8B%E8%AF%95"><span class="nav-number">6.0.1.</span> <span class="nav-text">表：hash 分组控制键规模测试</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="0x4096"
      src="https://cdn.0x4096.com//cdn/image/007S8ZIlgy1gja6idxwudj30hs0hsq3e.jpg">
  <p class="site-author-name" itemprop="name">0x4096</p>
  <div class="site-description" itemprop="description">求知若饥 虚心若愚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/0x4096" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;0x4096" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tech.0x4096.com/2022/03/22/redis-memory-optimization.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.0x4096.com//cdn/image/007S8ZIlgy1gja6idxwudj30hs0hsq3e.jpg">
      <meta itemprop="name" content="0x4096">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0x4096">
      <meta itemprop="description" content="求知若饥 虚心若愚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis的内存优化 | 0x4096">
      <meta itemprop="description" content="Redis的内存优化">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis的内存优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">


   <!-- 置顶 -->
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-22 22:24:48" itemprop="dateCreated datePublished" datetime="2022-03-22T22:24:48+08:00">2022-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>


          <!--
            <div class="post-description">Redis的内存优化</div>
          -->
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>声明：本文内容来自《Redis 开发与运维》一书第八章，如转载请声明。  <a target="_blank" rel="noopener" href="https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#chapter6">https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#chapter6</a></p>
</blockquote>
<p>Redis 所有的数据都在内存中，而内存又是非常宝贵的资源。对于如何优化内存使用一直是 Redis 用户非常关注的问题。本文让我们深入到 Redis 细节中，学习内存优化的技巧。分为如下几个部分：</p>
<p>一 . redisObject 对象<br>二 . 缩减键值对象<br>三 . 共享对象池<br>四 . 字符串优化<br>五 . 编码优化<br>六 . 控制 key 的数量</p>
<h2 id="一-redisObject-对象"><a href="#一-redisObject-对象" class="headerlink" title="一 . redisObject 对象"></a>一 . redisObject 对象</h2><p>Redis 存储的所有值对象在内部定义为 redisObject 结构体，内部结构如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png"><img src="http://i1.itc.cn/20170216/3084_2c3a0c00_6cbc_c4d9_01fe_8852cc497653_1.png" alt="img"></a></p>
<p>Redis 存储的数据都使用 redisObject 来封装，包括 string,hash,list,set,zset 在内的所有数据类型。理解 redisObject 对内存优化非常有帮助，下面针对每个字段做详细说明：</p>
<h3 id="1-type-字段"><a href="#1-type-字段" class="headerlink" title="1.type 字段 :"></a>1.type 字段 :</h3><p>表示当前对象使用的数据类型，Redis 主要支持 5 种数据类型 :string,hash,list,set,zset。可以使用 type {key} 命令查看对象所属类型，type 命令返回的是值对象类型，键都是 string 类型。</p>
<h3 id="2-encoding-字段"><a href="#2-encoding-字段" class="headerlink" title="2.encoding 字段 :"></a>2.encoding 字段 :</h3><p>表示 Redis 内部编码类型，encoding 在 Redis 内部使用，代表当前对象内部采用哪种数据结构实现。理解 Redis 内部编码方式对于优化内存非常重要 ，同一个对象采用不同的编码实现内存占用存在明显差异，具体细节见之后编码优化部分。</p>
<h3 id="3-lru-字段"><a href="#3-lru-字段" class="headerlink" title="3.lru 字段 :"></a>3.lru 字段 :</h3><p>记录对象最后一次被访问的时间，当配置了 maxmemory 和 maxmemory-policy&#x3D;volatile-lru | allkeys-lru 时， 用于辅助 LRU 算法删除键数据。可以使用 object idletime {key} 命令在不更新 lru 字段情况下查看当前键的空闲时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发提示：可以使用scan + object idletime  命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理降低内存占用。</span><br></pre></td></tr></table></figure>

<h3 id="4-refcount-字段"><a href="#4-refcount-字段" class="headerlink" title="4.refcount 字段 :"></a>4.refcount 字段 :</h3><p>记录当前对象被引用的次数，用于通过引用次数回收内存，当 refcount&#x3D;0 时，可以安全回收当前对象空间。使用 object refcount {key} 获取当前对象引用。当对象为整数且范围在 [0-9999] 时，Redis 可以使用共享对象的方式来节省内存。具体细节见之后共享对象池部分。</p>
<h3 id="5-ptr-字段"><a href="#5-ptr-字段" class="headerlink" title="5. *ptr 字段 :"></a>5. *ptr 字段 :</h3><p>与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针。Redis 在 3.0 之后对值对象是字符串且长度 &lt;&#x3D;39 字节的数据，内部编码为 embstr 类型，字符串 sds 和 redisObject 一起分配，从而只要一次内存操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发提示：高并发写入场景中，在条件允许的情况下建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数从而提高性能。</span><br></pre></td></tr></table></figure>

<h2 id="二-缩减键值对象"><a href="#二-缩减键值对象" class="headerlink" title="二 . 缩减键值对象"></a>二 . 缩减键值对象</h2><p>降低 Redis 内存使用最直接的方式就是缩减键（key）和值（value）的长度。</p>
<ul>
<li>key 长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li>
<li>value 长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入 Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。以 JAVA 为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如 : protostuff，kryo 等，下图是 JAVA 常见序列化工具空间压缩对比。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://i2.itc.cn/20170216/3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png"><img src="http://i2.itc.cn/20170216/3084_8e427aa5_bf49_c714_45f8_692fccf2cd6b_1.png" alt="img"></a></p>
<p>其中 java-built-in-serializer 表示 JAVA 内置序列化方式，更多数据见 jvm-serializers 项目 :<a target="_blank" rel="noopener" href="https://github.com/eishay/jvm-serializers/wiki">https://github.com/eishay/jvm-serializers/wiki</a> 其它语言也有各自对应的高效序列化工具。</p>
<p>值对象除了存储二进制数据之外，通常还会使用通用格式存储数据比如 :json，xml 等作为字符串存储在 Redis 中。这种方式优点是方便调试和跨语言，但是同样的数据相比字节数组所需的空间更大，在内存紧张的情况下，可以使用通用压缩算法压缩 json,xml 后再存入 Redis，从而降低内存占用，例如使用 GZIP 压缩后的 json 可降低约 60% 的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发提示：当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。</span><br></pre></td></tr></table></figure>

<h2 id="三-共享对象池"><a href="#三-共享对象池" class="headerlink" title="三 . 共享对象池"></a>三 . 共享对象池</h2><p>对象共享池指 Redis 内部维护 [0-9999] 的整数对象池。创建大量的整数类型 redisObject 存在内存开销，每个 redisObject 内部结构至少占 16 字节，甚至超过了整数自身空间消耗。所以 Redis 内存维护一个 [0-9999] 的整数对象池，用于节约内存。 除了整数值对象，其他类型如 list,hash,set,zset 内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。<br>整数对象池在 Redis 中通过变量 REDIS_SHARED_INTEGERS 定义，不能通过配置修改。可以通过 object refcount 命令查看对象引用数验证是否启用整数对象池技术，如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set foo 100 </span><br><span class="line">OK</span><br><span class="line">redis&gt; object refcount foo</span><br><span class="line">(integer) 2</span><br><span class="line">redis&gt; set bar 100</span><br><span class="line">OK</span><br><span class="line">redis&gt; object refcount bar</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>设置键 foo 等于 100 时，直接使用共享池内整数对象，因此引用数是 2，再设置键 bar 等于 100 时，引用数又变为 3，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i0.itc.cn/20170216/3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png"><img src="http://i0.itc.cn/20170216/3084_ffd40aaf_b79c_0c62_9751_650a6b0ccc53_1.png" alt="img"></a></p>
<p>使用整数对象池究竟能降低多少内存？让我们通过测试来对比对象池的内存优化效果，如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">操作说明</th>
<th align="left">是否对象共享</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">used_mem</th>
<th align="left">used_memory_rss</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入 200 万</td>
<td align="left">否</td>
<td align="left">20 字节</td>
<td align="left">[0-9999] 整数</td>
<td align="left">199.91MB</td>
<td align="left">205.28MB</td>
</tr>
<tr>
<td align="left">插入 200 万</td>
<td align="left">是</td>
<td align="left">20 字节</td>
<td align="left">[0-9999] 整数</td>
<td align="left">138.87MB</td>
<td align="left">143.28MB</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意本文所有测试环境都保持一致，信息如下:</span><br><span class="line">服务器信息: cpu=Intel-Xeon E5606@2.13GHz memory=32GB</span><br><span class="line">Redis版本:Redis server v=3.0.7 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64</span><br></pre></td></tr></table></figure>

<p>使用共享对象池后，相同的数据内存使用降低 30% 以上。可见当数据大量使用 [0-9999] 的整数时，共享对象池可以节约大量内存。需要注意的是对象池并不是只要存储 [0-9999] 的整数就可以工作。当设置 maxmemory 并启用 LRU 相关淘汰策略如 :volatile-lru，allkeys-lru 时，Redis 禁止使用共享对象池，测试命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set key:1 99</span><br><span class="line">OK //设置key:1=99</span><br><span class="line">redis&gt; object refcount key:1</span><br><span class="line">(integer) 2 //使用了对象共享,引用数为2</span><br><span class="line">redis&gt; config set maxmemory-policy volatile-lru</span><br><span class="line">OK //开启LRU淘汰策略</span><br><span class="line">redis&gt; set key:2 99</span><br><span class="line">OK //设置key:2=99</span><br><span class="line">redis&gt; object refcount key:2</span><br><span class="line">(integer) 3 //使用了对象共享,引用数变为3</span><br><span class="line">redis&gt; config set maxmemory 1GB</span><br><span class="line">OK //设置最大可用内存</span><br><span class="line">redis&gt; set key:3 99</span><br><span class="line">OK //设置key:3=99</span><br><span class="line">redis&gt; object refcount key:3</span><br><span class="line">(integer) 1 //未使用对象共享,引用数为1</span><br><span class="line">redis&gt; config set maxmemory-policy volatile-ttl</span><br><span class="line">OK //设置非LRU淘汰策略</span><br><span class="line">redis&gt; set key:4 99</span><br><span class="line">OK //设置key:4=99</span><br><span class="line">redis&gt; object refcount key:4</span><br><span class="line">(integer) 4 //又可以使用对象共享,引用数变为4</span><br></pre></td></tr></table></figure>

<h3 id="为什么开启-maxmemory-和-LRU-淘汰策略后对象池无效"><a href="#为什么开启-maxmemory-和-LRU-淘汰策略后对象池无效" class="headerlink" title="为什么开启 maxmemory 和 LRU 淘汰策略后对象池无效 ?"></a>为什么开启 maxmemory 和 LRU 淘汰策略后对象池无效 ?</h3><p>LRU 算法需要获取对象最后被访问时间，以便淘汰最长未访问数据，每个对象最后访问时间存储在 redisObject 对象的 lru 字段。对象共享意味着多个引用共享同一个 redisObject，这时 lru 字段也会被共享，导致无法获取每个对象的最后访问时间。如果没有设置 maxmemory，直到内存被用尽 Redis 也不会触发内存回收，所以共享对象池可以正常工作。</p>
<p>综上所述，共享对象池与 maxmemory+LRU 策略冲突，使用时需要注意。 对于 ziplist 编码的值对象，即使内部数据为整数也无法使用共享对象池，因为 ziplist 使用压缩且内存连续的结构，对象共享判断成本过高，ziplist 编码细节后面内容详细说明。</p>
<h3 id="为什么只有整数对象池？"><a href="#为什么只有整数对象池？" class="headerlink" title="为什么只有整数对象池？"></a>为什么只有整数对象池？</h3><p>首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis 之所以只有整数对象池，是因为整数比较算法时间复杂度为 O(1)，只保留一万个整数为了防止对象池浪费。如果是字符串判断相等性，时间复杂度变为 O(n)，特别是长字符串更消耗性能 (浮点数在 Redis 内部使用字符串存储)。对于更复杂的数据结构如 hash,list 等，相等性判断需要 O(n2)。对于单线程的 Redis 来说，这样的开销显然不合理，因此 Redis 只保留整数共享对象池。</p>
<h2 id="四-字符串优化"><a href="#四-字符串优化" class="headerlink" title="四 . 字符串优化"></a>四 . 字符串优化</h2><p>字符串对象是 Redis 内部最常用的数据类型。所有的键都是字符串类型， 值对象数据除了整数之外都使用字符串存储。比如执行命令 :lpush cache:type “redis” “memcache” “tair” “levelDB” ，Redis 首先创建”cache:type”键字符串，然后创建链表对象，链表对象内再包含四个字符串对象，排除 Redis 内部用到的字符串对象之外至少创建 5 个字符串对象。可见字符串对象在 Redis 内部使用非常广泛，因此深刻理解 Redis 字符串对于内存优化非常有帮助 :</p>
<h3 id="1-字符串结构"><a href="#1-字符串结构" class="headerlink" title="1. 字符串结构"></a>1. 字符串结构</h3><p>Redis 没有采用原生 C 语言的字符串类型而是自己实现了字符串结构，内部简单动态字符串 (simple dynamic string)，简称 SDS。结构下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i2.itc.cn/20170216/3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png"><img src="http://i2.itc.cn/20170216/3084_54bb9bb0_a89d_8e7e_2edb_11fcfc6ee5f1_1.png" alt="img"></a></p>
<p>Redis 自身实现的字符串结构有如下特点 :</p>
<ul>
<li>O(1) 时间复杂度获取：字符串长度，已用长度，未用长度。</li>
<li>可用于保存字节数组，支持安全的二进制数据存储。</li>
<li>内部实现空间预分配机制，降低内存再分配次数。</li>
<li>惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。</li>
</ul>
<h3 id="2-预分配机制"><a href="#2-预分配机制" class="headerlink" title="2. 预分配机制"></a>2. 预分配机制</h3><p>因为字符串 (SDS) 存在预分配机制，日常开发中要小心预分配带来的内存浪费，例如下表的测试用例。</p>
<h4 id="表：字符串内存预分配测试"><a href="#表：字符串内存预分配测试" class="headerlink" title="表：字符串内存预分配测试"></a>表：字符串内存预分配测试</h4><table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">数据量</th>
<th align="left">操作说明</th>
<th align="left">命令</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">used_mem</th>
<th align="left">used_memory_rss</th>
<th align="left">mem_fragmentation_ratio</th>
</tr>
</thead>
<tbody><tr>
<td align="left">阶段 1</td>
<td align="left">200w</td>
<td align="left">新插入 200w 数据</td>
<td align="left">set</td>
<td align="left">20 字节</td>
<td align="left">60 字节</td>
<td align="left">321.98MB</td>
<td align="left">331.44MB</td>
<td align="left">1.02</td>
</tr>
<tr>
<td align="left">阶段 2</td>
<td align="left">200w</td>
<td align="left">在阶段 1 上每个对象追加 60 字节数据</td>
<td align="left">append</td>
<td align="left">20 字节</td>
<td align="left">60 字节</td>
<td align="left">657.67MB</td>
<td align="left">752.80MB</td>
<td align="left">1.14</td>
</tr>
<tr>
<td align="left">阶段 3</td>
<td align="left">200w</td>
<td align="left">重新插入 200w 数据</td>
<td align="left">set</td>
<td align="left">20 字节</td>
<td align="left">120 字节</td>
<td align="left">474.56MB</td>
<td align="left">482.45MB</td>
<td align="left">1.02</td>
</tr>
</tbody></table>
<p>从测试数据可以看出，同样的数据追加后内存消耗非常严重，下面我们结合图来分析这一现象。阶段 1 每个字符串对象空间占用如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i3.itc.cn/20170216/3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png"><img src="http://i3.itc.cn/20170216/3084_348deb09_9394_4809_f74f_638d4a8cc902_1.png" alt="img"></a></p>
<p>阶段 1 插入新的字符串后，free 字段保留空间为 0，总占用空间 &#x3D; 实际占用空间+1 字节，最后 1 字节保存‘\0’标示结尾，这里忽略 int 类型 len 和 free 字段消耗的 8 字节。在阶段 1 原有字符串上追加 60 字节数据空间占用如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i2.itc.cn/20170216/3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png"><img src="http://i2.itc.cn/20170216/3084_ea8adf90_7c43_cff3_2bf8_7426f0fa60de_1.png" alt="img"></a></p>
<p>追加操作后字符串对象预分配了一倍容量作为预留空间，而且大量追加操作需要内存重新分配，造成内存碎片率 (mem_fragmentation_ratio) 上升。直接插入与阶段 2 相同数据的空间占用，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i1.itc.cn/20170216/3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png"><img src="http://i1.itc.cn/20170216/3084_0a3583f6_57d1_9c73_95b9_13bd067bc3c9_1.png" alt="img"></a></p>
<p>阶段 3 直接插入同等数据后，相比阶段 2 节省了每个字符串对象预分配的空间，同时降低了碎片率。<br>字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。字符串预分配每次并不都是翻倍扩容，空间预分配规则如下 :</p>
<ul>
<li>第一次创建 len 属性等于数据实际大小，free 等于 0，不做预分配。</li>
<li>修改后如果已有 free 空间不够且数据小于 1M，每次预分配一倍容量。如原有 len&#x3D;60byte，free&#x3D;0，再追加 60byte，预分配 120byte，总占用空间 :60byte+60byte+120byte+1byte。</li>
<li>修改后如果已有 free 空间不够且数据大于 1MB，每次预分配 1MB 数据。如原有 len&#x3D;30MB，free&#x3D;0，当再追加 100byte , 预分配 1MB，总占用空间 :1MB+100byte+1MB+1byte。<br>开发提示 : 尽量减少字符串频繁修改操作如 append，setrange, 改为直接使用 set 修改字符串，降低预分配带来的内存浪费和内存碎片化。</li>
</ul>
<h3 id="3-字符串重构"><a href="#3-字符串重构" class="headerlink" title="3. 字符串重构"></a>3. 字符串重构</h3><p>字符串重构 : 指不一定把每份数据作为字符串整体存储，像 json 这样的数据可以使用 hash 结构，使用二级结构存储也能帮我们节省内存。同时可以使用 hmget,hmset 命令支持字段的部分读取修改，而不用每次整体存取。例如下面的 json 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;vid&quot;: &quot;413368768&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;搜狐屌丝男士&quot;,</span><br><span class="line">    &quot;videoAlbumPic&quot;: &quot;http://photocdn.sohu.com/60160518/vrsa_ver8400079_ae433_pic26.jpg&quot;,</span><br><span class="line">    &quot;pid&quot;: &quot;6494271&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;1024&quot;,</span><br><span class="line">    &quot;playlist&quot;: &quot;6494271&quot;,</span><br><span class="line">    &quot;playTime&quot;: &quot;468&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别使用字符串和 hash 结构测试内存表现，如下表所示。</p>
<h4 id="表：测试内存表现"><a href="#表：测试内存表现" class="headerlink" title="表：测试内存表现"></a>表：测试内存表现</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key</th>
<th align="left">存储类型</th>
<th align="left">value</th>
<th align="left">配置</th>
<th align="left">used_mem</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">string</td>
<td align="left">json 字符串</td>
<td align="left">默认</td>
<td align="left">612.62M</td>
</tr>
<tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">hash</td>
<td align="left">key-value 对</td>
<td align="left">默认</td>
<td align="left">默认 1.88GB</td>
</tr>
<tr>
<td align="left">200W</td>
<td align="left">20 字节</td>
<td align="left">hash</td>
<td align="left">key-value 对</td>
<td align="left">hash-max-ziplist-value:66</td>
<td align="left">535.60M</td>
</tr>
</tbody></table>
<p>根据测试结构，第一次默认配置下使用 hash 类型，内存消耗不但没有降低反而比字符串存储多出 2 倍，而调整 hash-max-ziplist-value&#x3D;66 之后内存降低为 535.60M。因为 json 的 videoAlbumPic 属性长度是 65，而 hash-max-ziplist-value 默认值是 64，Redis 采用 hashtable 编码方式，反而消耗了大量内存。调整配置后 hash 类型内部编码方式变为 ziplist，相比字符串更省内存且支持属性的部分操作。下一节将具体介绍 ziplist 编码优化细节。</p>
<h2 id="五-编码优化"><a href="#五-编码优化" class="headerlink" title="五 . 编码优化"></a>五 . 编码优化</h2><h3 id="1-了解编码"><a href="#1-了解编码" class="headerlink" title="1. 了解编码"></a>1. 了解编码</h3><p>Redis 对外提供了 string,list,hash,set,zet 等类型，但是 Redis 内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。使用 object encoding {key} 命令获取编码类型。如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set str:1 hello</span><br><span class="line">OK</span><br><span class="line">redis&gt; object encoding str:1</span><br><span class="line">&quot;embstr&quot; // embstr编码字符串</span><br><span class="line">redis&gt; lpush list:1 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;ziplist&quot; // ziplist编码列表</span><br></pre></td></tr></table></figure>

<p>Redis 针对每种数据类型 (type) 可以采用至少两种编码方式来实现，下表表示 type 和 encoding 的对应关系。</p>
<h4 id="表：type-和-encoding-对应关系表"><a href="#表：type-和-encoding-对应关系表" class="headerlink" title="表：type 和 encoding 对应关系表"></a>表：type 和 encoding 对应关系表</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码方式</th>
<th align="left">数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">raw embstr int</td>
<td align="left">动态字符串编码 优化内存分配的字符串编码 整数编码</td>
</tr>
<tr>
<td align="left">hash</td>
<td align="left">hashtable ziplist</td>
<td align="left">散列表编码 压缩列表编码</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">linkedlist ziplist quicklist</td>
<td align="left">双向链表编码 压缩列表编码 3.2 版本新的列表编码</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">hashtable intset</td>
<td align="left">散列表编码 整数集合编码</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">skiplist ziplist</td>
<td align="left">跳跃表编码 压缩列表编码</td>
</tr>
</tbody></table>
<p>了解编码和类型对应关系之后，我们不禁疑惑 Redis 为什么需要对一种数据结构实现多种编码方式？<br>主要原因是 Redis 作者想通过不同编码实现效率和空间的平衡。比如当我们的存储只有 10 个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要 : 前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表 (ziplist)，将会节省大量内存，而由于数据长度较小，存取操作时间复杂度即使为 O(n2) 性能也可满足需求。</p>
<h3 id="2-控制编码类型"><a href="#2-控制编码类型" class="headerlink" title="2. 控制编码类型"></a>2. 控制编码类型</h3><p>编码类型转换在 Redis 写入数据时自动完成，这个转换过程是不可逆的，转换规则只能从小内存编码向大内存编码转换。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush list:1 a b c d</span><br><span class="line">(integer) 4 //存储4个元素</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;ziplist&quot; //采用ziplist压缩列表编码</span><br><span class="line">redis&gt; config set list-max-ziplist-entries 4</span><br><span class="line">OK //设置列表类型ziplist编码最大允许4个元素</span><br><span class="line">redis&gt; lpush list:1 e</span><br><span class="line">(integer) 5 //写入第5个元素e</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;linkedlist&quot; //编码类型转换为链表</span><br><span class="line">redis&gt; rpop list:1</span><br><span class="line">&quot;a&quot; //弹出元素a</span><br><span class="line">redis&gt; llen list:1</span><br><span class="line">(integer) 4 // 列表此时有4个元素</span><br><span class="line">redis&gt; object encoding list:1</span><br><span class="line">&quot;linkedlist&quot; //编码类型依然为链表，未做编码回退</span><br></pre></td></tr></table></figure>

<p>以上命令体现了 list 类型编码的转换过程，其中 Redis 之所以不支持编码回退，主要是数据增删频繁时，数据向压缩编码转换非常消耗 CPU，得不偿失。以上示例用到了 list-max-ziplist-entries 参数，这个参数用来决定列表长度在多少范围内使用 ziplist 编码。当然还有其它参数控制各种数据类型的编码，如下表所示：</p>
<h4 id="表：hash-list-set-zset-内部编码配置"><a href="#表：hash-list-set-zset-内部编码配置" class="headerlink" title="表：hash,list,set,zset 内部编码配置"></a>表：hash,list,set,zset 内部编码配置</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码</th>
<th align="left">决定条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">ziplist</td>
<td align="left">满足所有条件 : value 最大空间 (字节)&lt;&#x3D;hash-max-ziplist-value field 个数 &lt;&#x3D;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">hashtable</td>
<td align="left">满足任意条件 : value 最大空间 (字节)&gt;hash-max-ziplist-value field 个数 &gt;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">ziplist</td>
<td align="left">ziplist 满足所有条件 : value 最大空间 (字节)&lt;&#x3D;list-max-ziplist-value 链表长度 &lt;&#x3D;list-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">linkedlist</td>
<td align="left">满足任意条件 value 最大空间 (字节)&gt;list-max-ziplist-value 链表长度 &gt;list-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">quicklist</td>
<td align="left">3.2 版本新编码 : 废弃 list-max-ziplist-entries 和 list-max-ziplist-entries 配置 使用新配置 :  list-max-ziplist-size: 表示最大压缩空间或长度 , 最大空间使用 [-5-1] 范围配置，默认-2 表示 8KB, 正整数表示最大压缩长度 list-compress-depth: 表示最大压缩深度，默认 &#x3D;0 不压缩</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">intset</td>
<td align="left">满足所有条件 : 元素必须为整数 集合长度 &lt;&#x3D;set-max-intset-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">hashtable</td>
<td align="left">满足任意条件 元素非整数类型 集合长度 &gt;hash-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">ziplist</td>
<td align="left">满足所有条件 : value 最大空间 (字节)&lt;&#x3D;zset-max-ziplist-value 有序集合长度 &lt;&#x3D;zset-max-ziplist-entries</td>
</tr>
<tr>
<td align="left">同上</td>
<td align="left">skiplist</td>
<td align="left">满足任意条件 : value 最大空间 (字节)&gt;zset-max-ziplist-value 有序集合长度 &gt;zset-max-ziplist-entries</td>
</tr>
</tbody></table>
<p>掌握编码转换机制，对我们通过编码来优化内存使用非常有帮助。下面以 hash 类型为例，介绍编码转换的运行流程，如下图所示。</p>
<p>掌握编码转换机制，对我们通过编码来优化内存使用非常有帮助。下面以 hash 类型为例，介绍编码转换的运行流程，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i2.itc.cn/20170216/3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png"><img src="http://i2.itc.cn/20170216/3084_706c9e3a_9b61_95c5_69ac_f46b88d41bc5_1.png" alt="img"></a></p>
<p>理解编码转换流程和相关配置之后，可以使用 config set 命令设置编码相关参数来满足使用压缩编码的条件。对于已经采用非压缩编码类型的数据如 hashtable,linkedlist 等，设置参数后即使数据满足压缩编码条件，Redis 也不会做转换，需要重启 Redis 重新加载数据才能完成转换。</p>
<h3 id="3-ziplist-编码"><a href="#3-ziplist-编码" class="headerlink" title="3.ziplist 编码"></a>3.ziplist 编码</h3><p>ziplist 编码主要目的是为了节约内存，因此所有数据都是采用线性连续的内存结构。ziplist 编码是应用范围最广的一种，可以分别作为 hash、list、zset 类型的底层数据结构实现。首先从 ziplist 编码结构开始分析，它的内部结构类似这样 :&lt;….&gt;。一个 ziplist 可以包含多个 entry(元素)，每个 entry 保存具体的数据 (整数或者字节数组)，内部结构如下图所示。</p>
<p><a target="_blank" rel="noopener" href="http://i1.itc.cn/20170216/3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png"><img src="http://i1.itc.cn/20170216/3084_8e48faac_2a3e_51f4_d602_1fb45a002892_1.png" alt="img"></a></p>
<p>ziplist 结构字段含义：</p>
<ul>
<li>zlbytes: 记录整个压缩列表所占字节长度，方便重新调整 ziplist 空间。类型是 int-32，长度为 4 字节</li>
<li>zltail: 记录距离尾节点的偏移量，方便尾节点弹出操作。类型是 int-32，长度为 4 字节</li>
<li>zllen: 记录压缩链表节点数量，当长度超过 216-2 时需要遍历整个列表获取长度，一般很少见。类型是 int-16，长度为 2 字节</li>
<li>entry: 记录具体的节点，长度根据实际存储的数据而定。<ul>
<li>prev_entry_bytes_length: 记录前一个节点所占空间，用于快速定位上一个节点，可实现列表反向迭代。</li>
<li>encoding: 标示当前节点编码和长度，前两位表示编码类型：字符串 &#x2F; 整数，其余位表示数据长度。 </li>
<li>contents: 保存节点的值，针对实际数据长度做内存占用优化。</li>
</ul>
</li>
<li>zlend: 记录列表结尾，占用一个字节。</li>
</ul>
<p>根据以上对 ziplist 字段说明，可以分析出该数据结构特点如下 :</p>
<ul>
<li>内部表现为数据紧凑排列的一块连续内存数组。</li>
<li>可以模拟双向链表结构，以 O(1) 时间复杂度入队和出队。</li>
<li>新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。</li>
<li>读写操作涉及复杂的指针移动，最坏时间复杂度为 O(n2)。</li>
<li>适合存储小对象和长度有限的数据。</li>
</ul>
<p>下面通过测试展示 ziplist 编码在不同类型中内存和速度的表现，如下表所示。 </p>
<h4 id="表：ziplist-在-hash-list-zset-内存和速度测试"><a href="#表：ziplist-在-hash-list-zset-内存和速度测试" class="headerlink" title="表：ziplist 在 hash,list,zset 内存和速度测试"></a>表：ziplist 在 hash,list,zset 内存和速度测试</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">数据量</th>
<th align="left">key 总数量</th>
<th align="left">长度</th>
<th align="left">value 大小</th>
<th align="left">普通编码内存量 &#x2F; 平均耗时</th>
<th align="left">压缩编码内存量 &#x2F; 平均耗时</th>
<th align="left">内存降低比例</th>
<th align="left">耗时增长倍数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">103.37M&#x2F;0.84 微秒</td>
<td align="left">43.83M&#x2F;13.24 微秒</td>
<td align="left">57.5%</td>
<td align="left">15 倍</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">92.46M&#x2F;2.04 微秒</td>
<td align="left">39.92M&#x2F;5.45 微秒</td>
<td align="left">56.8%</td>
<td align="left">2.5 倍</td>
</tr>
<tr>
<td align="left">zset</td>
<td align="left">100 万</td>
<td align="left">1 千</td>
<td align="left">1 千</td>
<td align="left">36 字节</td>
<td align="left">151.84M&#x2F;1.85 微秒</td>
<td align="left">43.83M&#x2F;77.88 微秒</td>
<td align="left">71%</td>
<td align="left">42 倍</td>
</tr>
</tbody></table>
<p>测试数据采用 100W 个 36 字节数据，划分为 1000 个键，每个类型长度统一为 1000。从测试结果可以看出：</p>
<ul>
<li>使用 ziplist 可以分别作为 hash,list,zset 数据类型实现。</li>
<li>使用 ziplist 编码类型可以大幅降低内存占用。</li>
<li>ziplist 实现的数据类型相比原生结构，命令操作更加耗时，不同类型耗时排序 :list &lt; hash &lt; zset。<br>ziplist 压缩编码的性能表现跟值长度和元素个数密切相关，正因为如此 Redis 提供了{type}-max-ziplist-value 和{type}-max-ziplist-entries 相关参数来做控制 ziplist 编码转换。最后再次强调使用 ziplist 压缩编码的原则：追求空间和时间的平衡。<br>开发提示：</li>
<li>针对性能要求较高的场景使用 ziplist，建议长度不要超过 1000，每个元素大小控制在 512 字节以内。</li>
<li>命令平均耗时使用 info Commandstats 命令获取，包含每个命令调用次数，总耗时，平均耗时，单位微秒。</li>
</ul>
<h3 id="4-intset-编码"><a href="#4-intset-编码" class="headerlink" title="4.intset 编码"></a>4.intset 编码</h3><p>intset 编码是集合 (set) 类型编码的一种，内部表现为存储有序，不重复的整数集。当集合只包含整数且长度不超过 set-max-intset-entries 配置时被启用。执行以下命令查看 intset 表现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set:test 3 4 2 6 8 9 2</span><br><span class="line">(integer) 6 //乱序写入6个整数</span><br><span class="line">127.0.0.1:6379&gt; object encoding set:test</span><br><span class="line">&quot;intset&quot; //使用intset编码</span><br><span class="line">127.0.0.1:6379&gt; smembers set:test</span><br><span class="line">&quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; &quot;9&quot; // 排序输出整数结合</span><br><span class="line">redis&gt; config set set-max-intset-entries 6</span><br><span class="line">OK //设置intset最大允许整数长度</span><br><span class="line">redis&gt; sadd set:test 5</span><br><span class="line">(integer) 1 //写入第7个整数 5</span><br><span class="line">redis&gt; object encoding set:test</span><br><span class="line">&quot;hashtable&quot; // 编码变为hashtable</span><br><span class="line">redis&gt; smembers set:test</span><br><span class="line">&quot;8&quot; &quot;3&quot; &quot;5&quot; &quot;9&quot; &quot;4&quot; &quot;2&quot; &quot;6&quot; //乱序输出</span><br></pre></td></tr></table></figure>

<p>以上命令可以看出 intset 对写入整数进行排序，通过 O(log(n)) 时间复杂度实现查找和去重操作，intset 编码结构如下图所示。<br><a target="_blank" rel="noopener" href="http://i1.itc.cn/20170216/3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png"><img src="http://i1.itc.cn/20170216/3084_5417a9b7_6050_0614_09f1_ce8565f04eca_1.png" alt="img"></a></p>
<p>intset 的字段结构含义：</p>
<ul>
<li>encoding: 整数表示类型，根据集合内最长整数值确定类型，整数类型划分三种 :int-16，int-32，int-64。</li>
<li>length: 表示集合元素个数。</li>
<li>contents: 整数数组，按从小到大顺序保存。<br>intset 保存的整数类型根据长度划分，当保存的整数超出当前类型时，将会触发自动升级操作且升级后不再做回退。升级操作将会导致重新申请内存空间，把原有数据按转换类型后拷贝到新数组。<br>开发提示：使用 intset 编码的集合时，尽量保持整数范围一致，如都在 int-16 范围内。防止个别大整数触发集合升级操作，产生内存浪费。<br>下面通过测试查看 ziplist 编码的集合内存和速度表现，如下表所示。</li>
</ul>
<h4 id="表：ziplist-编码在-set-下内存和速度表现"><a href="#表：ziplist-编码在-set-下内存和速度表现" class="headerlink" title="表：ziplist 编码在 set 下内存和速度表现"></a>表：ziplist 编码在 set 下内存和速度表现</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">编码</th>
<th align="left">集合长度</th>
<th align="left">内存量</th>
<th align="left">内存降低比例</th>
<th align="left">平均耗时</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">hashtable</td>
<td align="left">1 千</td>
<td align="left">61.97MB</td>
<td align="left">–</td>
<td align="left">0.78 毫秒</td>
</tr>
<tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">intset</td>
<td align="left">1 千</td>
<td align="left">4.77MB</td>
<td align="left">92.6%</td>
<td align="left">0.51 毫秒</td>
</tr>
<tr>
<td align="left">100w</td>
<td align="left">20byte</td>
<td align="left">7 字节</td>
<td align="left">ziplist</td>
<td align="left">1 千</td>
<td align="left">8.67MB</td>
<td align="left">86.2%</td>
<td align="left">13.12 毫秒</td>
</tr>
</tbody></table>
<p>根据以上测试结果发现 intset 表现非常好，同样的数据内存占用只有不到 hashtable 编码的十分之一。intset 数据结构插入命令复杂度为 O(n)，查询命令为 O(log(n))，由于整数占用空间非常小，所以在集合长度可控的基础上，写入命令执行速度也会非常快，因此当使用整数集合时尽量使用 intset 编码。上表测试第三行把 ziplist-hash 类型也放入其中，主要因为 intset 编码必须存储整数，当集合内保存非整数数据时，无法使用 intset 实现内存优化。这时可以使用 ziplist-hash 类型对象模拟集合类型，hash 的 field 当作集合中的元素，value 设置为 1 字节占位符即可。使用 ziplist 编码的 hash 类型依然比使用 hashtable 编码的集合节省大量内存。</p>
<h2 id="六-控制-key-的数量"><a href="#六-控制-key-的数量" class="headerlink" title="六 控制 key 的数量"></a>六 控制 key 的数量</h2><p>当使用 Redis 存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis 本质是一个数据结构服务器，它为我们提供多种数据结构，如 hash，list，set，zset 等结构。使用 Redis 时不要进入一个误区，大量使用 get&#x2F;set 这样的 API，把 Redis 当成 Memcached 使用。对于存储相同的数据内容利用 Redis 的数据结构降低外层键的数量，也可以节省大量内存。如下图所示，通过在客户端预估键规模，把大量键分组映射到多个 hash 结构中降低键的数量。</p>
<p><a target="_blank" rel="noopener" href="http://i1.itc.cn/20170216/3084_d48315af_6789_08d6_823d_beec6378e7da_1.png"><img src="http://i1.itc.cn/20170216/3084_d48315af_6789_08d6_823d_beec6378e7da_1.png" alt="img"></a></p>
<p>hash 结构降低键数量分析：</p>
<ul>
<li>根据键规模在客户端通过分组映射到一组 hash 对象中，如存在 100 万个键，可以映射到 1000 个 hash 中，每个 hash 保存 1000 个元素。</li>
<li>hash 的 field 可用于记录原始 key 字符串，方便哈希查找。</li>
<li>hash 的 value 保存原始值对象，确保不要超过 hash-max-ziplist-value 限制。<br>下面测试这种优化技巧的内存表现，如下表所示。</li>
</ul>
<h4 id="表：hash-分组控制键规模测试"><a href="#表：hash-分组控制键规模测试" class="headerlink" title="表：hash 分组控制键规模测试"></a>表：hash 分组控制键规模测试</h4><table>
<thead>
<tr>
<th align="left">数据量</th>
<th align="left">key 大小</th>
<th align="left">value 大小</th>
<th align="left">string 类型占用内存</th>
<th align="left">hash-ziplist 类型占用内存</th>
<th align="left">内存降低比例</th>
<th align="left">string:set 平均耗时</th>
<th align="left">hash:hset 平均耗时</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">512byte</td>
<td align="left">1392.64MB</td>
<td align="left">1000.97MB</td>
<td align="left">28.1%</td>
<td align="left">2.13 微秒</td>
<td align="left">21.28 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">200byte</td>
<td align="left">596.62MB</td>
<td align="left">399.38MB</td>
<td align="left">33.1%</td>
<td align="left">1.49 微秒</td>
<td align="left">16.08 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">100byte</td>
<td align="left">382.99MB</td>
<td align="left">211.88MB</td>
<td align="left">44.6%</td>
<td align="left">1.30 微秒</td>
<td align="left">14.92 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">50byte</td>
<td align="left">291.46MB</td>
<td align="left">110.32MB</td>
<td align="left">62.1%</td>
<td align="left">1.28 微秒</td>
<td align="left">13.48 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">20byte</td>
<td align="left">246.40MB</td>
<td align="left">55.63MB</td>
<td align="left">77.4%</td>
<td align="left">1.10 微秒</td>
<td align="left">13.21 微秒</td>
</tr>
<tr>
<td align="left">200w</td>
<td align="left">20byte</td>
<td align="left">5byte</td>
<td align="left">199.93MB</td>
<td align="left">24.42MB</td>
<td align="left">87.7%</td>
<td align="left">1.10 微秒</td>
<td align="left">13.06 微秒</td>
</tr>
</tbody></table>
<p>通过这个测试数据，可以说明：</p>
<ul>
<li>同样的数据使用 ziplist 编码的 hash 类型存储比 string 类型节约内存</li>
<li>节省内存量随着 value 空间的减少，越来越明显。</li>
<li>hash-ziplist 类型比 string 类型写入耗时，但随着 value 空间的减少，耗时逐渐降低。<br>使用 hash 重构后节省内存量效果非常明显，特变对于存储小对象的场景，内存只有不到原来的 1&#x2F;5。下面分析这种内存优化技巧的关键点：<ul>
<li>hash 类型节省内存的原理是使用 ziplist 编码，如果使用 hashtable 编码方式反而会增加内存消耗。</li>
<li>ziplist 长度需要控制在 1000 以内，否则由于存取操作时间复杂度在 O(n) 到 O(n2) 之间，长列表会导致 CPU 消耗严重，得不偿失。</li>
<li>ziplist 适合存储的小对象，对于大对象不但内存优化效果不明显还会增加命令操作耗时。</li>
<li>需要预估键的规模，从而确定每个 hash 结构需要存储的元素数量。</li>
<li>根据 hash 长度和元素大小，调整 hash-max-ziplist-entries 和 hash-max-ziplist-value 参数，确保 hash 类型使用 ziplist 编码。</li>
</ul>
</li>
</ul>
<p>关于 hash 键和 field 键的设计：</p>
<ul>
<li>当键离散度较高时，可以按字符串位截取，把后三位作为哈希的 field，之前部分作为哈希的键。如：key&#x3D;1948480 哈希 key&#x3D;group:hash:1948，哈希 field&#x3D;480。</li>
<li>当键离散度较低时，可以使用哈希算法打散键，如 : 使用 crc32(key)&amp;10000 函数把所有的键映射到“0-9999”整数范围内，哈希 field 存储键的原始值。</li>
<li>尽量减少 hash 键和 field 的长度，如使用部分键内容。</li>
</ul>
<p>使用 hash 结构控制键的规模虽然可以大幅降低内存，但同样会带来问题，需要提前做好规避处理。如下 :</p>
<ol>
<li>客户端需要预估键的规模并设计 hash 分组规则，加重客户端开发成本。</li>
<li>hash 重构后所有的键无法再使用超时 (expire) 和 LRU 淘汰机制自动删除，需要手动维护删除。</li>
<li>对于大对象，如 1KB 以上的对象。使用 hash-ziplist 结构控制键数量。<br>不过瑕不掩瑜，对于大量小对象的存储场景，非常适合使用 ziplist 编码的 hash 类型控制键的规模来降低内存。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发提示：使用ziplist+hash优化keys后，如果想使用超时删除功能，开发人员可以存储每个对象写入的时间，再通过定时任务使用hscan命令扫描数据，找出hash内超时的数据项删除即可。</span><br></pre></td></tr></table></figure>

<p>本文主要讲解 Redis 内存优化技巧，Redis 的数据特性是 “ALL IN MEMORY”，优化内存将变得非常重要。对于内存优化建议读者先要掌握 Redis 内存存储的特性比如字符串，压缩编码，整数集合等，再根据数据规模和所用命令需求去调整，从而达到空间和效率的最佳平衡。建议使用 Redis 存储大量数据时，把内存优化环节加入到前期设计阶段，否则数据大幅增长后，开发人员需要面对重新优化内存所带来开发和数据迁移的双重成本。当 Redis 内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化。当遇到瓶颈时，再去考虑水平扩展。即使对于集群化方案，垂直层面优化也同样重要，避免不必要的资源浪费和集群化后的管理成本。</p>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/12/backoff-strategy.html" rel="prev" title="退避策略">
                  <i class="fa fa-chevron-left"></i> 退避策略
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/11/use-error-codes-gracefully.html" rel="next" title="优雅使用错误码">
                  优雅使用错误码 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">0x4096</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">116k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:45</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

  <div class="powered-by">
      <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"> 
         <image src="https://cdn.0x4096.com/cdn/image/ypy.jpeg" width="300px" />
      </a>
  </div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
