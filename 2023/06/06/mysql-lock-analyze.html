<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tech.0x4096.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.11.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SQL语句加锁分析">
<meta property="og:type" content="article">
<meta property="og:title" content="「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析">
<meta property="og:url" content="https://tech.0x4096.com/2023/06/06/mysql-lock-analyze.html">
<meta property="og:site_name" content="0x4096">
<meta property="og:description" content="SQL语句加锁分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062248634.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062249327.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062250297.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062251380.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062251753.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062252725.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062252968.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062252189.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062253940.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062253613.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062253623.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062253509.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062254519.png">
<meta property="og:image" content="https://cdn.0x4096.com/cdn/image/202306062254924.png">
<meta property="article:published_time" content="2023-06-06T14:14:46.000Z">
<meta property="article:modified_time" content="2023-06-06T14:14:46.000Z">
<meta property="article:author" content="0x4096">
<meta property="article:tag" content="经验">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.0x4096.com/cdn/image/202306062248634.png">


<link rel="canonical" href="https://tech.0x4096.com/2023/06/06/mysql-lock-analyze.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tech.0x4096.com/2023/06/06/mysql-lock-analyze.html","path":"2023/06/06/mysql-lock-analyze.html","title":"「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析 | 0x4096</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?966d9db328492be47a2e40d36f047046"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<style type="text/css">
  code {
    color: red;
    background: #F0F0EC;
    margin: 0 5px;
    padding: 3px 5px;
    border: 0px solid #ddd;
  }
</style>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">0x4096</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">0x4096的技术分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">15</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">一、基本的加锁规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95-SQL-%E7%9A%84%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">二、简单 SQL 的加锁分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 聚簇索引，查询命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 聚簇索引，查询未命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BA%8C%E7%BA%A7%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 二级唯一索引，查询命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BA%8C%E7%BA%A7%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 二级唯一索引，查询未命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E4%BA%8C%E7%BA%A7%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 二级非唯一索引，查询命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%BA%8C%E7%BA%A7%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 二级非唯一索引，查询未命中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 无索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 聚簇索引，范围查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 二级索引，范围查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95%E5%80%BC"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 修改索引值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">三、复杂条件加锁分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81DELETE-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">四、DELETE 语句加锁分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81INSERT-%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-number">5.</span> <span class="nav-text">五、INSERT 语句加锁分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="0x4096"
      src="https://cdn.0x4096.com//cdn/image/007S8ZIlgy1gja6idxwudj30hs0hsq3e.jpg">
  <p class="site-author-name" itemprop="name">0x4096</p>
  <div class="site-description" itemprop="description">求知若饥 虚心若愚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/0x4096" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;0x4096" rel="noopener" target="_blank">GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://jm.taobao.org/" title="http:&#x2F;&#x2F;jm.taobao.org&#x2F;" rel="noopener" target="_blank">阿里中间件团队博客</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tech.0x4096.com/2023/06/06/mysql-lock-analyze.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.0x4096.com//cdn/image/007S8ZIlgy1gja6idxwudj30hs0hsq3e.jpg">
      <meta itemprop="name" content="0x4096">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="0x4096">
      <meta itemprop="description" content="求知若饥 虚心若愚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析 | 0x4096">
      <meta itemprop="description" content="SQL语句加锁分析">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「转载」解决死锁之路3 - 常见-SQL-语句的加锁分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">


   <!-- 置顶 -->
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-06 22:14:46" itemprop="dateCreated datePublished" datetime="2023-06-06T22:14:46+08:00">2023-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>


          <!--
            <div class="post-description">SQL语句加锁分析</div>
          -->
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>转载：<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html">https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html</a></p>
</blockquote>
<p>这篇博客将对一些常见的 SQL 语句进行加锁分析，看看我们平时执行的那些 SQL 都会加什么锁。只有对我们所写的 SQL 语句加锁过程了如指掌，才能在遇到死锁问题时倒推出是什么锁导致的问题。在前面的博客中我们已经学习了 MySQL 下不同的锁模式和锁类型，我们要特别注意它们的兼容矩阵，熟悉哪些锁是不兼容的，这些不兼容的锁往往就是导致死锁的罪魁祸首。总体来说，MySQL 中的锁可以分成两个粒度：表锁和行锁，表锁有：表级读锁，表级写锁，读意向锁，写意向锁，自增锁；行锁有：读记录锁，写记录锁，间隙锁，Next-key 锁，插入意向锁。不出意外，绝大多数的死锁问题都是由这些锁之间的冲突导致的。</p>
<p>我们知道，不同的隔离级别加锁也是不一样的，譬如 RR 隔离级别下有间隙锁和 Next-key 锁，这在 RC 隔离级别下是没有的（也有例外），所以在对 SQL 进行加锁分析时，必须得知道数据库的隔离级别。由于 RR 和 RC 用的比较多，所以这篇博客只对这两种隔离级别做分析。</p>
<p>这是《解决死锁之路》系列博文中的一篇，你还可以阅读其他几篇：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">学习事务与隔离级别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">了解常见的锁类型</a></li>
<li>掌握常见 SQL 语句的加锁分析</li>
<li><a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">死锁问题的分析和解决</a></li>
</ol>
<h2 id="一、基本的加锁规则"><a href="#一、基本的加锁规则" class="headerlink" title="一、基本的加锁规则"></a>一、基本的加锁规则</h2><p>虽然 MySQL 的锁各式各样，但是有些基本的加锁原则是保持不变的，譬如：快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁的等等。这些规则整理如下，后面就不再重复介绍了： </p>
<ul>
<li>常见语句的加锁<ul>
<li>SELECT … 语句正常情况下为快照读，不加锁；</li>
<li>SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁；</li>
<li>SELECT … FOR UPDATE 语句为当前读，加 X 锁；</li>
<li>常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；</li>
<li>常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚；</li>
</ul>
</li>
<li>表锁<ul>
<li>表锁（分 S 锁和 X 锁）</li>
<li>意向锁（分 IS 锁和 IX 锁）</li>
<li>自增锁（一般见不到，只有在 innodb_autoinc_lock_mode &#x3D; 0 或者 Bulk inserts 时才可能有）</li>
</ul>
</li>
<li>行锁<ul>
<li>记录锁（分 S 锁和 X 锁）</li>
<li>间隙锁（分 S 锁和 X 锁）</li>
<li>Next-key 锁（分 S 锁和 X 锁）</li>
<li>插入意向锁</li>
</ul>
</li>
<li>行锁分析<ul>
<li>行锁都是加在索引上的，最终都会落在聚簇索引上；</li>
<li>加行锁的过程是一条一条记录加的；</li>
</ul>
</li>
<li>锁冲突<ul>
<li>S 锁和 S 锁兼容，X 锁和 X 锁冲突，X 锁和 S 锁冲突；</li>
<li>表锁和行锁的冲突矩阵参见前面的博客 <a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html">了解常见的锁类型</a>；</li>
</ul>
</li>
<li>不同隔离级别下的锁<ul>
<li>上面说 SELECT … 语句正常情况下为快照读，不加锁；但是在 Serializable 隔离级别下为当前读，加 S 锁；</li>
<li>RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）；</li>
<li>不同隔离级别下锁的区别，参见前面的博客 <a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html">学习事务与隔离级别</a>；</li>
</ul>
</li>
</ul>
<h2 id="二、简单-SQL-的加锁分析"><a href="#二、简单-SQL-的加锁分析" class="headerlink" title="二、简单 SQL 的加锁分析"></a>二、简单 SQL 的加锁分析</h2><p>何登成前辈在他的博客《MySQL 加锁处理分析》中对一些常见的 SQL 加锁进行了细致的分析，这篇博客可以说是网上介绍 MySQL 加锁分析的一个范本，网上几乎所有关于加锁分析的博客都是参考了这篇博客，勘称经典，强烈推荐。我这里也不例外，只是在他的基础上进行了一些整理和总结。</p>
<p>我们使用下面这张 students 表作为实例，其中 id 为主键，no（学号）为二级唯一索引，name（姓名）和 age（年龄）为二级非唯一索引，score（学分）无索引。 </p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062248634.png" alt="students-table.png"></p>
<p>这一节我们只分析最简单的一种 SQL，它只包含一个 WHERE 条件，等值查询或范围查询。虽然 SQL 非常简单，但是针对不同类型的列，我们还是会面对各种情况：</p>
<ul>
<li>聚簇索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：UPDATE students SET score &#x3D; 100 WHERE name &#x3D; ‘John’;</li>
<li>无索引：UPDATE students SET score &#x3D; 100 WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：UPDATE students SET score &#x3D; 100 WHERE age &lt;&#x3D; 23;</li>
<li>修改索引值：UPDATE students SET name &#x3D; ‘John’ WHERE id &#x3D; 15;</li>
</ul>
<h3 id="2-1-聚簇索引，查询命中"><a href="#2-1-聚簇索引，查询命中" class="headerlink" title="2.1 聚簇索引，查询命中"></a>2.1 聚簇索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE id = 15</code> 在 RC 和 RR 隔离级别下加锁情况一样，都是对 id 这个聚簇索引加 X 锁，如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062249327.png" alt="primary-index-locks.png"></p>
<h3 id="2-2-聚簇索引，查询未命中"><a href="#2-2-聚簇索引，查询未命中" class="headerlink" title="2.2 聚簇索引，查询未命中"></a>2.2 聚簇索引，查询未命中</h3><p>如果查询未命中纪录，在 RC 和 RR 隔离级别下加锁是不一样的，因为 RR 有 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE id = 16</code> 在 RC 和 RR 隔离级别下的加锁情况如下（RC 不加锁）：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062250297.png" alt="primary-index-locks-gap.png"></p>
<h3 id="2-3-二级唯一索引，查询命中"><a href="#2-3-二级唯一索引，查询命中" class="headerlink" title="2.3 二级唯一索引，查询命中"></a>2.3 二级唯一索引，查询命中</h3><p>语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0003&#39;</code> 命中二级唯一索引，上一篇博客中我们介绍了索引的结构，我们知道二级索引的叶子节点中保存了主键索引的位置，在给二级索引加锁的时候，主键索引也会一并加锁。这个在 RC 和 RR 两种隔离级别下没有区别：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062251380.png" alt="secondary-index-unique-locks.png"></p>
<p>那么，为什么主键索引上的记录也要加锁呢？因为有可能其他事务会根据主键对 students 表进行更新，如：<code>UPDATE students SET score = 100 WHERE id = 20</code>，试想一下，如果主键索引没有加锁，那么显然会存在并发问题。</p>
<h3 id="2-4-二级唯一索引，查询未命中"><a href="#2-4-二级唯一索引，查询未命中" class="headerlink" title="2.4 二级唯一索引，查询未命中"></a>2.4 二级唯一索引，查询未命中</h3><p>如果查询未命中纪录，和 2.2 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE no = &#39;S0008&#39;</code> 加锁情况如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062251753.png" alt="secondary-index-unique-locks-gap.png"></p>
<p>这种情况下只会在二级索引加锁，不会在聚簇索引上加锁。</p>
<h3 id="2-5-二级非唯一索引，查询命中"><a href="#2-5-二级非唯一索引，查询命中" class="headerlink" title="2.5 二级非唯一索引，查询命中"></a>2.5 二级非唯一索引，查询命中</h3><p>如果查询命中的是二级非唯一索引，在 RR 隔离级别下，还会加 GAP 锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;Tom&#39;</code>加锁如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252725.png" alt="secondary-index-non-unique-locks.png"></p>
<p>为什么非唯一索引会加 GAP 锁，而唯一索引不用加 GAP 锁呢？原因很简单，GAP 锁的作用是为了解决幻读，防止其他事务插入相同索引值的记录，而唯一索引和主键约束都已经保证了该索引值肯定只有一条记录，所以无需加 GAP 锁。</p>
<p>这里还有一点要注意一下，数一数右图中的锁你可能会觉得一共加了 7 把锁，实际情况不是，要注意的是 (Tom, 37) 上的记录锁和它前面的 GAP 锁合起来是一个 Next-key 锁，这个锁加在 (Tom, 37) 这个索引上，另外 (Tom, 49) 上也有一把 Next-key 锁。那么最右边的 GAP 锁加在哪呢？右边已经没有任何记录了啊。其实，在 InnoDb 存储引擎里，每个数据页中都会有两个虚拟的行记录，用来限定记录的边界，分别是：<code>Infimum Record</code> 和 <code>Supremum Record</code>，Infimum 是比该页中任何记录都要小的值，而 Supremum 比该页中最大的记录值还要大，这两条记录在创建页的时候就有了，并且不会删除。上面右边的 GAP 锁就是加在 Supremum Record 上。所以说，上面右图中共有 2 把 Next-key 锁，1 把 GAP 锁，2 把记录锁，一共 5 把锁。</p>
<h3 id="2-6-二级非唯一索引，查询未命中"><a href="#2-6-二级非唯一索引，查询未命中" class="headerlink" title="2.6 二级非唯一索引，查询未命中"></a>2.6 二级非唯一索引，查询未命中</h3><p>如果查询未命中纪录，和 2.2、2.4 情况一样，RR 隔离级别会加 GAP 锁，RC 无锁。语句 <code>UPDATE students SET score = 100 WHERE name = &#39;John&#39;</code> 加锁情况如下：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252968.png" alt="secondary-index-non-unique-locks-gap.png"></p>
<h3 id="2-7-无索引"><a href="#2-7-无索引" class="headerlink" title="2.7 无索引"></a>2.7 无索引</h3><p>如果 WHERE 条件不能走索引，MySQL 会如何加锁呢？有的人说会在表上加 X 锁，也有人说会根据 WHERE 条件将筛选出来的记录在聚簇索引上加上 X 锁，那么究竟如何，我们看下图：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062252189.png" alt="no-index-locks.png"></p>
<p>在没有索引的时候，只能走聚簇索引，对表中的记录进行全表扫描。在 RC 隔离级别下会给所有记录加行锁，在 RR 隔离级别下，不仅会给所有记录加行锁，所有聚簇索引和聚簇索引之间还会加上 GAP 锁。</p>
<p>语句 <code>UPDATE students SET score = 100 WHERE score = 22</code> 满足条件的虽然只有 1 条记录，但是聚簇索引上所有的记录，都被加上了 X 锁。那么，为什么不是只在满足条件的记录上加锁呢？这是由于 MySQL 的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 MySQL Server 层进行过滤，因此也就把所有的记录都锁上了。</p>
<p>不过在实际的实现中，MySQL 有一些改进，如果是 RC 隔离级别，在 MySQL Server 过滤条件发现不满足后，会调用 unlock_row 方法，把不满足条件的记录锁释放掉（违背了 2PL 的约束）。这样做可以保证最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。如果是 RR 隔离级别，一般情况下 MySQL 是不能这样优化的，除非设置了 <code>innodb_locks_unsafe_for_binlog</code> 参数，这时也会提前释放锁，并且不加 GAP 锁，这就是所谓的 <strong>semi-consistent read</strong>。</p>
<h3 id="2-8-聚簇索引，范围查询"><a href="#2-8-聚簇索引，范围查询" class="headerlink" title="2.8 聚簇索引，范围查询"></a>2.8 聚簇索引，范围查询</h3><p>上面所介绍的各种情况其实都是非常常见的 SQL，它们有一个特点：全部都只有一个 WHERE 条件，并且都是等值查询。那么问题来了，如果不是等值查询而是范围查询，加锁情况会怎么样呢？有人可能会觉得这很简单，根据上面的加锁经验，我们只要给查询范围内的所有记录加上锁即可，如果隔离级别是 RR，所有记录之间再加上间隙锁。事实究竟如何，我们看下面的图：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253940.png" alt="primary-index-range-locks.png"></p>
<p>SQL 语句为 <code>UPDATE students SET score = 100 WHERE id &lt;= 20</code>，按理说我们只需要将 id &#x3D; 20、18、15 三条记录锁住即可，但是看右边的图，在 RR 隔离级别下，我们还把 id &#x3D; 30 这条记录以及 (20, 30] 之间的间隙也锁起来了，很显然这是一个 Next-key 锁。如果 WHERE 条件是 id &lt; 20，则会把 id &#x3D; 20 这条记录锁住。为什么会这样我也不清楚，网上搜了很久，有人说是为了防止幻读，但 id 是唯一主键，(20, 30] 之间是不可能再插入一条 id &#x3D; 20 的，所以具体的原因还需要再分析下，如果你知道，还请不吝赐教。</p>
<p>所以对于范围查询，如果 WHERE 条件是 id &lt;&#x3D; N，那么 N 后一条记录也会被加上 Next-key 锁；如果条件是 id &lt; N，那么 N 这条记录会被加上 Next-key 锁。另外，如果 WHERE 条件是 id &gt;&#x3D; N，只会给 N 加上记录锁，以及给比 N 大的记录加锁，不会给 N 前一条记录加锁；如果条件是 id &gt; N，也不会锁前一条记录，连 N 这条记录都不会锁。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 11月26号补充 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>我在做实验的时候发现，在 RR 隔离级别，条件是 id &gt;&#x3D; 20，有时会对 id &lt; 20 的记录加锁，有时候又不加，感觉找不到任何规律，请以实际情况为准。我对范围查询的加锁原理还不是很明白，后面有时间再仔细研究下，也欢迎有兴趣的同学一起讨论下。</p>
<p>下面是我做的一个简单的实验，表很简单，只有一列主键 id：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show create table t1;</span><br><span class="line">+-------+--------------------------------------------+</span><br><span class="line">| Table | Create Table                               |</span><br><span class="line">+-------+--------------------------------------------+</span><br><span class="line">| t1    | CREATE TABLE `t1` (                        |</span><br><span class="line">|       |    `id` int(11) NOT NULL AUTO_INCREMENT,   |</span><br><span class="line">|       |    PRIMARY KEY (`id`)                      |</span><br><span class="line">|       | ) ENGINE=InnoDB DEFAULT CHARSET=utf8       |</span><br><span class="line">+-------+--------------------------------------------+</span><br></pre></td></tr></table></figure>



<p>表里一共三条数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">|  6 |</span><br><span class="line">+----+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>执行 <code>delete from t1 where id &gt; 2</code> 时加锁情况是：(2, 4], (4, 6], (6, +∞)<br>执行 <code>select * from t1 where id &gt; 2 for update</code> 时加锁情况是：(-∞, 2], (2, 4], (4, 6], (6, +∞)<br>可见 <strong>select for update</strong> 和 <strong>delete</strong> 的加锁还是有所区别的，至于 select for update 为什么加 (-∞, 2] 这个锁，我还是百思不得其解。后来无意中给表 t1 加了一个字段 a int(11) NOT NULL，竟然发现 <code>select * from t1 where id &gt; 2 for update</code> 就不会给 (-∞, 2] 加锁了，真的非常奇怪。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 12月3号补充 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>经过几天的搜索，终于找到了一个像样的解释（但不好去证实）：当数据表中数据非常少时，譬如上面那个的例子，select … [lock in share mode | for update] 语句会走全表扫描，这样表中所有记录都会被锁住，这就是 (-∞, 2] 被锁的原因。而 delete 语句并不会走全表扫描。</p>
<h3 id="2-9-二级索引，范围查询"><a href="#2-9-二级索引，范围查询" class="headerlink" title="2.9 二级索引，范围查询"></a>2.9 二级索引，范围查询</h3><p>然后我们把范围查询应用到二级非唯一索引上来，SQL 语句为：<code>UPDATE students SET score = 100 WHERE age &lt;= 23</code>，加锁情况如下图所示：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253613.png" alt="secondary-index-range-locks.png"></p>
<p>可以看出和聚簇索引的范围查询一样，除了 WHERE 条件范围内的记录加锁之外，后面一条记录也会加上 Next-key 锁，这里有意思的一点是，尽管满足 age &#x3D; 24 的记录有两条，但只有第一条被加锁，第二条没有加锁，并且第一条和第二条之间也没有加锁。</p>
<h3 id="2-10-修改索引值"><a href="#2-10-修改索引值" class="headerlink" title="2.10 修改索引值"></a>2.10 修改索引值</h3><p>这种情况比较容易理解，WHERE 部分的索引加锁原则和上面介绍的一样，多的是 SET 部分的加锁。譬如 <code>UPDATE students SET name = &#39;John&#39; WHERE id = 15</code> 不仅在 id &#x3D; 15 记录上加锁之外，还会在 name &#x3D; ‘Bob’（原值）和 name &#x3D; ‘John’（新值） 上加锁。示意图如下（<span style='color:red;'>此处理解有误，参见下面的评论区</span>）：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253623.png" alt="update-index-locks.png"></p>
<p>RC 和 RR 没有区别。</p>
<h2 id="三、复杂条件加锁分析"><a href="#三、复杂条件加锁分析" class="headerlink" title="三、复杂条件加锁分析"></a>三、复杂条件加锁分析</h2><p>前面的例子都是非常简单的 SQL，只包含一个 WHERE 条件，并且是等值查询，当 SQL 语句中包含多个条件时，对索引的分析就相当重要了。因为我们知道行锁最终都是加在索引上的，如果我们连执行 SQL 语句时会使用哪个索引都不知道，又怎么去分析这个 SQL 所加的锁呢？</p>
<p>MySQL 的索引是一个很复杂的话题，甚至可以写一本书出来了。这里就只是学习一下在对复杂 SQL 加锁分析之前如何先对索引进行分析。譬如下面这样的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE name = &#x27;Tom&#x27; AND age = 22;</span><br></pre></td></tr></table></figure>



<p>其中 name 和 age 两个字段都是索引，那么该如何加锁？这其实取决于 MySQL 用哪个索引。可以用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">EXPLAIN 命令</a>分析 MySQL 是如何执行这条 SQL 的，通过这个命令可以知道 MySQL 会使用哪些索引以及怎么用索引来执行 SQL 的，只有执行会用到的索引才有可能被加锁，没有使用的索引是不加锁的，这里有<a target="_blank" rel="noopener" href="http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html">一篇 EXPLAIN 的博客</a>可以参考。也可以使用 MySQL 的 <a target="_blank" rel="noopener" href="http://mysqllover.com/?p=708">optimizer_trace 功能</a> 来对 SQL 进行分析，它支持将执行的 SQL 的查询计划树记录下来，这个稍微有点难度，有兴趣的同学可以研究下。那么 MySQL 是如何选择合适的索引呢？其实 MySQL 会给每一个索引一个指标，叫做索引的选择性，这个值越高表示使用这个索引能最大程度的过滤更多的记录，关于这个，又是另一个话题了。</p>
<p>当然，从两个索引中选择一个索引来用，这种情况的加锁分析和我们上一节讨论的情形并没有本质的区别，只需要将那个没有用索引的 WHERE 条件当成普通的过滤条件就好了。这里我们会把用到的索引称为 <strong>Index Key</strong>，而另一个条件称为 <strong>Table Filter</strong>。譬如这里如果用到的索引为 age，那么 age 就是 Index Key，而 name &#x3D; ‘Tom’ 就是 Table Filter。Index Key 又分为 First Key 和 Last Key，如果 Index Key 是范围查询的话，如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE name = &#x27;Tom&#x27; AND age &gt; 22 AND age &lt; 25;</span><br></pre></td></tr></table></figure>



<p>其中 First Key 为 age &gt; 22，Last Key 为 age &lt; 25。</p>
<p>所以我们在加锁分析时，只需要确定 Index Key 即可，锁是加在 First Key 和 Last Key 之间的记录上的，如果隔离级别为 RR，同样会有间隙锁。要注意的是，当索引为复合索引时，Index Key 可能会有多个，何登成的这篇博客《SQL中的where条件，在数据库中提取与应用浅析》 详细介绍了如何从一个复杂的 WHERE 条件中提取出 Index Key，推荐一读。<a target="_blank" rel="noopener" href="http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html">这里</a> 也有一篇博客介绍了 MySQL 是如何利用索引的。</p>
<p>当索引为复合索引时，不仅可能有多个 <strong>Index Key</strong>，而且还可能有 <strong>Index Filter</strong>。所谓 Index Filter，就是复合索引中除 Index Key 之外的其他可用于过滤的条件。如果 MySQL 是 5.6 之前的版本，Index Filter 和 Table Filter 没有区别，统统将 Index First Key 与 Index Last Key 范围内的索引记录，回表读取完整记录，然后返回给 MySQL Server 层进行过滤。而在 MySQL 5.6 之后，Index Filter 与 Table Filter 分离，Index Filter 下降到 InnoDB 的索引层面进行过滤，减少了回表与返回 MySQL Server 层的记录交互开销，提高了SQL的执行效率，这就是传说中的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html">ICP（Index Condition Pushdown）</a>，使用 Index Filter 过滤不满足条件的记录，无需加锁。</p>
<p>这里引用何登成前辈博客中的一个例子：</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062253509.png" alt="complicated-sql-locks.png"></p>
<p>可以看到 pubtime &gt; 1 and pubtime &lt; 20 为 Index First Key 和 Index Last Key，MySQL 会在这个范围内加上记录锁和间隙锁；userid &#x3D; ‘hdc’ 为 Index Filter，这个过滤条件可以在索引层面就可以过滤掉一条记录，因此如果数据库支持 ICP 的话，(4, yyy, 3) 这条记录就不会加锁；comment is not NULL 为 Table Filter，虽然这个条件也可以过滤一条记录，但是它不能在索引层面过滤，而是在根据索引读取了整条记录之后才过滤的，因此加锁并不能省略。</p>
<h2 id="四、DELETE-语句加锁分析"><a href="#四、DELETE-语句加锁分析" class="headerlink" title="四、DELETE 语句加锁分析"></a>四、DELETE 语句加锁分析</h2><p>一般来说，DELETE 的加锁和 SELECT FOR UPDATE 或 UPDATE 并没有太大的差异，DELETE 语句一样会有下面这些情况：</p>
<ul>
<li>聚簇索引，查询命中：DELETE FROM students WHERE id &#x3D; 15;</li>
<li>聚簇索引，查询未命中：DELETE FROM students WHERE id &#x3D; 16;</li>
<li>二级唯一索引，查询命中：DELETE FROM students WHERE no &#x3D; ‘S0003’;</li>
<li>二级唯一索引，查询未命中：DELETE FROM students WHERE no &#x3D; ‘S0008’;</li>
<li>二级非唯一索引，查询命中：DELETE FROM students WHERE name &#x3D; ‘Tom’;</li>
<li>二级非唯一索引，查询未命中：DELETE FROM students WHERE name &#x3D; ‘John’;</li>
<li>无索引：DELETE FROM students WHERE score &#x3D; 22;</li>
<li>聚簇索引，范围查询：DELETE FROM students WHERE id &lt;&#x3D; 20;</li>
<li>二级索引，范围查询：DELETE FROM students WHERE age &lt;&#x3D; 23;</li>
</ul>
<p>针对这些情况的加锁分析和上文一致，这里不再赘述。</p>
<p>那么 DELETE 语句和 UPDATE 语句的加锁到底会有什么不同呢？我们知道，在 MySQL 数据库中，执行 DELETE 语句其实并没有直接删除记录，而是在记录上打上一个删除标记，然后通过后台的一个叫做 purge 的线程来清理。从这一点来看，DELETE 和 UPDATE 确实是非常相像。事实上，DELETE 和 UPDATE 的加锁也几乎是一样的，这里要单独加一节来说明 DELETE 语句的加锁分析，其实并不是因为 DELETE 语句的加锁和其他语句有所不同，而是因为 DELETE 语句导致多了一种特殊类型的记录：标记为删除的记录，对于这种类型记录，它的加锁和其他记录的加锁机制不一样。所以这一节的标题叫做 <strong>标记为删除的记录的加锁分析</strong> 可能更合适。</p>
<p>那么问题又来了：什么情况下会对已标记为删除的记录加锁呢？我总结下来会有两种情况：<strong>阻塞后加锁</strong> 和 <strong>快照读后加锁</strong>（自己取得名字），下面分别介绍。</p>
<p><strong>阻塞后加锁</strong> 如下图所示，事务 A 删除 id &#x3D; 18 这条记录，同时事务 B 也删除 id &#x3D; 18 这条记录，很显然，id 为主键，DELETE 语句需要获取 X 记录锁，事务 B 阻塞。事务 A 提交之后，id &#x3D; 18 这条记录被标记为删除，此时事务 B 就需要对已删除记录进行加锁。</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062254519.png" alt="delete-locks-after-block.png"></p>
<p><strong>快照读后加锁</strong> 如下图所示，事务 A 删除 id &#x3D; 18 这条记录，并提交。事务 B 在事务 A 提交之前有一次 id &#x3D; 18 的快照读，所以在后面删除 id &#x3D; 18 这条记录的时候就需要对已删除记录加锁了。如果没有事务开头的这个快照读，DELETE 语句就只是简单的删除一条不存在的记录。</p>
<p><img src="https://cdn.0x4096.com/cdn/image/202306062254924.png" alt="delete-locks-after-snapshot-read.png"></p>
<p>注意，上面的事务 B 不限于 DELETE 语句，换成 UPDATE 或 SELECT FOR UPDATE 同样适用。网上对这种删除记录的加锁分析并不多，我通过自己做的实验，得到了下面这些结论，如有不正确的地方，欢迎斧正。（实验环境，MySQL 版本：5.7，隔离级别：RR）</p>
<ul>
<li>删除记录为聚簇索引<ul>
<li>阻塞后加锁：在删除记录上加 X 记录锁（rec but not gap），并在删除的后一条记录上加间隙锁（gap before rec）</li>
<li>快照读后加锁：在删除记录上加 X 记录锁（rec but not gap）</li>
</ul>
</li>
<li>删除记录为二级索引（唯一索引和非唯一索引都适用）<ul>
<li>阻塞后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
<li>快照读后加锁：在删除记录上加 Next-key 锁，并在删除的后一条记录上加间隙锁</li>
</ul>
</li>
</ul>
<p>要注意的是，这里的隔离级别为 RR，如果在 RC 隔离级别下，加锁过程应该会不一样，感兴趣的同学可以自行实验。关于 DELETE 语句的加锁，何登成前辈在他的博客：《一个最不可思议的MySQL死锁分析》里面有详细的分析，并介绍了页面锁的相关概念，还原了仅仅只有一条 DELETE 语句也会造成死锁的整个过程，讲的很精彩。</p>
<h2 id="五、INSERT-语句加锁分析"><a href="#五、INSERT-语句加锁分析" class="headerlink" title="五、INSERT 语句加锁分析"></a>五、INSERT 语句加锁分析</h2><p>上面所提到的加锁分析，都是针对 SELECT FOR UPDATE、UPDATE、DELETE 等进行的，那么针对 INSERT 加锁过程又是怎样的呢？我们下面继续探索。</p>
<p>还是用 students 表来实验，譬如我们执行下面的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into students(no, name, age, score) value(&#x27;S0008&#x27;, &#x27;John&#x27;, 26, 87);</span><br></pre></td></tr></table></figure>



<p>然后我们用 <code>show engine innodb status\G</code> 查询事务的锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---TRANSACTION 3774, ACTIVE 2 sec</span><br><span class="line">1 lock struct(s), heap size 1136, 0 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 150, OS thread handle 10420, query id 3125 localhost ::1 root</span><br><span class="line">TABLE LOCK table `sys`.`t3` trx id 3774 lock mode IX</span><br></pre></td></tr></table></figure>



<p>我们发现除了一个 IX 的 TABLE LOCK 之外，就没有其他的锁了，难道 INSERT 不加锁？一般来说，加锁都是对表中已有的记录进行加锁，而 INSERT 语句是插入一条新的纪录，这条记录表中本来就没有，那是不是就不需要加锁了？显然不是，至少有两个原因可以说明 INSERT 加了锁：</p>
<ol>
<li>为了防止幻读，如果记录之间加有 GAP 锁，此时不能 INSERT；</li>
<li>如果 INSERT 的记录和已有记录造成唯一键冲突，此时不能 INSERT；</li>
</ol>
<p>要解决这两个问题，都是靠锁来解决的（第一个加插入意向锁，第二个加 S 锁进行当前读），只是在 INSERT 的时候如果没有出现这两种情况，那么锁就是隐式的，只是我们看不到而已。这里我们不得不提一个概念叫 <strong>隐式锁（Implicit Lock）</strong>，它对我们分析 INSERT 语句的加锁过程至关重要。</p>
<p>关于隐式锁，这篇文章<a target="_blank" rel="noopener" href="http://www.uml.org.cn/sjjm/201205302.asp">《MySQL数据库InnoDB存储引擎中的锁机制》</a>对其做了详细的说明，讲的非常清楚，推荐一读。可以参考上一篇介绍的悲观锁和乐观锁。</p>
<blockquote>
<p>锁是一种悲观的顺序化机制，它假设很可能发生冲突，因此在操作数据时，就加锁，如果冲突的可能性很小，多数的锁都是不必要的。Innodb 实现了一个延迟加锁的机制来减少加锁的数量，这被称为隐式锁。</p>
<p>隐式锁中有个重要的元素：事务ID（trx_id）。隐式锁的逻辑过程如下：</p>
<p>A. InnoDB 的每条记录中都有一个隐含的 trx_id 字段，这个字段存在于簇索引的 B+Tree 中;<br>B. 在操作一条记录前，首先根据记录中的 trx_id 检查该事务是否是活动的事务（未提交或回滚），如果是活动的事务，首先将隐式锁转换为显式锁（就是为该事务添加一个锁）；<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为 waiting 状态；如果没有冲突不加锁，跳到 E；<br>D. 等待加锁成功，被唤醒，或者超时；<br>E. 写数据，并将自己的 trx_id 写入 trx_id 字段。</p>
<p>隐式锁的特点是只有在可能发生冲突时才加锁，减少了锁的数量。另外，隐式锁是针对被修改的 B+Tree 记录，因此都是 Record 类型的锁，不可能是 Gap 或 Next-Key 类型。</p>
<ol>
<li>INSERT 操作只加隐式锁，不需要显示加锁；</li>
<li>UPDATE、DELETE 在查询时，直接对查询用的 Index 和主键使用显示锁，其他索引上使用隐式锁。</li>
</ol>
<p>理论上说，可以对主键使用隐式锁的。提前使用显示锁应该是为了减少死锁的可能性。INSERT，UPDATE，DELETE 对 B+Tree 们的操作都是从主键的 B+Tree 开始，因此对主键加锁可以有效的阻止死锁。</p>
</blockquote>
<p>INSERT 加锁流程如下（<a target="_blank" rel="noopener" href="http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/">参考</a>）：</p>
<ul>
<li>首先对插入的间隙加插入意向锁（Insert Intension Locks）<ul>
<li>如果该间隙已被加上了 GAP 锁或 Next-Key 锁，则加锁失败进入等待；</li>
<li>如果没有，则加锁成功，表示可以插入；</li>
</ul>
</li>
<li>然后判断插入记录是否有唯一键，如果有，则进行唯一性约束检查<ul>
<li>如果不存在相同键值，则完成插入</li>
<li>如果存在相同键值，则判断该键值是否加锁<ul>
<li>如果没有锁， 判断该记录是否被标记为删除<ul>
<li>如果标记为删除，说明事务已经提交，还没来得及 purge，这时加 S 锁等待；</li>
<li>如果没有标记删除，则报 1062 duplicate key 错误；</li>
</ul>
</li>
<li>如果有锁，说明该记录正在处理（新增、删除或更新），且事务还未提交，加 S 锁等待；</li>
</ul>
</li>
</ul>
</li>
<li>插入记录并对记录加 X 记录锁；</li>
</ul>
<p>这里的表述其实并不准确，有兴趣的同学可以去阅读 InnoDb 的源码分析 INSERT 语句具体的加锁过程，我在 <a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-source-code.html">《读 MySQL 源码再看 INSERT 加锁流程》</a> 这篇博客中有详细的介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>何登成的技术博客 - MySQL 加锁处理分析</li>
<li>何登成的技术博客 - MySQL+InnoDB semi-consitent read原理及实现分析</li>
<li>何登成的技术博客 - SQL中的where条件，在数据库中提取与应用浅析</li>
<li>何登成的技术博客 - 一个最不可思议的MySQL死锁分析</li>
<li><a target="_blank" rel="noopener" href="http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/">Yilun Fan’s Blog - MySQL加锁分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.fordba.com/spend-10-min-to-understand-how-mysql-use-index.html">10分钟让你明白MySQL是如何利用索引的</a></li>
<li><a target="_blank" rel="noopener" href="http://www.fordba.com/locks-set-by-different-sql-statements-in-innodb.html">MySQL innodb中各种SQL语句加锁分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yelbosh/p/5813865.html">MySQL的并发控制与加锁分析</a></li>
<li>[克鲁斯卡尔的博客 - InnoDB 锁](<a target="_blank" rel="noopener" href="http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB">http://novoland.github.io/数据库/2015/08/17/InnoDB</a> 锁.html)</li>
<li><a target="_blank" rel="noopener" href="http://www.uml.org.cn/sjjm/201205302.asp">MySQL数据库InnoDB存储引擎中的锁机制</a></li>
<li><a target="_blank" rel="noopener" href="http://www.fordba.com/lock-analyse-of-delete.html">MySQL DELETE 删除语句加锁分析</a></li>
<li><a target="_blank" rel="noopener" href="http://keithlan.github.io/2017/06/21/innodb_locks_algorithms/">MySQL锁系列（七）之 锁算法详解</a></li>
<li>[<a target="_blank" rel="noopener" href="http://mysqllover.com/?p=708">MySQL 5.6] 初识5.6的optimizer trace</a></li>
<li>[<a target="_blank" rel="noopener" href="http://mysqllover.com/?p=431">MySQL学习] Innodb锁系统(4) Insert&#x2F;Delete 锁处理及死锁示例分析</a></li>
</ol>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag"># 经验</a>
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/19/talk-about-a-promotion.html" rel="prev" title="谈一次晋升">
                  <i class="fa fa-chevron-left"></i> 谈一次晋升
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/28/mysql-lock-type.html" rel="next" title="「转载」解决死锁之路2 - 了解常见的锁类型">
                  「转载」解决死锁之路2 - 了解常见的锁类型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">0x4096</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">116k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:45</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

  <div class="powered-by">
      <a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"> 
         <image src="https://cdn.0x4096.com/cdn/image/ypy.jpeg" width="300px" />
      </a>
  </div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
